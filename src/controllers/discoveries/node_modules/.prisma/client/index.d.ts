
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Discoveries
 * 
 */
export type Discoveries = {
  id: number
  email: string
  typeform_id: string
  BMR: number
  carbs_macronutrients: number
  protein_macronutrients: number
  fat_macronutrients: number
  carbs_per_meal: number
  protein_per_meal: number
  fat_per_meal: number
  calorie_per_meal: number
}

/**
 * Model Customers
 * 
 */
export type Customers = {
  id: number
  uuid: string | null
  email: string
  age: number | null
  weightKg: number | null
  heightCm: number | null
  gender: string | null
  activeLevel: string | null
  mealsPerDay: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateCustomerNutritionNeed
 * 
 */
export type IntermediateCustomerNutritionNeed = {
  customerNutritionNeedId: number
  customerId: number
  nutritionValue: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model CustomerNutritionNeed
 * 
 */
export type CustomerNutritionNeed = {
  id: number
  name: string
  label: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateCustomerMedicalCondition
 * 
 */
export type IntermediateCustomerMedicalCondition = {
  medicalConditionValue: string
  customerMedicalConditionId: number
  customerId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model CustomerMedicalCondition
 * 
 */
export type CustomerMedicalCondition = {
  id: number
  name: string
  label: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateCustomerFoodType
 * 
 */
export type IntermediateCustomerFoodType = {
  productFoodTypeId: number
  customerId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductFoodType
 * 
 */
export type ProductFoodType = {
  id: number
  label: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateProductFoodType
 * 
 */
export type IntermediateProductFoodType = {
  productFoodTypeId: number
  productId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: number
  activeStatus: ActiveStatus | null
  name: string | null
  label: string | null
  ingredientLabel: string | null
  allergenLabel: string | null
  expertComment: string | null
  productProviderId: number
  productCategoryId: number | null
  productFlavorId: number | null
  productVendorId: number | null
  externalSku: string
  upcCode: string | null
  MSP: number | null
  WSP: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductImage
 * 
 */
export type ProductImage = {
  id: number
  productId: number
  src: string
  position: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateProductCookingMethod
 * 
 */
export type IntermediateProductCookingMethod = {
  productId: number
  productCookingMethodId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateCustomerUnavailableCookingMethod
 * 
 */
export type IntermediateCustomerUnavailableCookingMethod = {
  customerId: number
  productCookingMethodId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductCookingMethod
 * 
 */
export type ProductCookingMethod = {
  id: number
  label: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductFlavor
 * 
 */
export type ProductFlavor = {
  id: number
  label: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductVendor
 * 
 */
export type ProductVendor = {
  id: number
  label: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateCustomerFlavorDislike
 * 
 */
export type IntermediateCustomerFlavorDislike = {
  productFlavorId: number
  customerId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = {
  id: number
  label: string
  name: string
  src: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateCustomerCategoryPreference
 * 
 */
export type IntermediateCustomerCategoryPreference = {
  productCategoryId: number
  customerId: number
  rank: number | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateProductIngredient
 * 
 */
export type IntermediateProductIngredient = {
  productId: number
  productIngredientId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductIngredient
 * 
 */
export type ProductIngredient = {
  id: number
  label: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateCustomerIngredientDislike
 * 
 */
export type IntermediateCustomerIngredientDislike = {
  productIngredientId: number
  customerId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateProductAllergen
 * 
 */
export type IntermediateProductAllergen = {
  productId: number
  productAllergenId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductAllergen
 * 
 */
export type ProductAllergen = {
  id: number
  label: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateCustomerAllergen
 * 
 */
export type IntermediateCustomerAllergen = {
  customerId: number
  productAllergenId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductNutritionFact
 * 
 */
export type ProductNutritionFact = {
  id: number
  productId: number
  quantity: number | null
  servingSize: number | null
  calories: number | null
  totalFatG: number | null
  saturatedFatG: number | null
  transFatG: number | null
  cholesteroleMg: number | null
  sodiumMg: number | null
  totalCarbohydrateG: number | null
  dietaryFiberG: number | null
  totalSugarG: number | null
  addedSugarG: number | null
  proteinG: number | null
  sweet: number | null
  sour: number | null
  salty: number | null
  bitter: number | null
  spicy: number | null
  texture: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ProductProvider
 * 
 */
export type ProductProvider = {
  id: number
  provider: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Survey
 * 
 */
export type Survey = {
  id: number
  name: string
  label: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateSurveyQuestion
 * 
 */
export type IntermediateSurveyQuestion = {
  surveyId: number
  displayOrder: number | null
  surveyQuestionId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SurveyQuestion
 * 
 */
export type SurveyQuestion = {
  id: number
  name: string
  label: string
  questionCategoryId: number
  mustBeAnswered: boolean
  instruction: string | null
  placeholder: string | null
  surveyQuestionAnswerTypeId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QuestionCategory
 * 
 */
export type QuestionCategory = {
  id: number
  label: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SurveyQuestionAnswerType
 * 
 */
export type SurveyQuestionAnswerType = {
  id: number
  name: string
  label: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SurveyQuestionOption
 * 
 */
export type SurveyQuestionOption = {
  id: number
  label: string
  name: string
  surveyQuestionId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SurveyQuestionAnswer
 * 
 */
export type SurveyQuestionAnswer = {
  id: number
  responseId: string | null
  customerId: number
  surveyQuestionId: number
  answerSingleOptionId: number | null
  answerNumeric: number | null
  answerText: string | null
  answerBool: boolean | null
  reason: string | null
  title: string | null
  content: string | null
  answerCount: number | null
  productId: number | null
  orderNumber: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediateSurveyQuestionAnswerProduct
 * 
 */
export type IntermediateSurveyQuestionAnswerProduct = {
  surveyQuestionAnswerId: number
  surveyQuestionOptionId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model CustomerProductDistance
 * 
 */
export type CustomerProductDistance = {
  id: number
  distance: number
  productId: number
  customerId: number
  version: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model CustomerBoxItems
 * 
 */
export type CustomerBoxItems = {
  id: number
  productId: number
  customerId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model QueuedShopifyOrder
 * 
 */
export type QueuedShopifyOrder = {
  id: number
  customerId: number
  orderName: string
  status: QueueStatus
  scheduledAt: string
  orderedAt: string | null
  fulfilledAt: string | null
}

/**
 * Model Practitioner
 * 
 */
export type Practitioner = {
  id: number
  uuid: string
  email: string
  phoneNumber: string | null
  firstName: string
  lastName: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PractitionerSocialMedia
 * 
 */
export type PractitionerSocialMedia = {
  id: number
  practitionerId: number
  instagram: string | null
  facebook: string | null
  twitter: string | null
  website: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PractitionerBox
 * 
 */
export type PractitionerBox = {
  id: number
  practitionerId: number
  label: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model IntermediatePractitionerBoxProduct
 * 
 */
export type IntermediatePractitionerBoxProduct = {
  practitionerBoxId: number
  productId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model PractitionerCustomerOrderHistory
 * 
 */
export type PractitionerCustomerOrderHistory = {
  id: number
  customerId: number
  practitionerBoxId: number
  orderNumber: string
  purchasePrice: number
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ActiveStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type ActiveStatus = (typeof ActiveStatus)[keyof typeof ActiveStatus]


export const QueueStatus: {
  scheduled: 'scheduled',
  ordered: 'ordered',
  fulfilled: 'fulfilled'
};

export type QueueStatus = (typeof QueueStatus)[keyof typeof QueueStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Discoveries
 * const discoveries = await prisma.discoveries.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Discoveries
   * const discoveries = await prisma.discoveries.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.discoveries`: Exposes CRUD operations for the **Discoveries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discoveries
    * const discoveries = await prisma.discoveries.findMany()
    * ```
    */
  get discoveries(): Prisma.DiscoveriesDelegate<GlobalReject>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<GlobalReject>;

  /**
   * `prisma.intermediateCustomerNutritionNeed`: Exposes CRUD operations for the **IntermediateCustomerNutritionNeed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateCustomerNutritionNeeds
    * const intermediateCustomerNutritionNeeds = await prisma.intermediateCustomerNutritionNeed.findMany()
    * ```
    */
  get intermediateCustomerNutritionNeed(): Prisma.IntermediateCustomerNutritionNeedDelegate<GlobalReject>;

  /**
   * `prisma.customerNutritionNeed`: Exposes CRUD operations for the **CustomerNutritionNeed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerNutritionNeeds
    * const customerNutritionNeeds = await prisma.customerNutritionNeed.findMany()
    * ```
    */
  get customerNutritionNeed(): Prisma.CustomerNutritionNeedDelegate<GlobalReject>;

  /**
   * `prisma.intermediateCustomerMedicalCondition`: Exposes CRUD operations for the **IntermediateCustomerMedicalCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateCustomerMedicalConditions
    * const intermediateCustomerMedicalConditions = await prisma.intermediateCustomerMedicalCondition.findMany()
    * ```
    */
  get intermediateCustomerMedicalCondition(): Prisma.IntermediateCustomerMedicalConditionDelegate<GlobalReject>;

  /**
   * `prisma.customerMedicalCondition`: Exposes CRUD operations for the **CustomerMedicalCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerMedicalConditions
    * const customerMedicalConditions = await prisma.customerMedicalCondition.findMany()
    * ```
    */
  get customerMedicalCondition(): Prisma.CustomerMedicalConditionDelegate<GlobalReject>;

  /**
   * `prisma.intermediateCustomerFoodType`: Exposes CRUD operations for the **IntermediateCustomerFoodType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateCustomerFoodTypes
    * const intermediateCustomerFoodTypes = await prisma.intermediateCustomerFoodType.findMany()
    * ```
    */
  get intermediateCustomerFoodType(): Prisma.IntermediateCustomerFoodTypeDelegate<GlobalReject>;

  /**
   * `prisma.productFoodType`: Exposes CRUD operations for the **ProductFoodType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductFoodTypes
    * const productFoodTypes = await prisma.productFoodType.findMany()
    * ```
    */
  get productFoodType(): Prisma.ProductFoodTypeDelegate<GlobalReject>;

  /**
   * `prisma.intermediateProductFoodType`: Exposes CRUD operations for the **IntermediateProductFoodType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateProductFoodTypes
    * const intermediateProductFoodTypes = await prisma.intermediateProductFoodType.findMany()
    * ```
    */
  get intermediateProductFoodType(): Prisma.IntermediateProductFoodTypeDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<GlobalReject>;

  /**
   * `prisma.intermediateProductCookingMethod`: Exposes CRUD operations for the **IntermediateProductCookingMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateProductCookingMethods
    * const intermediateProductCookingMethods = await prisma.intermediateProductCookingMethod.findMany()
    * ```
    */
  get intermediateProductCookingMethod(): Prisma.IntermediateProductCookingMethodDelegate<GlobalReject>;

  /**
   * `prisma.intermediateCustomerUnavailableCookingMethod`: Exposes CRUD operations for the **IntermediateCustomerUnavailableCookingMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateCustomerUnavailableCookingMethods
    * const intermediateCustomerUnavailableCookingMethods = await prisma.intermediateCustomerUnavailableCookingMethod.findMany()
    * ```
    */
  get intermediateCustomerUnavailableCookingMethod(): Prisma.IntermediateCustomerUnavailableCookingMethodDelegate<GlobalReject>;

  /**
   * `prisma.productCookingMethod`: Exposes CRUD operations for the **ProductCookingMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCookingMethods
    * const productCookingMethods = await prisma.productCookingMethod.findMany()
    * ```
    */
  get productCookingMethod(): Prisma.ProductCookingMethodDelegate<GlobalReject>;

  /**
   * `prisma.productFlavor`: Exposes CRUD operations for the **ProductFlavor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductFlavors
    * const productFlavors = await prisma.productFlavor.findMany()
    * ```
    */
  get productFlavor(): Prisma.ProductFlavorDelegate<GlobalReject>;

  /**
   * `prisma.productVendor`: Exposes CRUD operations for the **ProductVendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVendors
    * const productVendors = await prisma.productVendor.findMany()
    * ```
    */
  get productVendor(): Prisma.ProductVendorDelegate<GlobalReject>;

  /**
   * `prisma.intermediateCustomerFlavorDislike`: Exposes CRUD operations for the **IntermediateCustomerFlavorDislike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateCustomerFlavorDislikes
    * const intermediateCustomerFlavorDislikes = await prisma.intermediateCustomerFlavorDislike.findMany()
    * ```
    */
  get intermediateCustomerFlavorDislike(): Prisma.IntermediateCustomerFlavorDislikeDelegate<GlobalReject>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<GlobalReject>;

  /**
   * `prisma.intermediateCustomerCategoryPreference`: Exposes CRUD operations for the **IntermediateCustomerCategoryPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateCustomerCategoryPreferences
    * const intermediateCustomerCategoryPreferences = await prisma.intermediateCustomerCategoryPreference.findMany()
    * ```
    */
  get intermediateCustomerCategoryPreference(): Prisma.IntermediateCustomerCategoryPreferenceDelegate<GlobalReject>;

  /**
   * `prisma.intermediateProductIngredient`: Exposes CRUD operations for the **IntermediateProductIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateProductIngredients
    * const intermediateProductIngredients = await prisma.intermediateProductIngredient.findMany()
    * ```
    */
  get intermediateProductIngredient(): Prisma.IntermediateProductIngredientDelegate<GlobalReject>;

  /**
   * `prisma.productIngredient`: Exposes CRUD operations for the **ProductIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductIngredients
    * const productIngredients = await prisma.productIngredient.findMany()
    * ```
    */
  get productIngredient(): Prisma.ProductIngredientDelegate<GlobalReject>;

  /**
   * `prisma.intermediateCustomerIngredientDislike`: Exposes CRUD operations for the **IntermediateCustomerIngredientDislike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateCustomerIngredientDislikes
    * const intermediateCustomerIngredientDislikes = await prisma.intermediateCustomerIngredientDislike.findMany()
    * ```
    */
  get intermediateCustomerIngredientDislike(): Prisma.IntermediateCustomerIngredientDislikeDelegate<GlobalReject>;

  /**
   * `prisma.intermediateProductAllergen`: Exposes CRUD operations for the **IntermediateProductAllergen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateProductAllergens
    * const intermediateProductAllergens = await prisma.intermediateProductAllergen.findMany()
    * ```
    */
  get intermediateProductAllergen(): Prisma.IntermediateProductAllergenDelegate<GlobalReject>;

  /**
   * `prisma.productAllergen`: Exposes CRUD operations for the **ProductAllergen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAllergens
    * const productAllergens = await prisma.productAllergen.findMany()
    * ```
    */
  get productAllergen(): Prisma.ProductAllergenDelegate<GlobalReject>;

  /**
   * `prisma.intermediateCustomerAllergen`: Exposes CRUD operations for the **IntermediateCustomerAllergen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateCustomerAllergens
    * const intermediateCustomerAllergens = await prisma.intermediateCustomerAllergen.findMany()
    * ```
    */
  get intermediateCustomerAllergen(): Prisma.IntermediateCustomerAllergenDelegate<GlobalReject>;

  /**
   * `prisma.productNutritionFact`: Exposes CRUD operations for the **ProductNutritionFact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductNutritionFacts
    * const productNutritionFacts = await prisma.productNutritionFact.findMany()
    * ```
    */
  get productNutritionFact(): Prisma.ProductNutritionFactDelegate<GlobalReject>;

  /**
   * `prisma.productProvider`: Exposes CRUD operations for the **ProductProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductProviders
    * const productProviders = await prisma.productProvider.findMany()
    * ```
    */
  get productProvider(): Prisma.ProductProviderDelegate<GlobalReject>;

  /**
   * `prisma.survey`: Exposes CRUD operations for the **Survey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surveys
    * const surveys = await prisma.survey.findMany()
    * ```
    */
  get survey(): Prisma.SurveyDelegate<GlobalReject>;

  /**
   * `prisma.intermediateSurveyQuestion`: Exposes CRUD operations for the **IntermediateSurveyQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateSurveyQuestions
    * const intermediateSurveyQuestions = await prisma.intermediateSurveyQuestion.findMany()
    * ```
    */
  get intermediateSurveyQuestion(): Prisma.IntermediateSurveyQuestionDelegate<GlobalReject>;

  /**
   * `prisma.surveyQuestion`: Exposes CRUD operations for the **SurveyQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyQuestions
    * const surveyQuestions = await prisma.surveyQuestion.findMany()
    * ```
    */
  get surveyQuestion(): Prisma.SurveyQuestionDelegate<GlobalReject>;

  /**
   * `prisma.questionCategory`: Exposes CRUD operations for the **QuestionCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionCategories
    * const questionCategories = await prisma.questionCategory.findMany()
    * ```
    */
  get questionCategory(): Prisma.QuestionCategoryDelegate<GlobalReject>;

  /**
   * `prisma.surveyQuestionAnswerType`: Exposes CRUD operations for the **SurveyQuestionAnswerType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyQuestionAnswerTypes
    * const surveyQuestionAnswerTypes = await prisma.surveyQuestionAnswerType.findMany()
    * ```
    */
  get surveyQuestionAnswerType(): Prisma.SurveyQuestionAnswerTypeDelegate<GlobalReject>;

  /**
   * `prisma.surveyQuestionOption`: Exposes CRUD operations for the **SurveyQuestionOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyQuestionOptions
    * const surveyQuestionOptions = await prisma.surveyQuestionOption.findMany()
    * ```
    */
  get surveyQuestionOption(): Prisma.SurveyQuestionOptionDelegate<GlobalReject>;

  /**
   * `prisma.surveyQuestionAnswer`: Exposes CRUD operations for the **SurveyQuestionAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyQuestionAnswers
    * const surveyQuestionAnswers = await prisma.surveyQuestionAnswer.findMany()
    * ```
    */
  get surveyQuestionAnswer(): Prisma.SurveyQuestionAnswerDelegate<GlobalReject>;

  /**
   * `prisma.intermediateSurveyQuestionAnswerProduct`: Exposes CRUD operations for the **IntermediateSurveyQuestionAnswerProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediateSurveyQuestionAnswerProducts
    * const intermediateSurveyQuestionAnswerProducts = await prisma.intermediateSurveyQuestionAnswerProduct.findMany()
    * ```
    */
  get intermediateSurveyQuestionAnswerProduct(): Prisma.IntermediateSurveyQuestionAnswerProductDelegate<GlobalReject>;

  /**
   * `prisma.customerProductDistance`: Exposes CRUD operations for the **CustomerProductDistance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerProductDistances
    * const customerProductDistances = await prisma.customerProductDistance.findMany()
    * ```
    */
  get customerProductDistance(): Prisma.CustomerProductDistanceDelegate<GlobalReject>;

  /**
   * `prisma.customerBoxItems`: Exposes CRUD operations for the **CustomerBoxItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerBoxItems
    * const customerBoxItems = await prisma.customerBoxItems.findMany()
    * ```
    */
  get customerBoxItems(): Prisma.CustomerBoxItemsDelegate<GlobalReject>;

  /**
   * `prisma.queuedShopifyOrder`: Exposes CRUD operations for the **QueuedShopifyOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueuedShopifyOrders
    * const queuedShopifyOrders = await prisma.queuedShopifyOrder.findMany()
    * ```
    */
  get queuedShopifyOrder(): Prisma.QueuedShopifyOrderDelegate<GlobalReject>;

  /**
   * `prisma.practitioner`: Exposes CRUD operations for the **Practitioner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Practitioners
    * const practitioners = await prisma.practitioner.findMany()
    * ```
    */
  get practitioner(): Prisma.PractitionerDelegate<GlobalReject>;

  /**
   * `prisma.practitionerSocialMedia`: Exposes CRUD operations for the **PractitionerSocialMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PractitionerSocialMedias
    * const practitionerSocialMedias = await prisma.practitionerSocialMedia.findMany()
    * ```
    */
  get practitionerSocialMedia(): Prisma.PractitionerSocialMediaDelegate<GlobalReject>;

  /**
   * `prisma.practitionerBox`: Exposes CRUD operations for the **PractitionerBox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PractitionerBoxes
    * const practitionerBoxes = await prisma.practitionerBox.findMany()
    * ```
    */
  get practitionerBox(): Prisma.PractitionerBoxDelegate<GlobalReject>;

  /**
   * `prisma.intermediatePractitionerBoxProduct`: Exposes CRUD operations for the **IntermediatePractitionerBoxProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntermediatePractitionerBoxProducts
    * const intermediatePractitionerBoxProducts = await prisma.intermediatePractitionerBoxProduct.findMany()
    * ```
    */
  get intermediatePractitionerBoxProduct(): Prisma.IntermediatePractitionerBoxProductDelegate<GlobalReject>;

  /**
   * `prisma.practitionerCustomerOrderHistory`: Exposes CRUD operations for the **PractitionerCustomerOrderHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PractitionerCustomerOrderHistories
    * const practitionerCustomerOrderHistories = await prisma.practitionerCustomerOrderHistory.findMany()
    * ```
    */
  get practitionerCustomerOrderHistory(): Prisma.PractitionerCustomerOrderHistoryDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.6.0
   * Query Engine version: dc520b92b1ebb2d28dc3161f9f82e875bd35d727
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Discoveries: 'Discoveries',
    Customers: 'Customers',
    IntermediateCustomerNutritionNeed: 'IntermediateCustomerNutritionNeed',
    CustomerNutritionNeed: 'CustomerNutritionNeed',
    IntermediateCustomerMedicalCondition: 'IntermediateCustomerMedicalCondition',
    CustomerMedicalCondition: 'CustomerMedicalCondition',
    IntermediateCustomerFoodType: 'IntermediateCustomerFoodType',
    ProductFoodType: 'ProductFoodType',
    IntermediateProductFoodType: 'IntermediateProductFoodType',
    Product: 'Product',
    ProductImage: 'ProductImage',
    IntermediateProductCookingMethod: 'IntermediateProductCookingMethod',
    IntermediateCustomerUnavailableCookingMethod: 'IntermediateCustomerUnavailableCookingMethod',
    ProductCookingMethod: 'ProductCookingMethod',
    ProductFlavor: 'ProductFlavor',
    ProductVendor: 'ProductVendor',
    IntermediateCustomerFlavorDislike: 'IntermediateCustomerFlavorDislike',
    ProductCategory: 'ProductCategory',
    IntermediateCustomerCategoryPreference: 'IntermediateCustomerCategoryPreference',
    IntermediateProductIngredient: 'IntermediateProductIngredient',
    ProductIngredient: 'ProductIngredient',
    IntermediateCustomerIngredientDislike: 'IntermediateCustomerIngredientDislike',
    IntermediateProductAllergen: 'IntermediateProductAllergen',
    ProductAllergen: 'ProductAllergen',
    IntermediateCustomerAllergen: 'IntermediateCustomerAllergen',
    ProductNutritionFact: 'ProductNutritionFact',
    ProductProvider: 'ProductProvider',
    Survey: 'Survey',
    IntermediateSurveyQuestion: 'IntermediateSurveyQuestion',
    SurveyQuestion: 'SurveyQuestion',
    QuestionCategory: 'QuestionCategory',
    SurveyQuestionAnswerType: 'SurveyQuestionAnswerType',
    SurveyQuestionOption: 'SurveyQuestionOption',
    SurveyQuestionAnswer: 'SurveyQuestionAnswer',
    IntermediateSurveyQuestionAnswerProduct: 'IntermediateSurveyQuestionAnswerProduct',
    CustomerProductDistance: 'CustomerProductDistance',
    CustomerBoxItems: 'CustomerBoxItems',
    QueuedShopifyOrder: 'QueuedShopifyOrder',
    Practitioner: 'Practitioner',
    PractitionerSocialMedia: 'PractitionerSocialMedia',
    PractitionerBox: 'PractitionerBox',
    IntermediatePractitionerBoxProduct: 'IntermediatePractitionerBoxProduct',
    PractitionerCustomerOrderHistory: 'PractitionerCustomerOrderHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomersCountOutputType
   */


  export type CustomersCountOutputType = {
    intermediateCustomerNutritionNeeds: number
    intermediateCustomerMedicalConditions: number
    intermediateCustomerAllergens: number
    surveyQuestionAnswer: number
    customerProductDistances: number
    customerBoxItems: number
    queuedShopifyOrder: number
    intermediateCustomerFlavorDislikes: number
    intermediateCustomerCategoryPreferences: number
    intermediateCustomerIngredientDislikes: number
    intermediateCustomerFoodTypes: number
    intermediateCustomerUnavailableCookingMethods: number
    practitionerCustomerOrderHistory: number
  }

  export type CustomersCountOutputTypeSelect = {
    intermediateCustomerNutritionNeeds?: boolean
    intermediateCustomerMedicalConditions?: boolean
    intermediateCustomerAllergens?: boolean
    surveyQuestionAnswer?: boolean
    customerProductDistances?: boolean
    customerBoxItems?: boolean
    queuedShopifyOrder?: boolean
    intermediateCustomerFlavorDislikes?: boolean
    intermediateCustomerCategoryPreferences?: boolean
    intermediateCustomerIngredientDislikes?: boolean
    intermediateCustomerFoodTypes?: boolean
    intermediateCustomerUnavailableCookingMethods?: boolean
    practitionerCustomerOrderHistory?: boolean
  }

  export type CustomersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CustomersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CustomersCountOutputType
    : S extends undefined
    ? never
    : S extends CustomersCountOutputTypeArgs
    ?'include' extends U
    ? CustomersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CustomersCountOutputType ?CustomersCountOutputType [P]
  : 
     never
  } 
    : CustomersCountOutputType
  : CustomersCountOutputType




  // Custom InputTypes

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     * 
    **/
    select?: CustomersCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomerNutritionNeedCountOutputType
   */


  export type CustomerNutritionNeedCountOutputType = {
    intermediateCustomerNutritionNeed: number
  }

  export type CustomerNutritionNeedCountOutputTypeSelect = {
    intermediateCustomerNutritionNeed?: boolean
  }

  export type CustomerNutritionNeedCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CustomerNutritionNeedCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CustomerNutritionNeedCountOutputType
    : S extends undefined
    ? never
    : S extends CustomerNutritionNeedCountOutputTypeArgs
    ?'include' extends U
    ? CustomerNutritionNeedCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CustomerNutritionNeedCountOutputType ?CustomerNutritionNeedCountOutputType [P]
  : 
     never
  } 
    : CustomerNutritionNeedCountOutputType
  : CustomerNutritionNeedCountOutputType




  // Custom InputTypes

  /**
   * CustomerNutritionNeedCountOutputType without action
   */
  export type CustomerNutritionNeedCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeedCountOutputType
     * 
    **/
    select?: CustomerNutritionNeedCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomerMedicalConditionCountOutputType
   */


  export type CustomerMedicalConditionCountOutputType = {
    intermediateCustomerMedicalConditions: number
  }

  export type CustomerMedicalConditionCountOutputTypeSelect = {
    intermediateCustomerMedicalConditions?: boolean
  }

  export type CustomerMedicalConditionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CustomerMedicalConditionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CustomerMedicalConditionCountOutputType
    : S extends undefined
    ? never
    : S extends CustomerMedicalConditionCountOutputTypeArgs
    ?'include' extends U
    ? CustomerMedicalConditionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CustomerMedicalConditionCountOutputType ?CustomerMedicalConditionCountOutputType [P]
  : 
     never
  } 
    : CustomerMedicalConditionCountOutputType
  : CustomerMedicalConditionCountOutputType




  // Custom InputTypes

  /**
   * CustomerMedicalConditionCountOutputType without action
   */
  export type CustomerMedicalConditionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalConditionCountOutputType
     * 
    **/
    select?: CustomerMedicalConditionCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductFoodTypeCountOutputType
   */


  export type ProductFoodTypeCountOutputType = {
    intermediateCustomerFoodTypes: number
    intermediateProductFoodTypes: number
  }

  export type ProductFoodTypeCountOutputTypeSelect = {
    intermediateCustomerFoodTypes?: boolean
    intermediateProductFoodTypes?: boolean
  }

  export type ProductFoodTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductFoodTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductFoodTypeCountOutputType
    : S extends undefined
    ? never
    : S extends ProductFoodTypeCountOutputTypeArgs
    ?'include' extends U
    ? ProductFoodTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductFoodTypeCountOutputType ?ProductFoodTypeCountOutputType [P]
  : 
     never
  } 
    : ProductFoodTypeCountOutputType
  : ProductFoodTypeCountOutputType




  // Custom InputTypes

  /**
   * ProductFoodTypeCountOutputType without action
   */
  export type ProductFoodTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodTypeCountOutputType
     * 
    **/
    select?: ProductFoodTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    intermediateProductFoodTypes: number
    intermediateProductIngredients: number
    intermediateProductAllergens: number
    intermediateProductCookingMethods: number
    intermediatePractitionerBoxProduct: number
    surveyQuestionAnswer: number
    customerProductDistances: number
    customerBoxItems: number
    productImages: number
  }

  export type ProductCountOutputTypeSelect = {
    intermediateProductFoodTypes?: boolean
    intermediateProductIngredients?: boolean
    intermediateProductAllergens?: boolean
    intermediateProductCookingMethods?: boolean
    intermediatePractitionerBoxProduct?: boolean
    surveyQuestionAnswer?: boolean
    customerProductDistances?: boolean
    customerBoxItems?: boolean
    productImages?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductCountOutputType ?ProductCountOutputType [P]
  : 
     never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCookingMethodCountOutputType
   */


  export type ProductCookingMethodCountOutputType = {
    intermediateProductCookingMethods: number
    intermediateCustomerUnavailableCookingMethods: number
  }

  export type ProductCookingMethodCountOutputTypeSelect = {
    intermediateProductCookingMethods?: boolean
    intermediateCustomerUnavailableCookingMethods?: boolean
  }

  export type ProductCookingMethodCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCookingMethodCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCookingMethodCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCookingMethodCountOutputTypeArgs
    ?'include' extends U
    ? ProductCookingMethodCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductCookingMethodCountOutputType ?ProductCookingMethodCountOutputType [P]
  : 
     never
  } 
    : ProductCookingMethodCountOutputType
  : ProductCookingMethodCountOutputType




  // Custom InputTypes

  /**
   * ProductCookingMethodCountOutputType without action
   */
  export type ProductCookingMethodCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethodCountOutputType
     * 
    **/
    select?: ProductCookingMethodCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductFlavorCountOutputType
   */


  export type ProductFlavorCountOutputType = {
    products: number
    intermediateCustomerFlavorDislikes: number
  }

  export type ProductFlavorCountOutputTypeSelect = {
    products?: boolean
    intermediateCustomerFlavorDislikes?: boolean
  }

  export type ProductFlavorCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductFlavorCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductFlavorCountOutputType
    : S extends undefined
    ? never
    : S extends ProductFlavorCountOutputTypeArgs
    ?'include' extends U
    ? ProductFlavorCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductFlavorCountOutputType ?ProductFlavorCountOutputType [P]
  : 
     never
  } 
    : ProductFlavorCountOutputType
  : ProductFlavorCountOutputType




  // Custom InputTypes

  /**
   * ProductFlavorCountOutputType without action
   */
  export type ProductFlavorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavorCountOutputType
     * 
    **/
    select?: ProductFlavorCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductVendorCountOutputType
   */


  export type ProductVendorCountOutputType = {
    products: number
  }

  export type ProductVendorCountOutputTypeSelect = {
    products?: boolean
  }

  export type ProductVendorCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductVendorCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductVendorCountOutputType
    : S extends undefined
    ? never
    : S extends ProductVendorCountOutputTypeArgs
    ?'include' extends U
    ? ProductVendorCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductVendorCountOutputType ?ProductVendorCountOutputType [P]
  : 
     never
  } 
    : ProductVendorCountOutputType
  : ProductVendorCountOutputType




  // Custom InputTypes

  /**
   * ProductVendorCountOutputType without action
   */
  export type ProductVendorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductVendorCountOutputType
     * 
    **/
    select?: ProductVendorCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCategoryCountOutputType
   */


  export type ProductCategoryCountOutputType = {
    products: number
    intermediateCustomerCategoryPreferences: number
  }

  export type ProductCategoryCountOutputTypeSelect = {
    products?: boolean
    intermediateCustomerCategoryPreferences?: boolean
  }

  export type ProductCategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCategoryCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCategoryCountOutputTypeArgs
    ?'include' extends U
    ? ProductCategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductCategoryCountOutputType ?ProductCategoryCountOutputType [P]
  : 
     never
  } 
    : ProductCategoryCountOutputType
  : ProductCategoryCountOutputType




  // Custom InputTypes

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     * 
    **/
    select?: ProductCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductIngredientCountOutputType
   */


  export type ProductIngredientCountOutputType = {
    intermediateProductIngredients: number
    intermediateCustomerIngredientDislikes: number
  }

  export type ProductIngredientCountOutputTypeSelect = {
    intermediateProductIngredients?: boolean
    intermediateCustomerIngredientDislikes?: boolean
  }

  export type ProductIngredientCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductIngredientCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductIngredientCountOutputType
    : S extends undefined
    ? never
    : S extends ProductIngredientCountOutputTypeArgs
    ?'include' extends U
    ? ProductIngredientCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductIngredientCountOutputType ?ProductIngredientCountOutputType [P]
  : 
     never
  } 
    : ProductIngredientCountOutputType
  : ProductIngredientCountOutputType




  // Custom InputTypes

  /**
   * ProductIngredientCountOutputType without action
   */
  export type ProductIngredientCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredientCountOutputType
     * 
    **/
    select?: ProductIngredientCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductAllergenCountOutputType
   */


  export type ProductAllergenCountOutputType = {
    intermediateProductAllergens: number
    intermediateCustomerAllergens: number
  }

  export type ProductAllergenCountOutputTypeSelect = {
    intermediateProductAllergens?: boolean
    intermediateCustomerAllergens?: boolean
  }

  export type ProductAllergenCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductAllergenCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductAllergenCountOutputType
    : S extends undefined
    ? never
    : S extends ProductAllergenCountOutputTypeArgs
    ?'include' extends U
    ? ProductAllergenCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductAllergenCountOutputType ?ProductAllergenCountOutputType [P]
  : 
     never
  } 
    : ProductAllergenCountOutputType
  : ProductAllergenCountOutputType




  // Custom InputTypes

  /**
   * ProductAllergenCountOutputType without action
   */
  export type ProductAllergenCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergenCountOutputType
     * 
    **/
    select?: ProductAllergenCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductProviderCountOutputType
   */


  export type ProductProviderCountOutputType = {
    products: number
  }

  export type ProductProviderCountOutputTypeSelect = {
    products?: boolean
  }

  export type ProductProviderCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductProviderCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductProviderCountOutputType
    : S extends undefined
    ? never
    : S extends ProductProviderCountOutputTypeArgs
    ?'include' extends U
    ? ProductProviderCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductProviderCountOutputType ?ProductProviderCountOutputType [P]
  : 
     never
  } 
    : ProductProviderCountOutputType
  : ProductProviderCountOutputType




  // Custom InputTypes

  /**
   * ProductProviderCountOutputType without action
   */
  export type ProductProviderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductProviderCountOutputType
     * 
    **/
    select?: ProductProviderCountOutputTypeSelect | null
  }



  /**
   * Count Type SurveyCountOutputType
   */


  export type SurveyCountOutputType = {
    intermediateSurveyQuestions: number
  }

  export type SurveyCountOutputTypeSelect = {
    intermediateSurveyQuestions?: boolean
  }

  export type SurveyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SurveyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SurveyCountOutputType
    : S extends undefined
    ? never
    : S extends SurveyCountOutputTypeArgs
    ?'include' extends U
    ? SurveyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyCountOutputType ?SurveyCountOutputType [P]
  : 
     never
  } 
    : SurveyCountOutputType
  : SurveyCountOutputType




  // Custom InputTypes

  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SurveyCountOutputType
     * 
    **/
    select?: SurveyCountOutputTypeSelect | null
  }



  /**
   * Count Type SurveyQuestionCountOutputType
   */


  export type SurveyQuestionCountOutputType = {
    intermediateSurveyQuestions: number
    surveyQuestionOptions: number
    surveyQuestionAnswer: number
  }

  export type SurveyQuestionCountOutputTypeSelect = {
    intermediateSurveyQuestions?: boolean
    surveyQuestionOptions?: boolean
    surveyQuestionAnswer?: boolean
  }

  export type SurveyQuestionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SurveyQuestionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SurveyQuestionCountOutputType
    : S extends undefined
    ? never
    : S extends SurveyQuestionCountOutputTypeArgs
    ?'include' extends U
    ? SurveyQuestionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyQuestionCountOutputType ?SurveyQuestionCountOutputType [P]
  : 
     never
  } 
    : SurveyQuestionCountOutputType
  : SurveyQuestionCountOutputType




  // Custom InputTypes

  /**
   * SurveyQuestionCountOutputType without action
   */
  export type SurveyQuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionCountOutputType
     * 
    **/
    select?: SurveyQuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionCategoryCountOutputType
   */


  export type QuestionCategoryCountOutputType = {
    surveyQuestions: number
  }

  export type QuestionCategoryCountOutputTypeSelect = {
    surveyQuestions?: boolean
  }

  export type QuestionCategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionCategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionCategoryCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionCategoryCountOutputTypeArgs
    ?'include' extends U
    ? QuestionCategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof QuestionCategoryCountOutputType ?QuestionCategoryCountOutputType [P]
  : 
     never
  } 
    : QuestionCategoryCountOutputType
  : QuestionCategoryCountOutputType




  // Custom InputTypes

  /**
   * QuestionCategoryCountOutputType without action
   */
  export type QuestionCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategoryCountOutputType
     * 
    **/
    select?: QuestionCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type SurveyQuestionAnswerTypeCountOutputType
   */


  export type SurveyQuestionAnswerTypeCountOutputType = {
    surveyQuestions: number
  }

  export type SurveyQuestionAnswerTypeCountOutputTypeSelect = {
    surveyQuestions?: boolean
  }

  export type SurveyQuestionAnswerTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SurveyQuestionAnswerTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SurveyQuestionAnswerTypeCountOutputType
    : S extends undefined
    ? never
    : S extends SurveyQuestionAnswerTypeCountOutputTypeArgs
    ?'include' extends U
    ? SurveyQuestionAnswerTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyQuestionAnswerTypeCountOutputType ?SurveyQuestionAnswerTypeCountOutputType [P]
  : 
     never
  } 
    : SurveyQuestionAnswerTypeCountOutputType
  : SurveyQuestionAnswerTypeCountOutputType




  // Custom InputTypes

  /**
   * SurveyQuestionAnswerTypeCountOutputType without action
   */
  export type SurveyQuestionAnswerTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerTypeCountOutputType
     * 
    **/
    select?: SurveyQuestionAnswerTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type SurveyQuestionOptionCountOutputType
   */


  export type SurveyQuestionOptionCountOutputType = {
    surveyQuestionAnswer: number
    intermediateSurveyQuestionAnswerProduct: number
  }

  export type SurveyQuestionOptionCountOutputTypeSelect = {
    surveyQuestionAnswer?: boolean
    intermediateSurveyQuestionAnswerProduct?: boolean
  }

  export type SurveyQuestionOptionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SurveyQuestionOptionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SurveyQuestionOptionCountOutputType
    : S extends undefined
    ? never
    : S extends SurveyQuestionOptionCountOutputTypeArgs
    ?'include' extends U
    ? SurveyQuestionOptionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyQuestionOptionCountOutputType ?SurveyQuestionOptionCountOutputType [P]
  : 
     never
  } 
    : SurveyQuestionOptionCountOutputType
  : SurveyQuestionOptionCountOutputType




  // Custom InputTypes

  /**
   * SurveyQuestionOptionCountOutputType without action
   */
  export type SurveyQuestionOptionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOptionCountOutputType
     * 
    **/
    select?: SurveyQuestionOptionCountOutputTypeSelect | null
  }



  /**
   * Count Type SurveyQuestionAnswerCountOutputType
   */


  export type SurveyQuestionAnswerCountOutputType = {
    intermediateSurveyQuestionAnswerProduct: number
  }

  export type SurveyQuestionAnswerCountOutputTypeSelect = {
    intermediateSurveyQuestionAnswerProduct?: boolean
  }

  export type SurveyQuestionAnswerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SurveyQuestionAnswerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SurveyQuestionAnswerCountOutputType
    : S extends undefined
    ? never
    : S extends SurveyQuestionAnswerCountOutputTypeArgs
    ?'include' extends U
    ? SurveyQuestionAnswerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyQuestionAnswerCountOutputType ?SurveyQuestionAnswerCountOutputType [P]
  : 
     never
  } 
    : SurveyQuestionAnswerCountOutputType
  : SurveyQuestionAnswerCountOutputType




  // Custom InputTypes

  /**
   * SurveyQuestionAnswerCountOutputType without action
   */
  export type SurveyQuestionAnswerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerCountOutputType
     * 
    **/
    select?: SurveyQuestionAnswerCountOutputTypeSelect | null
  }



  /**
   * Count Type PractitionerCountOutputType
   */


  export type PractitionerCountOutputType = {
    practitionerBox: number
  }

  export type PractitionerCountOutputTypeSelect = {
    practitionerBox?: boolean
  }

  export type PractitionerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PractitionerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PractitionerCountOutputType
    : S extends undefined
    ? never
    : S extends PractitionerCountOutputTypeArgs
    ?'include' extends U
    ? PractitionerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PractitionerCountOutputType ?PractitionerCountOutputType [P]
  : 
     never
  } 
    : PractitionerCountOutputType
  : PractitionerCountOutputType




  // Custom InputTypes

  /**
   * PractitionerCountOutputType without action
   */
  export type PractitionerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCountOutputType
     * 
    **/
    select?: PractitionerCountOutputTypeSelect | null
  }



  /**
   * Count Type PractitionerBoxCountOutputType
   */


  export type PractitionerBoxCountOutputType = {
    practitionerCustomerOrderHistory: number
    intermediatePractitionerBoxProduct: number
  }

  export type PractitionerBoxCountOutputTypeSelect = {
    practitionerCustomerOrderHistory?: boolean
    intermediatePractitionerBoxProduct?: boolean
  }

  export type PractitionerBoxCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PractitionerBoxCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PractitionerBoxCountOutputType
    : S extends undefined
    ? never
    : S extends PractitionerBoxCountOutputTypeArgs
    ?'include' extends U
    ? PractitionerBoxCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PractitionerBoxCountOutputType ?PractitionerBoxCountOutputType [P]
  : 
     never
  } 
    : PractitionerBoxCountOutputType
  : PractitionerBoxCountOutputType




  // Custom InputTypes

  /**
   * PractitionerBoxCountOutputType without action
   */
  export type PractitionerBoxCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBoxCountOutputType
     * 
    **/
    select?: PractitionerBoxCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Discoveries
   */


  export type AggregateDiscoveries = {
    _count: DiscoveriesCountAggregateOutputType | null
    _avg: DiscoveriesAvgAggregateOutputType | null
    _sum: DiscoveriesSumAggregateOutputType | null
    _min: DiscoveriesMinAggregateOutputType | null
    _max: DiscoveriesMaxAggregateOutputType | null
  }

  export type DiscoveriesAvgAggregateOutputType = {
    id: number | null
    BMR: number | null
    carbs_macronutrients: number | null
    protein_macronutrients: number | null
    fat_macronutrients: number | null
    carbs_per_meal: number | null
    protein_per_meal: number | null
    fat_per_meal: number | null
    calorie_per_meal: number | null
  }

  export type DiscoveriesSumAggregateOutputType = {
    id: number | null
    BMR: number | null
    carbs_macronutrients: number | null
    protein_macronutrients: number | null
    fat_macronutrients: number | null
    carbs_per_meal: number | null
    protein_per_meal: number | null
    fat_per_meal: number | null
    calorie_per_meal: number | null
  }

  export type DiscoveriesMinAggregateOutputType = {
    id: number | null
    email: string | null
    typeform_id: string | null
    BMR: number | null
    carbs_macronutrients: number | null
    protein_macronutrients: number | null
    fat_macronutrients: number | null
    carbs_per_meal: number | null
    protein_per_meal: number | null
    fat_per_meal: number | null
    calorie_per_meal: number | null
  }

  export type DiscoveriesMaxAggregateOutputType = {
    id: number | null
    email: string | null
    typeform_id: string | null
    BMR: number | null
    carbs_macronutrients: number | null
    protein_macronutrients: number | null
    fat_macronutrients: number | null
    carbs_per_meal: number | null
    protein_per_meal: number | null
    fat_per_meal: number | null
    calorie_per_meal: number | null
  }

  export type DiscoveriesCountAggregateOutputType = {
    id: number
    email: number
    typeform_id: number
    BMR: number
    carbs_macronutrients: number
    protein_macronutrients: number
    fat_macronutrients: number
    carbs_per_meal: number
    protein_per_meal: number
    fat_per_meal: number
    calorie_per_meal: number
    _all: number
  }


  export type DiscoveriesAvgAggregateInputType = {
    id?: true
    BMR?: true
    carbs_macronutrients?: true
    protein_macronutrients?: true
    fat_macronutrients?: true
    carbs_per_meal?: true
    protein_per_meal?: true
    fat_per_meal?: true
    calorie_per_meal?: true
  }

  export type DiscoveriesSumAggregateInputType = {
    id?: true
    BMR?: true
    carbs_macronutrients?: true
    protein_macronutrients?: true
    fat_macronutrients?: true
    carbs_per_meal?: true
    protein_per_meal?: true
    fat_per_meal?: true
    calorie_per_meal?: true
  }

  export type DiscoveriesMinAggregateInputType = {
    id?: true
    email?: true
    typeform_id?: true
    BMR?: true
    carbs_macronutrients?: true
    protein_macronutrients?: true
    fat_macronutrients?: true
    carbs_per_meal?: true
    protein_per_meal?: true
    fat_per_meal?: true
    calorie_per_meal?: true
  }

  export type DiscoveriesMaxAggregateInputType = {
    id?: true
    email?: true
    typeform_id?: true
    BMR?: true
    carbs_macronutrients?: true
    protein_macronutrients?: true
    fat_macronutrients?: true
    carbs_per_meal?: true
    protein_per_meal?: true
    fat_per_meal?: true
    calorie_per_meal?: true
  }

  export type DiscoveriesCountAggregateInputType = {
    id?: true
    email?: true
    typeform_id?: true
    BMR?: true
    carbs_macronutrients?: true
    protein_macronutrients?: true
    fat_macronutrients?: true
    carbs_per_meal?: true
    protein_per_meal?: true
    fat_per_meal?: true
    calorie_per_meal?: true
    _all?: true
  }

  export type DiscoveriesAggregateArgs = {
    /**
     * Filter which Discoveries to aggregate.
     * 
    **/
    where?: DiscoveriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discoveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscoveriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DiscoveriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discoveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discoveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discoveries
    **/
    _count?: true | DiscoveriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscoveriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscoveriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscoveriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscoveriesMaxAggregateInputType
  }

  export type GetDiscoveriesAggregateType<T extends DiscoveriesAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscoveries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscoveries[P]>
      : GetScalarType<T[P], AggregateDiscoveries[P]>
  }




  export type DiscoveriesGroupByArgs = {
    where?: DiscoveriesWhereInput
    orderBy?: Enumerable<DiscoveriesOrderByWithAggregationInput>
    by: Array<DiscoveriesScalarFieldEnum>
    having?: DiscoveriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscoveriesCountAggregateInputType | true
    _avg?: DiscoveriesAvgAggregateInputType
    _sum?: DiscoveriesSumAggregateInputType
    _min?: DiscoveriesMinAggregateInputType
    _max?: DiscoveriesMaxAggregateInputType
  }


  export type DiscoveriesGroupByOutputType = {
    id: number
    email: string
    typeform_id: string
    BMR: number
    carbs_macronutrients: number
    protein_macronutrients: number
    fat_macronutrients: number
    carbs_per_meal: number
    protein_per_meal: number
    fat_per_meal: number
    calorie_per_meal: number
    _count: DiscoveriesCountAggregateOutputType | null
    _avg: DiscoveriesAvgAggregateOutputType | null
    _sum: DiscoveriesSumAggregateOutputType | null
    _min: DiscoveriesMinAggregateOutputType | null
    _max: DiscoveriesMaxAggregateOutputType | null
  }

  type GetDiscoveriesGroupByPayload<T extends DiscoveriesGroupByArgs> = Promise<
    Array<
      PickArray<DiscoveriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscoveriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscoveriesGroupByOutputType[P]>
            : GetScalarType<T[P], DiscoveriesGroupByOutputType[P]>
        }
      >
    >


  export type DiscoveriesSelect = {
    id?: boolean
    email?: boolean
    typeform_id?: boolean
    BMR?: boolean
    carbs_macronutrients?: boolean
    protein_macronutrients?: boolean
    fat_macronutrients?: boolean
    carbs_per_meal?: boolean
    protein_per_meal?: boolean
    fat_per_meal?: boolean
    calorie_per_meal?: boolean
  }

  export type DiscoveriesGetPayload<
    S extends boolean | null | undefined | DiscoveriesArgs,
    U = keyof S
      > = S extends true
        ? Discoveries
    : S extends undefined
    ? never
    : S extends DiscoveriesArgs | DiscoveriesFindManyArgs
    ?'include' extends U
    ? Discoveries 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Discoveries ?Discoveries [P]
  : 
     never
  } 
    : Discoveries
  : Discoveries


  type DiscoveriesCountArgs = Merge<
    Omit<DiscoveriesFindManyArgs, 'select' | 'include'> & {
      select?: DiscoveriesCountAggregateInputType | true
    }
  >

  export interface DiscoveriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Discoveries that matches the filter.
     * @param {DiscoveriesFindUniqueArgs} args - Arguments to find a Discoveries
     * @example
     * // Get one Discoveries
     * const discoveries = await prisma.discoveries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiscoveriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DiscoveriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Discoveries'> extends True ? CheckSelect<T, Prisma__DiscoveriesClient<Discoveries>, Prisma__DiscoveriesClient<DiscoveriesGetPayload<T>>> : CheckSelect<T, Prisma__DiscoveriesClient<Discoveries | null >, Prisma__DiscoveriesClient<DiscoveriesGetPayload<T> | null >>

    /**
     * Find the first Discoveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveriesFindFirstArgs} args - Arguments to find a Discoveries
     * @example
     * // Get one Discoveries
     * const discoveries = await prisma.discoveries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiscoveriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DiscoveriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Discoveries'> extends True ? CheckSelect<T, Prisma__DiscoveriesClient<Discoveries>, Prisma__DiscoveriesClient<DiscoveriesGetPayload<T>>> : CheckSelect<T, Prisma__DiscoveriesClient<Discoveries | null >, Prisma__DiscoveriesClient<DiscoveriesGetPayload<T> | null >>

    /**
     * Find zero or more Discoveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discoveries
     * const discoveries = await prisma.discoveries.findMany()
     * 
     * // Get first 10 Discoveries
     * const discoveries = await prisma.discoveries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discoveriesWithIdOnly = await prisma.discoveries.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiscoveriesFindManyArgs>(
      args?: SelectSubset<T, DiscoveriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Discoveries>>, PrismaPromise<Array<DiscoveriesGetPayload<T>>>>

    /**
     * Create a Discoveries.
     * @param {DiscoveriesCreateArgs} args - Arguments to create a Discoveries.
     * @example
     * // Create one Discoveries
     * const Discoveries = await prisma.discoveries.create({
     *   data: {
     *     // ... data to create a Discoveries
     *   }
     * })
     * 
    **/
    create<T extends DiscoveriesCreateArgs>(
      args: SelectSubset<T, DiscoveriesCreateArgs>
    ): CheckSelect<T, Prisma__DiscoveriesClient<Discoveries>, Prisma__DiscoveriesClient<DiscoveriesGetPayload<T>>>

    /**
     * Create many Discoveries.
     *     @param {DiscoveriesCreateManyArgs} args - Arguments to create many Discoveries.
     *     @example
     *     // Create many Discoveries
     *     const discoveries = await prisma.discoveries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiscoveriesCreateManyArgs>(
      args?: SelectSubset<T, DiscoveriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Discoveries.
     * @param {DiscoveriesDeleteArgs} args - Arguments to delete one Discoveries.
     * @example
     * // Delete one Discoveries
     * const Discoveries = await prisma.discoveries.delete({
     *   where: {
     *     // ... filter to delete one Discoveries
     *   }
     * })
     * 
    **/
    delete<T extends DiscoveriesDeleteArgs>(
      args: SelectSubset<T, DiscoveriesDeleteArgs>
    ): CheckSelect<T, Prisma__DiscoveriesClient<Discoveries>, Prisma__DiscoveriesClient<DiscoveriesGetPayload<T>>>

    /**
     * Update one Discoveries.
     * @param {DiscoveriesUpdateArgs} args - Arguments to update one Discoveries.
     * @example
     * // Update one Discoveries
     * const discoveries = await prisma.discoveries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiscoveriesUpdateArgs>(
      args: SelectSubset<T, DiscoveriesUpdateArgs>
    ): CheckSelect<T, Prisma__DiscoveriesClient<Discoveries>, Prisma__DiscoveriesClient<DiscoveriesGetPayload<T>>>

    /**
     * Delete zero or more Discoveries.
     * @param {DiscoveriesDeleteManyArgs} args - Arguments to filter Discoveries to delete.
     * @example
     * // Delete a few Discoveries
     * const { count } = await prisma.discoveries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiscoveriesDeleteManyArgs>(
      args?: SelectSubset<T, DiscoveriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discoveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discoveries
     * const discoveries = await prisma.discoveries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiscoveriesUpdateManyArgs>(
      args: SelectSubset<T, DiscoveriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Discoveries.
     * @param {DiscoveriesUpsertArgs} args - Arguments to update or create a Discoveries.
     * @example
     * // Update or create a Discoveries
     * const discoveries = await prisma.discoveries.upsert({
     *   create: {
     *     // ... data to create a Discoveries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discoveries we want to update
     *   }
     * })
    **/
    upsert<T extends DiscoveriesUpsertArgs>(
      args: SelectSubset<T, DiscoveriesUpsertArgs>
    ): CheckSelect<T, Prisma__DiscoveriesClient<Discoveries>, Prisma__DiscoveriesClient<DiscoveriesGetPayload<T>>>

    /**
     * Count the number of Discoveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveriesCountArgs} args - Arguments to filter Discoveries to count.
     * @example
     * // Count the number of Discoveries
     * const count = await prisma.discoveries.count({
     *   where: {
     *     // ... the filter for the Discoveries we want to count
     *   }
     * })
    **/
    count<T extends DiscoveriesCountArgs>(
      args?: Subset<T, DiscoveriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscoveriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discoveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscoveriesAggregateArgs>(args: Subset<T, DiscoveriesAggregateArgs>): PrismaPromise<GetDiscoveriesAggregateType<T>>

    /**
     * Group by Discoveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscoveriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscoveriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscoveriesGroupByArgs['orderBy'] }
        : { orderBy?: DiscoveriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscoveriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscoveriesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discoveries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DiscoveriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Discoveries findUnique
   */
  export type DiscoveriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Discoveries
     * 
    **/
    select?: DiscoveriesSelect | null
    /**
     * Throw an Error if a Discoveries can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Discoveries to fetch.
     * 
    **/
    where: DiscoveriesWhereUniqueInput
  }


  /**
   * Discoveries findFirst
   */
  export type DiscoveriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Discoveries
     * 
    **/
    select?: DiscoveriesSelect | null
    /**
     * Throw an Error if a Discoveries can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Discoveries to fetch.
     * 
    **/
    where?: DiscoveriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discoveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscoveriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discoveries.
     * 
    **/
    cursor?: DiscoveriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discoveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discoveries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discoveries.
     * 
    **/
    distinct?: Enumerable<DiscoveriesScalarFieldEnum>
  }


  /**
   * Discoveries findMany
   */
  export type DiscoveriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Discoveries
     * 
    **/
    select?: DiscoveriesSelect | null
    /**
     * Filter, which Discoveries to fetch.
     * 
    **/
    where?: DiscoveriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discoveries to fetch.
     * 
    **/
    orderBy?: Enumerable<DiscoveriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discoveries.
     * 
    **/
    cursor?: DiscoveriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discoveries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discoveries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DiscoveriesScalarFieldEnum>
  }


  /**
   * Discoveries create
   */
  export type DiscoveriesCreateArgs = {
    /**
     * Select specific fields to fetch from the Discoveries
     * 
    **/
    select?: DiscoveriesSelect | null
    /**
     * The data needed to create a Discoveries.
     * 
    **/
    data: XOR<DiscoveriesCreateInput, DiscoveriesUncheckedCreateInput>
  }


  /**
   * Discoveries createMany
   */
  export type DiscoveriesCreateManyArgs = {
    data: Enumerable<DiscoveriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Discoveries update
   */
  export type DiscoveriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Discoveries
     * 
    **/
    select?: DiscoveriesSelect | null
    /**
     * The data needed to update a Discoveries.
     * 
    **/
    data: XOR<DiscoveriesUpdateInput, DiscoveriesUncheckedUpdateInput>
    /**
     * Choose, which Discoveries to update.
     * 
    **/
    where: DiscoveriesWhereUniqueInput
  }


  /**
   * Discoveries updateMany
   */
  export type DiscoveriesUpdateManyArgs = {
    data: XOR<DiscoveriesUpdateManyMutationInput, DiscoveriesUncheckedUpdateManyInput>
    where?: DiscoveriesWhereInput
  }


  /**
   * Discoveries upsert
   */
  export type DiscoveriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Discoveries
     * 
    **/
    select?: DiscoveriesSelect | null
    /**
     * The filter to search for the Discoveries to update in case it exists.
     * 
    **/
    where: DiscoveriesWhereUniqueInput
    /**
     * In case the Discoveries found by the `where` argument doesn't exist, create a new Discoveries with this data.
     * 
    **/
    create: XOR<DiscoveriesCreateInput, DiscoveriesUncheckedCreateInput>
    /**
     * In case the Discoveries was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DiscoveriesUpdateInput, DiscoveriesUncheckedUpdateInput>
  }


  /**
   * Discoveries delete
   */
  export type DiscoveriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Discoveries
     * 
    **/
    select?: DiscoveriesSelect | null
    /**
     * Filter which Discoveries to delete.
     * 
    **/
    where: DiscoveriesWhereUniqueInput
  }


  /**
   * Discoveries deleteMany
   */
  export type DiscoveriesDeleteManyArgs = {
    where?: DiscoveriesWhereInput
  }


  /**
   * Discoveries without action
   */
  export type DiscoveriesArgs = {
    /**
     * Select specific fields to fetch from the Discoveries
     * 
    **/
    select?: DiscoveriesSelect | null
  }



  /**
   * Model Customers
   */


  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
    age: number | null
    weightKg: number | null
    heightCm: number | null
    mealsPerDay: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
    age: number | null
    weightKg: number | null
    heightCm: number | null
    mealsPerDay: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    age: number | null
    weightKg: number | null
    heightCm: number | null
    gender: string | null
    activeLevel: string | null
    mealsPerDay: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    age: number | null
    weightKg: number | null
    heightCm: number | null
    gender: string | null
    activeLevel: string | null
    mealsPerDay: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    uuid: number
    email: number
    age: number
    weightKg: number
    heightCm: number
    gender: number
    activeLevel: number
    mealsPerDay: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
    age?: true
    weightKg?: true
    heightCm?: true
    mealsPerDay?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
    age?: true
    weightKg?: true
    heightCm?: true
    mealsPerDay?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    age?: true
    weightKg?: true
    heightCm?: true
    gender?: true
    activeLevel?: true
    mealsPerDay?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    age?: true
    weightKg?: true
    heightCm?: true
    gender?: true
    activeLevel?: true
    mealsPerDay?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    age?: true
    weightKg?: true
    heightCm?: true
    gender?: true
    activeLevel?: true
    mealsPerDay?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomersAggregateArgs = {
    /**
     * Filter which Customers to aggregate.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs = {
    where?: CustomersWhereInput
    orderBy?: Enumerable<CustomersOrderByWithAggregationInput>
    by: Array<CustomersScalarFieldEnum>
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }


  export type CustomersGroupByOutputType = {
    id: number
    uuid: string | null
    email: string
    age: number | null
    weightKg: number | null
    heightCm: number | null
    gender: string | null
    activeLevel: string | null
    mealsPerDay: number | null
    createdAt: Date
    updatedAt: Date
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Promise<
    Array<
      PickArray<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect = {
    id?: boolean
    uuid?: boolean
    email?: boolean
    age?: boolean
    weightKg?: boolean
    heightCm?: boolean
    gender?: boolean
    activeLevel?: boolean
    mealsPerDay?: boolean
    intermediateCustomerNutritionNeeds?: boolean | IntermediateCustomerNutritionNeedFindManyArgs
    intermediateCustomerMedicalConditions?: boolean | IntermediateCustomerMedicalConditionFindManyArgs
    intermediateCustomerAllergens?: boolean | IntermediateCustomerAllergenFindManyArgs
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerFindManyArgs
    customerProductDistances?: boolean | CustomerProductDistanceFindManyArgs
    customerBoxItems?: boolean | CustomerBoxItemsFindManyArgs
    queuedShopifyOrder?: boolean | QueuedShopifyOrderFindManyArgs
    intermediateCustomerFlavorDislikes?: boolean | IntermediateCustomerFlavorDislikeFindManyArgs
    intermediateCustomerCategoryPreferences?: boolean | IntermediateCustomerCategoryPreferenceFindManyArgs
    intermediateCustomerIngredientDislikes?: boolean | IntermediateCustomerIngredientDislikeFindManyArgs
    intermediateCustomerFoodTypes?: boolean | IntermediateCustomerFoodTypeFindManyArgs
    intermediateCustomerUnavailableCookingMethods?: boolean | IntermediateCustomerUnavailableCookingMethodFindManyArgs
    practitionerCustomerOrderHistory?: boolean | PractitionerCustomerOrderHistoryFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | CustomersCountOutputTypeArgs
  }

  export type CustomersInclude = {
    intermediateCustomerNutritionNeeds?: boolean | IntermediateCustomerNutritionNeedFindManyArgs
    intermediateCustomerMedicalConditions?: boolean | IntermediateCustomerMedicalConditionFindManyArgs
    intermediateCustomerAllergens?: boolean | IntermediateCustomerAllergenFindManyArgs
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerFindManyArgs
    customerProductDistances?: boolean | CustomerProductDistanceFindManyArgs
    customerBoxItems?: boolean | CustomerBoxItemsFindManyArgs
    queuedShopifyOrder?: boolean | QueuedShopifyOrderFindManyArgs
    intermediateCustomerFlavorDislikes?: boolean | IntermediateCustomerFlavorDislikeFindManyArgs
    intermediateCustomerCategoryPreferences?: boolean | IntermediateCustomerCategoryPreferenceFindManyArgs
    intermediateCustomerIngredientDislikes?: boolean | IntermediateCustomerIngredientDislikeFindManyArgs
    intermediateCustomerFoodTypes?: boolean | IntermediateCustomerFoodTypeFindManyArgs
    intermediateCustomerUnavailableCookingMethods?: boolean | IntermediateCustomerUnavailableCookingMethodFindManyArgs
    practitionerCustomerOrderHistory?: boolean | PractitionerCustomerOrderHistoryFindManyArgs
    _count?: boolean | CustomersCountOutputTypeArgs
  }

  export type CustomersGetPayload<
    S extends boolean | null | undefined | CustomersArgs,
    U = keyof S
      > = S extends true
        ? Customers
    : S extends undefined
    ? never
    : S extends CustomersArgs | CustomersFindManyArgs
    ?'include' extends U
    ? Customers  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateCustomerNutritionNeeds'
        ? Array < IntermediateCustomerNutritionNeedGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerMedicalConditions'
        ? Array < IntermediateCustomerMedicalConditionGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerAllergens'
        ? Array < IntermediateCustomerAllergenGetPayload<S['include'][P]>>  :
        P extends 'surveyQuestionAnswer'
        ? Array < SurveyQuestionAnswerGetPayload<S['include'][P]>>  :
        P extends 'customerProductDistances'
        ? Array < CustomerProductDistanceGetPayload<S['include'][P]>>  :
        P extends 'customerBoxItems'
        ? Array < CustomerBoxItemsGetPayload<S['include'][P]>>  :
        P extends 'queuedShopifyOrder'
        ? Array < QueuedShopifyOrderGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerFlavorDislikes'
        ? Array < IntermediateCustomerFlavorDislikeGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerCategoryPreferences'
        ? Array < IntermediateCustomerCategoryPreferenceGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerIngredientDislikes'
        ? Array < IntermediateCustomerIngredientDislikeGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerFoodTypes'
        ? Array < IntermediateCustomerFoodTypeGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerUnavailableCookingMethods'
        ? Array < IntermediateCustomerUnavailableCookingMethodGetPayload<S['include'][P]>>  :
        P extends 'practitionerCustomerOrderHistory'
        ? Array < PractitionerCustomerOrderHistoryGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CustomersCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Customers ?Customers [P]
  : 
          P extends 'intermediateCustomerNutritionNeeds'
        ? Array < IntermediateCustomerNutritionNeedGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerMedicalConditions'
        ? Array < IntermediateCustomerMedicalConditionGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerAllergens'
        ? Array < IntermediateCustomerAllergenGetPayload<S['select'][P]>>  :
        P extends 'surveyQuestionAnswer'
        ? Array < SurveyQuestionAnswerGetPayload<S['select'][P]>>  :
        P extends 'customerProductDistances'
        ? Array < CustomerProductDistanceGetPayload<S['select'][P]>>  :
        P extends 'customerBoxItems'
        ? Array < CustomerBoxItemsGetPayload<S['select'][P]>>  :
        P extends 'queuedShopifyOrder'
        ? Array < QueuedShopifyOrderGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerFlavorDislikes'
        ? Array < IntermediateCustomerFlavorDislikeGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerCategoryPreferences'
        ? Array < IntermediateCustomerCategoryPreferenceGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerIngredientDislikes'
        ? Array < IntermediateCustomerIngredientDislikeGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerFoodTypes'
        ? Array < IntermediateCustomerFoodTypeGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerUnavailableCookingMethods'
        ? Array < IntermediateCustomerUnavailableCookingMethodGetPayload<S['select'][P]>>  :
        P extends 'practitionerCustomerOrderHistory'
        ? Array < PractitionerCustomerOrderHistoryGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CustomersCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Customers
  : Customers


  type CustomersCountArgs = Merge<
    Omit<CustomersFindManyArgs, 'select' | 'include'> & {
      select?: CustomersCountAggregateInputType | true
    }
  >

  export interface CustomersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customers'> extends True ? CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>> : CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customers'> extends True ? CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>> : CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomersFindManyArgs>(
      args?: SelectSubset<T, CustomersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Customers>>, PrismaPromise<Array<CustomersGetPayload<T>>>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
    **/
    create<T extends CustomersCreateArgs>(
      args: SelectSubset<T, CustomersCreateArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Create many Customers.
     *     @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customers = await prisma.customers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomersCreateManyArgs>(
      args?: SelectSubset<T, CustomersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
    **/
    delete<T extends CustomersDeleteArgs>(
      args: SelectSubset<T, CustomersDeleteArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomersUpdateArgs>(
      args: SelectSubset<T, CustomersUpdateArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomersDeleteManyArgs>(
      args?: SelectSubset<T, CustomersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomersUpdateManyArgs>(
      args: SelectSubset<T, CustomersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
    **/
    upsert<T extends CustomersUpsertArgs>(
      args: SelectSubset<T, CustomersUpsertArgs>
    ): CheckSelect<T, Prisma__CustomersClient<Customers>, Prisma__CustomersClient<CustomersGetPayload<T>>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateCustomerNutritionNeeds<T extends IntermediateCustomerNutritionNeedFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerNutritionNeedFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerNutritionNeed>>, PrismaPromise<Array<IntermediateCustomerNutritionNeedGetPayload<T>>>>;

    intermediateCustomerMedicalConditions<T extends IntermediateCustomerMedicalConditionFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerMedicalConditionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerMedicalCondition>>, PrismaPromise<Array<IntermediateCustomerMedicalConditionGetPayload<T>>>>;

    intermediateCustomerAllergens<T extends IntermediateCustomerAllergenFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerAllergenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerAllergen>>, PrismaPromise<Array<IntermediateCustomerAllergenGetPayload<T>>>>;

    surveyQuestionAnswer<T extends SurveyQuestionAnswerFindManyArgs = {}>(args?: Subset<T, SurveyQuestionAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SurveyQuestionAnswer>>, PrismaPromise<Array<SurveyQuestionAnswerGetPayload<T>>>>;

    customerProductDistances<T extends CustomerProductDistanceFindManyArgs = {}>(args?: Subset<T, CustomerProductDistanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerProductDistance>>, PrismaPromise<Array<CustomerProductDistanceGetPayload<T>>>>;

    customerBoxItems<T extends CustomerBoxItemsFindManyArgs = {}>(args?: Subset<T, CustomerBoxItemsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerBoxItems>>, PrismaPromise<Array<CustomerBoxItemsGetPayload<T>>>>;

    queuedShopifyOrder<T extends QueuedShopifyOrderFindManyArgs = {}>(args?: Subset<T, QueuedShopifyOrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<QueuedShopifyOrder>>, PrismaPromise<Array<QueuedShopifyOrderGetPayload<T>>>>;

    intermediateCustomerFlavorDislikes<T extends IntermediateCustomerFlavorDislikeFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerFlavorDislikeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerFlavorDislike>>, PrismaPromise<Array<IntermediateCustomerFlavorDislikeGetPayload<T>>>>;

    intermediateCustomerCategoryPreferences<T extends IntermediateCustomerCategoryPreferenceFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerCategoryPreferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerCategoryPreference>>, PrismaPromise<Array<IntermediateCustomerCategoryPreferenceGetPayload<T>>>>;

    intermediateCustomerIngredientDislikes<T extends IntermediateCustomerIngredientDislikeFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerIngredientDislikeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerIngredientDislike>>, PrismaPromise<Array<IntermediateCustomerIngredientDislikeGetPayload<T>>>>;

    intermediateCustomerFoodTypes<T extends IntermediateCustomerFoodTypeFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerFoodTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerFoodType>>, PrismaPromise<Array<IntermediateCustomerFoodTypeGetPayload<T>>>>;

    intermediateCustomerUnavailableCookingMethods<T extends IntermediateCustomerUnavailableCookingMethodFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerUnavailableCookingMethodFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerUnavailableCookingMethod>>, PrismaPromise<Array<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>>>;

    practitionerCustomerOrderHistory<T extends PractitionerCustomerOrderHistoryFindManyArgs = {}>(args?: Subset<T, PractitionerCustomerOrderHistoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PractitionerCustomerOrderHistory>>, PrismaPromise<Array<PractitionerCustomerOrderHistoryGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Customers findUnique
   */
  export type CustomersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Throw an Error if a Customers can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers findFirst
   */
  export type CustomersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Throw an Error if a Customers can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     * 
    **/
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter, which Customers to fetch.
     * 
    **/
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     * 
    **/
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomersScalarFieldEnum>
  }


  /**
   * Customers create
   */
  export type CustomersCreateArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The data needed to create a Customers.
     * 
    **/
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }


  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs = {
    data: Enumerable<CustomersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customers update
   */
  export type CustomersUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The data needed to update a Customers.
     * 
    **/
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     * 
    **/
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs = {
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    where?: CustomersWhereInput
  }


  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * The filter to search for the Customers to update in case it exists.
     * 
    **/
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     * 
    **/
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }


  /**
   * Customers delete
   */
  export type CustomersDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
    /**
     * Filter which Customers to delete.
     * 
    **/
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs = {
    where?: CustomersWhereInput
  }


  /**
   * Customers without action
   */
  export type CustomersArgs = {
    /**
     * Select specific fields to fetch from the Customers
     * 
    **/
    select?: CustomersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomersInclude | null
  }



  /**
   * Model IntermediateCustomerNutritionNeed
   */


  export type AggregateIntermediateCustomerNutritionNeed = {
    _count: IntermediateCustomerNutritionNeedCountAggregateOutputType | null
    _avg: IntermediateCustomerNutritionNeedAvgAggregateOutputType | null
    _sum: IntermediateCustomerNutritionNeedSumAggregateOutputType | null
    _min: IntermediateCustomerNutritionNeedMinAggregateOutputType | null
    _max: IntermediateCustomerNutritionNeedMaxAggregateOutputType | null
  }

  export type IntermediateCustomerNutritionNeedAvgAggregateOutputType = {
    customerNutritionNeedId: number | null
    customerId: number | null
    nutritionValue: number | null
  }

  export type IntermediateCustomerNutritionNeedSumAggregateOutputType = {
    customerNutritionNeedId: number | null
    customerId: number | null
    nutritionValue: number | null
  }

  export type IntermediateCustomerNutritionNeedMinAggregateOutputType = {
    customerNutritionNeedId: number | null
    customerId: number | null
    nutritionValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerNutritionNeedMaxAggregateOutputType = {
    customerNutritionNeedId: number | null
    customerId: number | null
    nutritionValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerNutritionNeedCountAggregateOutputType = {
    customerNutritionNeedId: number
    customerId: number
    nutritionValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateCustomerNutritionNeedAvgAggregateInputType = {
    customerNutritionNeedId?: true
    customerId?: true
    nutritionValue?: true
  }

  export type IntermediateCustomerNutritionNeedSumAggregateInputType = {
    customerNutritionNeedId?: true
    customerId?: true
    nutritionValue?: true
  }

  export type IntermediateCustomerNutritionNeedMinAggregateInputType = {
    customerNutritionNeedId?: true
    customerId?: true
    nutritionValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerNutritionNeedMaxAggregateInputType = {
    customerNutritionNeedId?: true
    customerId?: true
    nutritionValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerNutritionNeedCountAggregateInputType = {
    customerNutritionNeedId?: true
    customerId?: true
    nutritionValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateCustomerNutritionNeedAggregateArgs = {
    /**
     * Filter which IntermediateCustomerNutritionNeed to aggregate.
     * 
    **/
    where?: IntermediateCustomerNutritionNeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerNutritionNeeds to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerNutritionNeedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateCustomerNutritionNeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerNutritionNeeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerNutritionNeeds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateCustomerNutritionNeeds
    **/
    _count?: true | IntermediateCustomerNutritionNeedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateCustomerNutritionNeedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateCustomerNutritionNeedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateCustomerNutritionNeedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateCustomerNutritionNeedMaxAggregateInputType
  }

  export type GetIntermediateCustomerNutritionNeedAggregateType<T extends IntermediateCustomerNutritionNeedAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateCustomerNutritionNeed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateCustomerNutritionNeed[P]>
      : GetScalarType<T[P], AggregateIntermediateCustomerNutritionNeed[P]>
  }




  export type IntermediateCustomerNutritionNeedGroupByArgs = {
    where?: IntermediateCustomerNutritionNeedWhereInput
    orderBy?: Enumerable<IntermediateCustomerNutritionNeedOrderByWithAggregationInput>
    by: Array<IntermediateCustomerNutritionNeedScalarFieldEnum>
    having?: IntermediateCustomerNutritionNeedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateCustomerNutritionNeedCountAggregateInputType | true
    _avg?: IntermediateCustomerNutritionNeedAvgAggregateInputType
    _sum?: IntermediateCustomerNutritionNeedSumAggregateInputType
    _min?: IntermediateCustomerNutritionNeedMinAggregateInputType
    _max?: IntermediateCustomerNutritionNeedMaxAggregateInputType
  }


  export type IntermediateCustomerNutritionNeedGroupByOutputType = {
    customerNutritionNeedId: number
    customerId: number
    nutritionValue: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateCustomerNutritionNeedCountAggregateOutputType | null
    _avg: IntermediateCustomerNutritionNeedAvgAggregateOutputType | null
    _sum: IntermediateCustomerNutritionNeedSumAggregateOutputType | null
    _min: IntermediateCustomerNutritionNeedMinAggregateOutputType | null
    _max: IntermediateCustomerNutritionNeedMaxAggregateOutputType | null
  }

  type GetIntermediateCustomerNutritionNeedGroupByPayload<T extends IntermediateCustomerNutritionNeedGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateCustomerNutritionNeedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateCustomerNutritionNeedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateCustomerNutritionNeedGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateCustomerNutritionNeedGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateCustomerNutritionNeedSelect = {
    customerNutritionNeed?: boolean | CustomerNutritionNeedArgs
    customerNutritionNeedId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    nutritionValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateCustomerNutritionNeedInclude = {
    customerNutritionNeed?: boolean | CustomerNutritionNeedArgs
    customer?: boolean | CustomersArgs
  }

  export type IntermediateCustomerNutritionNeedGetPayload<
    S extends boolean | null | undefined | IntermediateCustomerNutritionNeedArgs,
    U = keyof S
      > = S extends true
        ? IntermediateCustomerNutritionNeed
    : S extends undefined
    ? never
    : S extends IntermediateCustomerNutritionNeedArgs | IntermediateCustomerNutritionNeedFindManyArgs
    ?'include' extends U
    ? IntermediateCustomerNutritionNeed  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customerNutritionNeed'
        ? CustomerNutritionNeedGetPayload<S['include'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateCustomerNutritionNeed ?IntermediateCustomerNutritionNeed [P]
  : 
          P extends 'customerNutritionNeed'
        ? CustomerNutritionNeedGetPayload<S['select'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : IntermediateCustomerNutritionNeed
  : IntermediateCustomerNutritionNeed


  type IntermediateCustomerNutritionNeedCountArgs = Merge<
    Omit<IntermediateCustomerNutritionNeedFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateCustomerNutritionNeedCountAggregateInputType | true
    }
  >

  export interface IntermediateCustomerNutritionNeedDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateCustomerNutritionNeed that matches the filter.
     * @param {IntermediateCustomerNutritionNeedFindUniqueArgs} args - Arguments to find a IntermediateCustomerNutritionNeed
     * @example
     * // Get one IntermediateCustomerNutritionNeed
     * const intermediateCustomerNutritionNeed = await prisma.intermediateCustomerNutritionNeed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateCustomerNutritionNeedFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateCustomerNutritionNeedFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateCustomerNutritionNeed'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeed>, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeedGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeed | null >, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeedGetPayload<T> | null >>

    /**
     * Find the first IntermediateCustomerNutritionNeed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerNutritionNeedFindFirstArgs} args - Arguments to find a IntermediateCustomerNutritionNeed
     * @example
     * // Get one IntermediateCustomerNutritionNeed
     * const intermediateCustomerNutritionNeed = await prisma.intermediateCustomerNutritionNeed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateCustomerNutritionNeedFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateCustomerNutritionNeedFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateCustomerNutritionNeed'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeed>, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeedGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeed | null >, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeedGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateCustomerNutritionNeeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerNutritionNeedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateCustomerNutritionNeeds
     * const intermediateCustomerNutritionNeeds = await prisma.intermediateCustomerNutritionNeed.findMany()
     * 
     * // Get first 10 IntermediateCustomerNutritionNeeds
     * const intermediateCustomerNutritionNeeds = await prisma.intermediateCustomerNutritionNeed.findMany({ take: 10 })
     * 
     * // Only select the `customerNutritionNeedId`
     * const intermediateCustomerNutritionNeedWithCustomerNutritionNeedIdOnly = await prisma.intermediateCustomerNutritionNeed.findMany({ select: { customerNutritionNeedId: true } })
     * 
    **/
    findMany<T extends IntermediateCustomerNutritionNeedFindManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerNutritionNeedFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerNutritionNeed>>, PrismaPromise<Array<IntermediateCustomerNutritionNeedGetPayload<T>>>>

    /**
     * Create a IntermediateCustomerNutritionNeed.
     * @param {IntermediateCustomerNutritionNeedCreateArgs} args - Arguments to create a IntermediateCustomerNutritionNeed.
     * @example
     * // Create one IntermediateCustomerNutritionNeed
     * const IntermediateCustomerNutritionNeed = await prisma.intermediateCustomerNutritionNeed.create({
     *   data: {
     *     // ... data to create a IntermediateCustomerNutritionNeed
     *   }
     * })
     * 
    **/
    create<T extends IntermediateCustomerNutritionNeedCreateArgs>(
      args: SelectSubset<T, IntermediateCustomerNutritionNeedCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeed>, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeedGetPayload<T>>>

    /**
     * Create many IntermediateCustomerNutritionNeeds.
     *     @param {IntermediateCustomerNutritionNeedCreateManyArgs} args - Arguments to create many IntermediateCustomerNutritionNeeds.
     *     @example
     *     // Create many IntermediateCustomerNutritionNeeds
     *     const intermediateCustomerNutritionNeed = await prisma.intermediateCustomerNutritionNeed.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateCustomerNutritionNeedCreateManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerNutritionNeedCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateCustomerNutritionNeed.
     * @param {IntermediateCustomerNutritionNeedDeleteArgs} args - Arguments to delete one IntermediateCustomerNutritionNeed.
     * @example
     * // Delete one IntermediateCustomerNutritionNeed
     * const IntermediateCustomerNutritionNeed = await prisma.intermediateCustomerNutritionNeed.delete({
     *   where: {
     *     // ... filter to delete one IntermediateCustomerNutritionNeed
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateCustomerNutritionNeedDeleteArgs>(
      args: SelectSubset<T, IntermediateCustomerNutritionNeedDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeed>, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeedGetPayload<T>>>

    /**
     * Update one IntermediateCustomerNutritionNeed.
     * @param {IntermediateCustomerNutritionNeedUpdateArgs} args - Arguments to update one IntermediateCustomerNutritionNeed.
     * @example
     * // Update one IntermediateCustomerNutritionNeed
     * const intermediateCustomerNutritionNeed = await prisma.intermediateCustomerNutritionNeed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateCustomerNutritionNeedUpdateArgs>(
      args: SelectSubset<T, IntermediateCustomerNutritionNeedUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeed>, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeedGetPayload<T>>>

    /**
     * Delete zero or more IntermediateCustomerNutritionNeeds.
     * @param {IntermediateCustomerNutritionNeedDeleteManyArgs} args - Arguments to filter IntermediateCustomerNutritionNeeds to delete.
     * @example
     * // Delete a few IntermediateCustomerNutritionNeeds
     * const { count } = await prisma.intermediateCustomerNutritionNeed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateCustomerNutritionNeedDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerNutritionNeedDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateCustomerNutritionNeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerNutritionNeedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateCustomerNutritionNeeds
     * const intermediateCustomerNutritionNeed = await prisma.intermediateCustomerNutritionNeed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateCustomerNutritionNeedUpdateManyArgs>(
      args: SelectSubset<T, IntermediateCustomerNutritionNeedUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateCustomerNutritionNeed.
     * @param {IntermediateCustomerNutritionNeedUpsertArgs} args - Arguments to update or create a IntermediateCustomerNutritionNeed.
     * @example
     * // Update or create a IntermediateCustomerNutritionNeed
     * const intermediateCustomerNutritionNeed = await prisma.intermediateCustomerNutritionNeed.upsert({
     *   create: {
     *     // ... data to create a IntermediateCustomerNutritionNeed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateCustomerNutritionNeed we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateCustomerNutritionNeedUpsertArgs>(
      args: SelectSubset<T, IntermediateCustomerNutritionNeedUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeed>, Prisma__IntermediateCustomerNutritionNeedClient<IntermediateCustomerNutritionNeedGetPayload<T>>>

    /**
     * Count the number of IntermediateCustomerNutritionNeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerNutritionNeedCountArgs} args - Arguments to filter IntermediateCustomerNutritionNeeds to count.
     * @example
     * // Count the number of IntermediateCustomerNutritionNeeds
     * const count = await prisma.intermediateCustomerNutritionNeed.count({
     *   where: {
     *     // ... the filter for the IntermediateCustomerNutritionNeeds we want to count
     *   }
     * })
    **/
    count<T extends IntermediateCustomerNutritionNeedCountArgs>(
      args?: Subset<T, IntermediateCustomerNutritionNeedCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateCustomerNutritionNeedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateCustomerNutritionNeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerNutritionNeedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateCustomerNutritionNeedAggregateArgs>(args: Subset<T, IntermediateCustomerNutritionNeedAggregateArgs>): PrismaPromise<GetIntermediateCustomerNutritionNeedAggregateType<T>>

    /**
     * Group by IntermediateCustomerNutritionNeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerNutritionNeedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateCustomerNutritionNeedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateCustomerNutritionNeedGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateCustomerNutritionNeedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateCustomerNutritionNeedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateCustomerNutritionNeedGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateCustomerNutritionNeed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateCustomerNutritionNeedClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customerNutritionNeed<T extends CustomerNutritionNeedArgs = {}>(args?: Subset<T, CustomerNutritionNeedArgs>): CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed | null >, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T> | null >>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateCustomerNutritionNeed findUnique
   */
  export type IntermediateCustomerNutritionNeedFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerNutritionNeed
     * 
    **/
    select?: IntermediateCustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerNutritionNeedInclude | null
    /**
     * Throw an Error if a IntermediateCustomerNutritionNeed can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerNutritionNeed to fetch.
     * 
    **/
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
  }


  /**
   * IntermediateCustomerNutritionNeed findFirst
   */
  export type IntermediateCustomerNutritionNeedFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerNutritionNeed
     * 
    **/
    select?: IntermediateCustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerNutritionNeedInclude | null
    /**
     * Throw an Error if a IntermediateCustomerNutritionNeed can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerNutritionNeed to fetch.
     * 
    **/
    where?: IntermediateCustomerNutritionNeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerNutritionNeeds to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerNutritionNeedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateCustomerNutritionNeeds.
     * 
    **/
    cursor?: IntermediateCustomerNutritionNeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerNutritionNeeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerNutritionNeeds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateCustomerNutritionNeeds.
     * 
    **/
    distinct?: Enumerable<IntermediateCustomerNutritionNeedScalarFieldEnum>
  }


  /**
   * IntermediateCustomerNutritionNeed findMany
   */
  export type IntermediateCustomerNutritionNeedFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerNutritionNeed
     * 
    **/
    select?: IntermediateCustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerNutritionNeedInclude | null
    /**
     * Filter, which IntermediateCustomerNutritionNeeds to fetch.
     * 
    **/
    where?: IntermediateCustomerNutritionNeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerNutritionNeeds to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerNutritionNeedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateCustomerNutritionNeeds.
     * 
    **/
    cursor?: IntermediateCustomerNutritionNeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerNutritionNeeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerNutritionNeeds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateCustomerNutritionNeedScalarFieldEnum>
  }


  /**
   * IntermediateCustomerNutritionNeed create
   */
  export type IntermediateCustomerNutritionNeedCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerNutritionNeed
     * 
    **/
    select?: IntermediateCustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerNutritionNeedInclude | null
    /**
     * The data needed to create a IntermediateCustomerNutritionNeed.
     * 
    **/
    data: XOR<IntermediateCustomerNutritionNeedCreateInput, IntermediateCustomerNutritionNeedUncheckedCreateInput>
  }


  /**
   * IntermediateCustomerNutritionNeed createMany
   */
  export type IntermediateCustomerNutritionNeedCreateManyArgs = {
    data: Enumerable<IntermediateCustomerNutritionNeedCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateCustomerNutritionNeed update
   */
  export type IntermediateCustomerNutritionNeedUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerNutritionNeed
     * 
    **/
    select?: IntermediateCustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerNutritionNeedInclude | null
    /**
     * The data needed to update a IntermediateCustomerNutritionNeed.
     * 
    **/
    data: XOR<IntermediateCustomerNutritionNeedUpdateInput, IntermediateCustomerNutritionNeedUncheckedUpdateInput>
    /**
     * Choose, which IntermediateCustomerNutritionNeed to update.
     * 
    **/
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
  }


  /**
   * IntermediateCustomerNutritionNeed updateMany
   */
  export type IntermediateCustomerNutritionNeedUpdateManyArgs = {
    data: XOR<IntermediateCustomerNutritionNeedUpdateManyMutationInput, IntermediateCustomerNutritionNeedUncheckedUpdateManyInput>
    where?: IntermediateCustomerNutritionNeedWhereInput
  }


  /**
   * IntermediateCustomerNutritionNeed upsert
   */
  export type IntermediateCustomerNutritionNeedUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerNutritionNeed
     * 
    **/
    select?: IntermediateCustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerNutritionNeedInclude | null
    /**
     * The filter to search for the IntermediateCustomerNutritionNeed to update in case it exists.
     * 
    **/
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
    /**
     * In case the IntermediateCustomerNutritionNeed found by the `where` argument doesn't exist, create a new IntermediateCustomerNutritionNeed with this data.
     * 
    **/
    create: XOR<IntermediateCustomerNutritionNeedCreateInput, IntermediateCustomerNutritionNeedUncheckedCreateInput>
    /**
     * In case the IntermediateCustomerNutritionNeed was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateCustomerNutritionNeedUpdateInput, IntermediateCustomerNutritionNeedUncheckedUpdateInput>
  }


  /**
   * IntermediateCustomerNutritionNeed delete
   */
  export type IntermediateCustomerNutritionNeedDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerNutritionNeed
     * 
    **/
    select?: IntermediateCustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerNutritionNeedInclude | null
    /**
     * Filter which IntermediateCustomerNutritionNeed to delete.
     * 
    **/
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
  }


  /**
   * IntermediateCustomerNutritionNeed deleteMany
   */
  export type IntermediateCustomerNutritionNeedDeleteManyArgs = {
    where?: IntermediateCustomerNutritionNeedWhereInput
  }


  /**
   * IntermediateCustomerNutritionNeed without action
   */
  export type IntermediateCustomerNutritionNeedArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerNutritionNeed
     * 
    **/
    select?: IntermediateCustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerNutritionNeedInclude | null
  }



  /**
   * Model CustomerNutritionNeed
   */


  export type AggregateCustomerNutritionNeed = {
    _count: CustomerNutritionNeedCountAggregateOutputType | null
    _avg: CustomerNutritionNeedAvgAggregateOutputType | null
    _sum: CustomerNutritionNeedSumAggregateOutputType | null
    _min: CustomerNutritionNeedMinAggregateOutputType | null
    _max: CustomerNutritionNeedMaxAggregateOutputType | null
  }

  export type CustomerNutritionNeedAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerNutritionNeedSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerNutritionNeedMinAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerNutritionNeedMaxAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerNutritionNeedCountAggregateOutputType = {
    id: number
    name: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerNutritionNeedAvgAggregateInputType = {
    id?: true
  }

  export type CustomerNutritionNeedSumAggregateInputType = {
    id?: true
  }

  export type CustomerNutritionNeedMinAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerNutritionNeedMaxAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerNutritionNeedCountAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerNutritionNeedAggregateArgs = {
    /**
     * Filter which CustomerNutritionNeed to aggregate.
     * 
    **/
    where?: CustomerNutritionNeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNutritionNeeds to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerNutritionNeedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerNutritionNeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNutritionNeeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNutritionNeeds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerNutritionNeeds
    **/
    _count?: true | CustomerNutritionNeedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerNutritionNeedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerNutritionNeedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerNutritionNeedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerNutritionNeedMaxAggregateInputType
  }

  export type GetCustomerNutritionNeedAggregateType<T extends CustomerNutritionNeedAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerNutritionNeed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerNutritionNeed[P]>
      : GetScalarType<T[P], AggregateCustomerNutritionNeed[P]>
  }




  export type CustomerNutritionNeedGroupByArgs = {
    where?: CustomerNutritionNeedWhereInput
    orderBy?: Enumerable<CustomerNutritionNeedOrderByWithAggregationInput>
    by: Array<CustomerNutritionNeedScalarFieldEnum>
    having?: CustomerNutritionNeedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerNutritionNeedCountAggregateInputType | true
    _avg?: CustomerNutritionNeedAvgAggregateInputType
    _sum?: CustomerNutritionNeedSumAggregateInputType
    _min?: CustomerNutritionNeedMinAggregateInputType
    _max?: CustomerNutritionNeedMaxAggregateInputType
  }


  export type CustomerNutritionNeedGroupByOutputType = {
    id: number
    name: string
    label: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerNutritionNeedCountAggregateOutputType | null
    _avg: CustomerNutritionNeedAvgAggregateOutputType | null
    _sum: CustomerNutritionNeedSumAggregateOutputType | null
    _min: CustomerNutritionNeedMinAggregateOutputType | null
    _max: CustomerNutritionNeedMaxAggregateOutputType | null
  }

  type GetCustomerNutritionNeedGroupByPayload<T extends CustomerNutritionNeedGroupByArgs> = Promise<
    Array<
      PickArray<CustomerNutritionNeedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerNutritionNeedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerNutritionNeedGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerNutritionNeedGroupByOutputType[P]>
        }
      >
    >


  export type CustomerNutritionNeedSelect = {
    id?: boolean
    name?: boolean
    label?: boolean
    intermediateCustomerNutritionNeed?: boolean | IntermediateCustomerNutritionNeedFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | CustomerNutritionNeedCountOutputTypeArgs
  }

  export type CustomerNutritionNeedInclude = {
    intermediateCustomerNutritionNeed?: boolean | IntermediateCustomerNutritionNeedFindManyArgs
    _count?: boolean | CustomerNutritionNeedCountOutputTypeArgs
  }

  export type CustomerNutritionNeedGetPayload<
    S extends boolean | null | undefined | CustomerNutritionNeedArgs,
    U = keyof S
      > = S extends true
        ? CustomerNutritionNeed
    : S extends undefined
    ? never
    : S extends CustomerNutritionNeedArgs | CustomerNutritionNeedFindManyArgs
    ?'include' extends U
    ? CustomerNutritionNeed  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateCustomerNutritionNeed'
        ? Array < IntermediateCustomerNutritionNeedGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CustomerNutritionNeedCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CustomerNutritionNeed ?CustomerNutritionNeed [P]
  : 
          P extends 'intermediateCustomerNutritionNeed'
        ? Array < IntermediateCustomerNutritionNeedGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CustomerNutritionNeedCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : CustomerNutritionNeed
  : CustomerNutritionNeed


  type CustomerNutritionNeedCountArgs = Merge<
    Omit<CustomerNutritionNeedFindManyArgs, 'select' | 'include'> & {
      select?: CustomerNutritionNeedCountAggregateInputType | true
    }
  >

  export interface CustomerNutritionNeedDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CustomerNutritionNeed that matches the filter.
     * @param {CustomerNutritionNeedFindUniqueArgs} args - Arguments to find a CustomerNutritionNeed
     * @example
     * // Get one CustomerNutritionNeed
     * const customerNutritionNeed = await prisma.customerNutritionNeed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerNutritionNeedFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerNutritionNeedFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerNutritionNeed'> extends True ? CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed>, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T>>> : CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed | null >, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T> | null >>

    /**
     * Find the first CustomerNutritionNeed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNutritionNeedFindFirstArgs} args - Arguments to find a CustomerNutritionNeed
     * @example
     * // Get one CustomerNutritionNeed
     * const customerNutritionNeed = await prisma.customerNutritionNeed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerNutritionNeedFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerNutritionNeedFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerNutritionNeed'> extends True ? CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed>, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T>>> : CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed | null >, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T> | null >>

    /**
     * Find zero or more CustomerNutritionNeeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNutritionNeedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerNutritionNeeds
     * const customerNutritionNeeds = await prisma.customerNutritionNeed.findMany()
     * 
     * // Get first 10 CustomerNutritionNeeds
     * const customerNutritionNeeds = await prisma.customerNutritionNeed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerNutritionNeedWithIdOnly = await prisma.customerNutritionNeed.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerNutritionNeedFindManyArgs>(
      args?: SelectSubset<T, CustomerNutritionNeedFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CustomerNutritionNeed>>, PrismaPromise<Array<CustomerNutritionNeedGetPayload<T>>>>

    /**
     * Create a CustomerNutritionNeed.
     * @param {CustomerNutritionNeedCreateArgs} args - Arguments to create a CustomerNutritionNeed.
     * @example
     * // Create one CustomerNutritionNeed
     * const CustomerNutritionNeed = await prisma.customerNutritionNeed.create({
     *   data: {
     *     // ... data to create a CustomerNutritionNeed
     *   }
     * })
     * 
    **/
    create<T extends CustomerNutritionNeedCreateArgs>(
      args: SelectSubset<T, CustomerNutritionNeedCreateArgs>
    ): CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed>, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T>>>

    /**
     * Create many CustomerNutritionNeeds.
     *     @param {CustomerNutritionNeedCreateManyArgs} args - Arguments to create many CustomerNutritionNeeds.
     *     @example
     *     // Create many CustomerNutritionNeeds
     *     const customerNutritionNeed = await prisma.customerNutritionNeed.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerNutritionNeedCreateManyArgs>(
      args?: SelectSubset<T, CustomerNutritionNeedCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerNutritionNeed.
     * @param {CustomerNutritionNeedDeleteArgs} args - Arguments to delete one CustomerNutritionNeed.
     * @example
     * // Delete one CustomerNutritionNeed
     * const CustomerNutritionNeed = await prisma.customerNutritionNeed.delete({
     *   where: {
     *     // ... filter to delete one CustomerNutritionNeed
     *   }
     * })
     * 
    **/
    delete<T extends CustomerNutritionNeedDeleteArgs>(
      args: SelectSubset<T, CustomerNutritionNeedDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed>, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T>>>

    /**
     * Update one CustomerNutritionNeed.
     * @param {CustomerNutritionNeedUpdateArgs} args - Arguments to update one CustomerNutritionNeed.
     * @example
     * // Update one CustomerNutritionNeed
     * const customerNutritionNeed = await prisma.customerNutritionNeed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerNutritionNeedUpdateArgs>(
      args: SelectSubset<T, CustomerNutritionNeedUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed>, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T>>>

    /**
     * Delete zero or more CustomerNutritionNeeds.
     * @param {CustomerNutritionNeedDeleteManyArgs} args - Arguments to filter CustomerNutritionNeeds to delete.
     * @example
     * // Delete a few CustomerNutritionNeeds
     * const { count } = await prisma.customerNutritionNeed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerNutritionNeedDeleteManyArgs>(
      args?: SelectSubset<T, CustomerNutritionNeedDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerNutritionNeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNutritionNeedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerNutritionNeeds
     * const customerNutritionNeed = await prisma.customerNutritionNeed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerNutritionNeedUpdateManyArgs>(
      args: SelectSubset<T, CustomerNutritionNeedUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerNutritionNeed.
     * @param {CustomerNutritionNeedUpsertArgs} args - Arguments to update or create a CustomerNutritionNeed.
     * @example
     * // Update or create a CustomerNutritionNeed
     * const customerNutritionNeed = await prisma.customerNutritionNeed.upsert({
     *   create: {
     *     // ... data to create a CustomerNutritionNeed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerNutritionNeed we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerNutritionNeedUpsertArgs>(
      args: SelectSubset<T, CustomerNutritionNeedUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeed>, Prisma__CustomerNutritionNeedClient<CustomerNutritionNeedGetPayload<T>>>

    /**
     * Count the number of CustomerNutritionNeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNutritionNeedCountArgs} args - Arguments to filter CustomerNutritionNeeds to count.
     * @example
     * // Count the number of CustomerNutritionNeeds
     * const count = await prisma.customerNutritionNeed.count({
     *   where: {
     *     // ... the filter for the CustomerNutritionNeeds we want to count
     *   }
     * })
    **/
    count<T extends CustomerNutritionNeedCountArgs>(
      args?: Subset<T, CustomerNutritionNeedCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerNutritionNeedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerNutritionNeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNutritionNeedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerNutritionNeedAggregateArgs>(args: Subset<T, CustomerNutritionNeedAggregateArgs>): PrismaPromise<GetCustomerNutritionNeedAggregateType<T>>

    /**
     * Group by CustomerNutritionNeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerNutritionNeedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerNutritionNeedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerNutritionNeedGroupByArgs['orderBy'] }
        : { orderBy?: CustomerNutritionNeedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerNutritionNeedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerNutritionNeedGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerNutritionNeed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerNutritionNeedClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateCustomerNutritionNeed<T extends IntermediateCustomerNutritionNeedFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerNutritionNeedFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerNutritionNeed>>, PrismaPromise<Array<IntermediateCustomerNutritionNeedGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CustomerNutritionNeed findUnique
   */
  export type CustomerNutritionNeedFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeed
     * 
    **/
    select?: CustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerNutritionNeedInclude | null
    /**
     * Throw an Error if a CustomerNutritionNeed can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CustomerNutritionNeed to fetch.
     * 
    **/
    where: CustomerNutritionNeedWhereUniqueInput
  }


  /**
   * CustomerNutritionNeed findFirst
   */
  export type CustomerNutritionNeedFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeed
     * 
    **/
    select?: CustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerNutritionNeedInclude | null
    /**
     * Throw an Error if a CustomerNutritionNeed can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CustomerNutritionNeed to fetch.
     * 
    **/
    where?: CustomerNutritionNeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNutritionNeeds to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerNutritionNeedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerNutritionNeeds.
     * 
    **/
    cursor?: CustomerNutritionNeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNutritionNeeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNutritionNeeds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerNutritionNeeds.
     * 
    **/
    distinct?: Enumerable<CustomerNutritionNeedScalarFieldEnum>
  }


  /**
   * CustomerNutritionNeed findMany
   */
  export type CustomerNutritionNeedFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeed
     * 
    **/
    select?: CustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerNutritionNeedInclude | null
    /**
     * Filter, which CustomerNutritionNeeds to fetch.
     * 
    **/
    where?: CustomerNutritionNeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerNutritionNeeds to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerNutritionNeedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerNutritionNeeds.
     * 
    **/
    cursor?: CustomerNutritionNeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerNutritionNeeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerNutritionNeeds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerNutritionNeedScalarFieldEnum>
  }


  /**
   * CustomerNutritionNeed create
   */
  export type CustomerNutritionNeedCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeed
     * 
    **/
    select?: CustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerNutritionNeedInclude | null
    /**
     * The data needed to create a CustomerNutritionNeed.
     * 
    **/
    data: XOR<CustomerNutritionNeedCreateInput, CustomerNutritionNeedUncheckedCreateInput>
  }


  /**
   * CustomerNutritionNeed createMany
   */
  export type CustomerNutritionNeedCreateManyArgs = {
    data: Enumerable<CustomerNutritionNeedCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerNutritionNeed update
   */
  export type CustomerNutritionNeedUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeed
     * 
    **/
    select?: CustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerNutritionNeedInclude | null
    /**
     * The data needed to update a CustomerNutritionNeed.
     * 
    **/
    data: XOR<CustomerNutritionNeedUpdateInput, CustomerNutritionNeedUncheckedUpdateInput>
    /**
     * Choose, which CustomerNutritionNeed to update.
     * 
    **/
    where: CustomerNutritionNeedWhereUniqueInput
  }


  /**
   * CustomerNutritionNeed updateMany
   */
  export type CustomerNutritionNeedUpdateManyArgs = {
    data: XOR<CustomerNutritionNeedUpdateManyMutationInput, CustomerNutritionNeedUncheckedUpdateManyInput>
    where?: CustomerNutritionNeedWhereInput
  }


  /**
   * CustomerNutritionNeed upsert
   */
  export type CustomerNutritionNeedUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeed
     * 
    **/
    select?: CustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerNutritionNeedInclude | null
    /**
     * The filter to search for the CustomerNutritionNeed to update in case it exists.
     * 
    **/
    where: CustomerNutritionNeedWhereUniqueInput
    /**
     * In case the CustomerNutritionNeed found by the `where` argument doesn't exist, create a new CustomerNutritionNeed with this data.
     * 
    **/
    create: XOR<CustomerNutritionNeedCreateInput, CustomerNutritionNeedUncheckedCreateInput>
    /**
     * In case the CustomerNutritionNeed was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerNutritionNeedUpdateInput, CustomerNutritionNeedUncheckedUpdateInput>
  }


  /**
   * CustomerNutritionNeed delete
   */
  export type CustomerNutritionNeedDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeed
     * 
    **/
    select?: CustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerNutritionNeedInclude | null
    /**
     * Filter which CustomerNutritionNeed to delete.
     * 
    **/
    where: CustomerNutritionNeedWhereUniqueInput
  }


  /**
   * CustomerNutritionNeed deleteMany
   */
  export type CustomerNutritionNeedDeleteManyArgs = {
    where?: CustomerNutritionNeedWhereInput
  }


  /**
   * CustomerNutritionNeed without action
   */
  export type CustomerNutritionNeedArgs = {
    /**
     * Select specific fields to fetch from the CustomerNutritionNeed
     * 
    **/
    select?: CustomerNutritionNeedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerNutritionNeedInclude | null
  }



  /**
   * Model IntermediateCustomerMedicalCondition
   */


  export type AggregateIntermediateCustomerMedicalCondition = {
    _count: IntermediateCustomerMedicalConditionCountAggregateOutputType | null
    _avg: IntermediateCustomerMedicalConditionAvgAggregateOutputType | null
    _sum: IntermediateCustomerMedicalConditionSumAggregateOutputType | null
    _min: IntermediateCustomerMedicalConditionMinAggregateOutputType | null
    _max: IntermediateCustomerMedicalConditionMaxAggregateOutputType | null
  }

  export type IntermediateCustomerMedicalConditionAvgAggregateOutputType = {
    customerMedicalConditionId: number | null
    customerId: number | null
  }

  export type IntermediateCustomerMedicalConditionSumAggregateOutputType = {
    customerMedicalConditionId: number | null
    customerId: number | null
  }

  export type IntermediateCustomerMedicalConditionMinAggregateOutputType = {
    medicalConditionValue: string | null
    customerMedicalConditionId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerMedicalConditionMaxAggregateOutputType = {
    medicalConditionValue: string | null
    customerMedicalConditionId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerMedicalConditionCountAggregateOutputType = {
    medicalConditionValue: number
    customerMedicalConditionId: number
    customerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateCustomerMedicalConditionAvgAggregateInputType = {
    customerMedicalConditionId?: true
    customerId?: true
  }

  export type IntermediateCustomerMedicalConditionSumAggregateInputType = {
    customerMedicalConditionId?: true
    customerId?: true
  }

  export type IntermediateCustomerMedicalConditionMinAggregateInputType = {
    medicalConditionValue?: true
    customerMedicalConditionId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerMedicalConditionMaxAggregateInputType = {
    medicalConditionValue?: true
    customerMedicalConditionId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerMedicalConditionCountAggregateInputType = {
    medicalConditionValue?: true
    customerMedicalConditionId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateCustomerMedicalConditionAggregateArgs = {
    /**
     * Filter which IntermediateCustomerMedicalCondition to aggregate.
     * 
    **/
    where?: IntermediateCustomerMedicalConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerMedicalConditions to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerMedicalConditionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateCustomerMedicalConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerMedicalConditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerMedicalConditions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateCustomerMedicalConditions
    **/
    _count?: true | IntermediateCustomerMedicalConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateCustomerMedicalConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateCustomerMedicalConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateCustomerMedicalConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateCustomerMedicalConditionMaxAggregateInputType
  }

  export type GetIntermediateCustomerMedicalConditionAggregateType<T extends IntermediateCustomerMedicalConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateCustomerMedicalCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateCustomerMedicalCondition[P]>
      : GetScalarType<T[P], AggregateIntermediateCustomerMedicalCondition[P]>
  }




  export type IntermediateCustomerMedicalConditionGroupByArgs = {
    where?: IntermediateCustomerMedicalConditionWhereInput
    orderBy?: Enumerable<IntermediateCustomerMedicalConditionOrderByWithAggregationInput>
    by: Array<IntermediateCustomerMedicalConditionScalarFieldEnum>
    having?: IntermediateCustomerMedicalConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateCustomerMedicalConditionCountAggregateInputType | true
    _avg?: IntermediateCustomerMedicalConditionAvgAggregateInputType
    _sum?: IntermediateCustomerMedicalConditionSumAggregateInputType
    _min?: IntermediateCustomerMedicalConditionMinAggregateInputType
    _max?: IntermediateCustomerMedicalConditionMaxAggregateInputType
  }


  export type IntermediateCustomerMedicalConditionGroupByOutputType = {
    medicalConditionValue: string
    customerMedicalConditionId: number
    customerId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateCustomerMedicalConditionCountAggregateOutputType | null
    _avg: IntermediateCustomerMedicalConditionAvgAggregateOutputType | null
    _sum: IntermediateCustomerMedicalConditionSumAggregateOutputType | null
    _min: IntermediateCustomerMedicalConditionMinAggregateOutputType | null
    _max: IntermediateCustomerMedicalConditionMaxAggregateOutputType | null
  }

  type GetIntermediateCustomerMedicalConditionGroupByPayload<T extends IntermediateCustomerMedicalConditionGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateCustomerMedicalConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateCustomerMedicalConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateCustomerMedicalConditionGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateCustomerMedicalConditionGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateCustomerMedicalConditionSelect = {
    medicalConditionValue?: boolean
    customerMedicalCondition?: boolean | CustomerMedicalConditionArgs
    customerMedicalConditionId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateCustomerMedicalConditionInclude = {
    customerMedicalCondition?: boolean | CustomerMedicalConditionArgs
    customer?: boolean | CustomersArgs
  }

  export type IntermediateCustomerMedicalConditionGetPayload<
    S extends boolean | null | undefined | IntermediateCustomerMedicalConditionArgs,
    U = keyof S
      > = S extends true
        ? IntermediateCustomerMedicalCondition
    : S extends undefined
    ? never
    : S extends IntermediateCustomerMedicalConditionArgs | IntermediateCustomerMedicalConditionFindManyArgs
    ?'include' extends U
    ? IntermediateCustomerMedicalCondition  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customerMedicalCondition'
        ? CustomerMedicalConditionGetPayload<S['include'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateCustomerMedicalCondition ?IntermediateCustomerMedicalCondition [P]
  : 
          P extends 'customerMedicalCondition'
        ? CustomerMedicalConditionGetPayload<S['select'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : IntermediateCustomerMedicalCondition
  : IntermediateCustomerMedicalCondition


  type IntermediateCustomerMedicalConditionCountArgs = Merge<
    Omit<IntermediateCustomerMedicalConditionFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateCustomerMedicalConditionCountAggregateInputType | true
    }
  >

  export interface IntermediateCustomerMedicalConditionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateCustomerMedicalCondition that matches the filter.
     * @param {IntermediateCustomerMedicalConditionFindUniqueArgs} args - Arguments to find a IntermediateCustomerMedicalCondition
     * @example
     * // Get one IntermediateCustomerMedicalCondition
     * const intermediateCustomerMedicalCondition = await prisma.intermediateCustomerMedicalCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateCustomerMedicalConditionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateCustomerMedicalConditionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateCustomerMedicalCondition'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalCondition>, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalConditionGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalCondition | null >, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalConditionGetPayload<T> | null >>

    /**
     * Find the first IntermediateCustomerMedicalCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerMedicalConditionFindFirstArgs} args - Arguments to find a IntermediateCustomerMedicalCondition
     * @example
     * // Get one IntermediateCustomerMedicalCondition
     * const intermediateCustomerMedicalCondition = await prisma.intermediateCustomerMedicalCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateCustomerMedicalConditionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateCustomerMedicalConditionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateCustomerMedicalCondition'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalCondition>, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalConditionGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalCondition | null >, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalConditionGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateCustomerMedicalConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerMedicalConditionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateCustomerMedicalConditions
     * const intermediateCustomerMedicalConditions = await prisma.intermediateCustomerMedicalCondition.findMany()
     * 
     * // Get first 10 IntermediateCustomerMedicalConditions
     * const intermediateCustomerMedicalConditions = await prisma.intermediateCustomerMedicalCondition.findMany({ take: 10 })
     * 
     * // Only select the `medicalConditionValue`
     * const intermediateCustomerMedicalConditionWithMedicalConditionValueOnly = await prisma.intermediateCustomerMedicalCondition.findMany({ select: { medicalConditionValue: true } })
     * 
    **/
    findMany<T extends IntermediateCustomerMedicalConditionFindManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerMedicalConditionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerMedicalCondition>>, PrismaPromise<Array<IntermediateCustomerMedicalConditionGetPayload<T>>>>

    /**
     * Create a IntermediateCustomerMedicalCondition.
     * @param {IntermediateCustomerMedicalConditionCreateArgs} args - Arguments to create a IntermediateCustomerMedicalCondition.
     * @example
     * // Create one IntermediateCustomerMedicalCondition
     * const IntermediateCustomerMedicalCondition = await prisma.intermediateCustomerMedicalCondition.create({
     *   data: {
     *     // ... data to create a IntermediateCustomerMedicalCondition
     *   }
     * })
     * 
    **/
    create<T extends IntermediateCustomerMedicalConditionCreateArgs>(
      args: SelectSubset<T, IntermediateCustomerMedicalConditionCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalCondition>, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalConditionGetPayload<T>>>

    /**
     * Create many IntermediateCustomerMedicalConditions.
     *     @param {IntermediateCustomerMedicalConditionCreateManyArgs} args - Arguments to create many IntermediateCustomerMedicalConditions.
     *     @example
     *     // Create many IntermediateCustomerMedicalConditions
     *     const intermediateCustomerMedicalCondition = await prisma.intermediateCustomerMedicalCondition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateCustomerMedicalConditionCreateManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerMedicalConditionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateCustomerMedicalCondition.
     * @param {IntermediateCustomerMedicalConditionDeleteArgs} args - Arguments to delete one IntermediateCustomerMedicalCondition.
     * @example
     * // Delete one IntermediateCustomerMedicalCondition
     * const IntermediateCustomerMedicalCondition = await prisma.intermediateCustomerMedicalCondition.delete({
     *   where: {
     *     // ... filter to delete one IntermediateCustomerMedicalCondition
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateCustomerMedicalConditionDeleteArgs>(
      args: SelectSubset<T, IntermediateCustomerMedicalConditionDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalCondition>, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalConditionGetPayload<T>>>

    /**
     * Update one IntermediateCustomerMedicalCondition.
     * @param {IntermediateCustomerMedicalConditionUpdateArgs} args - Arguments to update one IntermediateCustomerMedicalCondition.
     * @example
     * // Update one IntermediateCustomerMedicalCondition
     * const intermediateCustomerMedicalCondition = await prisma.intermediateCustomerMedicalCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateCustomerMedicalConditionUpdateArgs>(
      args: SelectSubset<T, IntermediateCustomerMedicalConditionUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalCondition>, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalConditionGetPayload<T>>>

    /**
     * Delete zero or more IntermediateCustomerMedicalConditions.
     * @param {IntermediateCustomerMedicalConditionDeleteManyArgs} args - Arguments to filter IntermediateCustomerMedicalConditions to delete.
     * @example
     * // Delete a few IntermediateCustomerMedicalConditions
     * const { count } = await prisma.intermediateCustomerMedicalCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateCustomerMedicalConditionDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerMedicalConditionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateCustomerMedicalConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerMedicalConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateCustomerMedicalConditions
     * const intermediateCustomerMedicalCondition = await prisma.intermediateCustomerMedicalCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateCustomerMedicalConditionUpdateManyArgs>(
      args: SelectSubset<T, IntermediateCustomerMedicalConditionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateCustomerMedicalCondition.
     * @param {IntermediateCustomerMedicalConditionUpsertArgs} args - Arguments to update or create a IntermediateCustomerMedicalCondition.
     * @example
     * // Update or create a IntermediateCustomerMedicalCondition
     * const intermediateCustomerMedicalCondition = await prisma.intermediateCustomerMedicalCondition.upsert({
     *   create: {
     *     // ... data to create a IntermediateCustomerMedicalCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateCustomerMedicalCondition we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateCustomerMedicalConditionUpsertArgs>(
      args: SelectSubset<T, IntermediateCustomerMedicalConditionUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalCondition>, Prisma__IntermediateCustomerMedicalConditionClient<IntermediateCustomerMedicalConditionGetPayload<T>>>

    /**
     * Count the number of IntermediateCustomerMedicalConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerMedicalConditionCountArgs} args - Arguments to filter IntermediateCustomerMedicalConditions to count.
     * @example
     * // Count the number of IntermediateCustomerMedicalConditions
     * const count = await prisma.intermediateCustomerMedicalCondition.count({
     *   where: {
     *     // ... the filter for the IntermediateCustomerMedicalConditions we want to count
     *   }
     * })
    **/
    count<T extends IntermediateCustomerMedicalConditionCountArgs>(
      args?: Subset<T, IntermediateCustomerMedicalConditionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateCustomerMedicalConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateCustomerMedicalCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerMedicalConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateCustomerMedicalConditionAggregateArgs>(args: Subset<T, IntermediateCustomerMedicalConditionAggregateArgs>): PrismaPromise<GetIntermediateCustomerMedicalConditionAggregateType<T>>

    /**
     * Group by IntermediateCustomerMedicalCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerMedicalConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateCustomerMedicalConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateCustomerMedicalConditionGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateCustomerMedicalConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateCustomerMedicalConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateCustomerMedicalConditionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateCustomerMedicalCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateCustomerMedicalConditionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customerMedicalCondition<T extends CustomerMedicalConditionArgs = {}>(args?: Subset<T, CustomerMedicalConditionArgs>): CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition | null >, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T> | null >>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateCustomerMedicalCondition findUnique
   */
  export type IntermediateCustomerMedicalConditionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerMedicalCondition
     * 
    **/
    select?: IntermediateCustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerMedicalConditionInclude | null
    /**
     * Throw an Error if a IntermediateCustomerMedicalCondition can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerMedicalCondition to fetch.
     * 
    **/
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
  }


  /**
   * IntermediateCustomerMedicalCondition findFirst
   */
  export type IntermediateCustomerMedicalConditionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerMedicalCondition
     * 
    **/
    select?: IntermediateCustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerMedicalConditionInclude | null
    /**
     * Throw an Error if a IntermediateCustomerMedicalCondition can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerMedicalCondition to fetch.
     * 
    **/
    where?: IntermediateCustomerMedicalConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerMedicalConditions to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerMedicalConditionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateCustomerMedicalConditions.
     * 
    **/
    cursor?: IntermediateCustomerMedicalConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerMedicalConditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerMedicalConditions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateCustomerMedicalConditions.
     * 
    **/
    distinct?: Enumerable<IntermediateCustomerMedicalConditionScalarFieldEnum>
  }


  /**
   * IntermediateCustomerMedicalCondition findMany
   */
  export type IntermediateCustomerMedicalConditionFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerMedicalCondition
     * 
    **/
    select?: IntermediateCustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerMedicalConditionInclude | null
    /**
     * Filter, which IntermediateCustomerMedicalConditions to fetch.
     * 
    **/
    where?: IntermediateCustomerMedicalConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerMedicalConditions to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerMedicalConditionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateCustomerMedicalConditions.
     * 
    **/
    cursor?: IntermediateCustomerMedicalConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerMedicalConditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerMedicalConditions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateCustomerMedicalConditionScalarFieldEnum>
  }


  /**
   * IntermediateCustomerMedicalCondition create
   */
  export type IntermediateCustomerMedicalConditionCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerMedicalCondition
     * 
    **/
    select?: IntermediateCustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerMedicalConditionInclude | null
    /**
     * The data needed to create a IntermediateCustomerMedicalCondition.
     * 
    **/
    data: XOR<IntermediateCustomerMedicalConditionCreateInput, IntermediateCustomerMedicalConditionUncheckedCreateInput>
  }


  /**
   * IntermediateCustomerMedicalCondition createMany
   */
  export type IntermediateCustomerMedicalConditionCreateManyArgs = {
    data: Enumerable<IntermediateCustomerMedicalConditionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateCustomerMedicalCondition update
   */
  export type IntermediateCustomerMedicalConditionUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerMedicalCondition
     * 
    **/
    select?: IntermediateCustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerMedicalConditionInclude | null
    /**
     * The data needed to update a IntermediateCustomerMedicalCondition.
     * 
    **/
    data: XOR<IntermediateCustomerMedicalConditionUpdateInput, IntermediateCustomerMedicalConditionUncheckedUpdateInput>
    /**
     * Choose, which IntermediateCustomerMedicalCondition to update.
     * 
    **/
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
  }


  /**
   * IntermediateCustomerMedicalCondition updateMany
   */
  export type IntermediateCustomerMedicalConditionUpdateManyArgs = {
    data: XOR<IntermediateCustomerMedicalConditionUpdateManyMutationInput, IntermediateCustomerMedicalConditionUncheckedUpdateManyInput>
    where?: IntermediateCustomerMedicalConditionWhereInput
  }


  /**
   * IntermediateCustomerMedicalCondition upsert
   */
  export type IntermediateCustomerMedicalConditionUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerMedicalCondition
     * 
    **/
    select?: IntermediateCustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerMedicalConditionInclude | null
    /**
     * The filter to search for the IntermediateCustomerMedicalCondition to update in case it exists.
     * 
    **/
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
    /**
     * In case the IntermediateCustomerMedicalCondition found by the `where` argument doesn't exist, create a new IntermediateCustomerMedicalCondition with this data.
     * 
    **/
    create: XOR<IntermediateCustomerMedicalConditionCreateInput, IntermediateCustomerMedicalConditionUncheckedCreateInput>
    /**
     * In case the IntermediateCustomerMedicalCondition was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateCustomerMedicalConditionUpdateInput, IntermediateCustomerMedicalConditionUncheckedUpdateInput>
  }


  /**
   * IntermediateCustomerMedicalCondition delete
   */
  export type IntermediateCustomerMedicalConditionDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerMedicalCondition
     * 
    **/
    select?: IntermediateCustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerMedicalConditionInclude | null
    /**
     * Filter which IntermediateCustomerMedicalCondition to delete.
     * 
    **/
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
  }


  /**
   * IntermediateCustomerMedicalCondition deleteMany
   */
  export type IntermediateCustomerMedicalConditionDeleteManyArgs = {
    where?: IntermediateCustomerMedicalConditionWhereInput
  }


  /**
   * IntermediateCustomerMedicalCondition without action
   */
  export type IntermediateCustomerMedicalConditionArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerMedicalCondition
     * 
    **/
    select?: IntermediateCustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerMedicalConditionInclude | null
  }



  /**
   * Model CustomerMedicalCondition
   */


  export type AggregateCustomerMedicalCondition = {
    _count: CustomerMedicalConditionCountAggregateOutputType | null
    _avg: CustomerMedicalConditionAvgAggregateOutputType | null
    _sum: CustomerMedicalConditionSumAggregateOutputType | null
    _min: CustomerMedicalConditionMinAggregateOutputType | null
    _max: CustomerMedicalConditionMaxAggregateOutputType | null
  }

  export type CustomerMedicalConditionAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerMedicalConditionSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMedicalConditionMinAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMedicalConditionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMedicalConditionCountAggregateOutputType = {
    id: number
    name: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMedicalConditionAvgAggregateInputType = {
    id?: true
  }

  export type CustomerMedicalConditionSumAggregateInputType = {
    id?: true
  }

  export type CustomerMedicalConditionMinAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMedicalConditionMaxAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMedicalConditionCountAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerMedicalConditionAggregateArgs = {
    /**
     * Filter which CustomerMedicalCondition to aggregate.
     * 
    **/
    where?: CustomerMedicalConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerMedicalConditions to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerMedicalConditionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerMedicalConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerMedicalConditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerMedicalConditions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerMedicalConditions
    **/
    _count?: true | CustomerMedicalConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerMedicalConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerMedicalConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMedicalConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMedicalConditionMaxAggregateInputType
  }

  export type GetCustomerMedicalConditionAggregateType<T extends CustomerMedicalConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerMedicalCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerMedicalCondition[P]>
      : GetScalarType<T[P], AggregateCustomerMedicalCondition[P]>
  }




  export type CustomerMedicalConditionGroupByArgs = {
    where?: CustomerMedicalConditionWhereInput
    orderBy?: Enumerable<CustomerMedicalConditionOrderByWithAggregationInput>
    by: Array<CustomerMedicalConditionScalarFieldEnum>
    having?: CustomerMedicalConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerMedicalConditionCountAggregateInputType | true
    _avg?: CustomerMedicalConditionAvgAggregateInputType
    _sum?: CustomerMedicalConditionSumAggregateInputType
    _min?: CustomerMedicalConditionMinAggregateInputType
    _max?: CustomerMedicalConditionMaxAggregateInputType
  }


  export type CustomerMedicalConditionGroupByOutputType = {
    id: number
    name: string
    label: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerMedicalConditionCountAggregateOutputType | null
    _avg: CustomerMedicalConditionAvgAggregateOutputType | null
    _sum: CustomerMedicalConditionSumAggregateOutputType | null
    _min: CustomerMedicalConditionMinAggregateOutputType | null
    _max: CustomerMedicalConditionMaxAggregateOutputType | null
  }

  type GetCustomerMedicalConditionGroupByPayload<T extends CustomerMedicalConditionGroupByArgs> = Promise<
    Array<
      PickArray<CustomerMedicalConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerMedicalConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerMedicalConditionGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerMedicalConditionGroupByOutputType[P]>
        }
      >
    >


  export type CustomerMedicalConditionSelect = {
    id?: boolean
    name?: boolean
    label?: boolean
    intermediateCustomerMedicalConditions?: boolean | IntermediateCustomerMedicalConditionFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | CustomerMedicalConditionCountOutputTypeArgs
  }

  export type CustomerMedicalConditionInclude = {
    intermediateCustomerMedicalConditions?: boolean | IntermediateCustomerMedicalConditionFindManyArgs
    _count?: boolean | CustomerMedicalConditionCountOutputTypeArgs
  }

  export type CustomerMedicalConditionGetPayload<
    S extends boolean | null | undefined | CustomerMedicalConditionArgs,
    U = keyof S
      > = S extends true
        ? CustomerMedicalCondition
    : S extends undefined
    ? never
    : S extends CustomerMedicalConditionArgs | CustomerMedicalConditionFindManyArgs
    ?'include' extends U
    ? CustomerMedicalCondition  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateCustomerMedicalConditions'
        ? Array < IntermediateCustomerMedicalConditionGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? CustomerMedicalConditionCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CustomerMedicalCondition ?CustomerMedicalCondition [P]
  : 
          P extends 'intermediateCustomerMedicalConditions'
        ? Array < IntermediateCustomerMedicalConditionGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? CustomerMedicalConditionCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : CustomerMedicalCondition
  : CustomerMedicalCondition


  type CustomerMedicalConditionCountArgs = Merge<
    Omit<CustomerMedicalConditionFindManyArgs, 'select' | 'include'> & {
      select?: CustomerMedicalConditionCountAggregateInputType | true
    }
  >

  export interface CustomerMedicalConditionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CustomerMedicalCondition that matches the filter.
     * @param {CustomerMedicalConditionFindUniqueArgs} args - Arguments to find a CustomerMedicalCondition
     * @example
     * // Get one CustomerMedicalCondition
     * const customerMedicalCondition = await prisma.customerMedicalCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerMedicalConditionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerMedicalConditionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerMedicalCondition'> extends True ? CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition>, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T>>> : CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition | null >, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T> | null >>

    /**
     * Find the first CustomerMedicalCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMedicalConditionFindFirstArgs} args - Arguments to find a CustomerMedicalCondition
     * @example
     * // Get one CustomerMedicalCondition
     * const customerMedicalCondition = await prisma.customerMedicalCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerMedicalConditionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerMedicalConditionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerMedicalCondition'> extends True ? CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition>, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T>>> : CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition | null >, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T> | null >>

    /**
     * Find zero or more CustomerMedicalConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMedicalConditionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerMedicalConditions
     * const customerMedicalConditions = await prisma.customerMedicalCondition.findMany()
     * 
     * // Get first 10 CustomerMedicalConditions
     * const customerMedicalConditions = await prisma.customerMedicalCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerMedicalConditionWithIdOnly = await prisma.customerMedicalCondition.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerMedicalConditionFindManyArgs>(
      args?: SelectSubset<T, CustomerMedicalConditionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CustomerMedicalCondition>>, PrismaPromise<Array<CustomerMedicalConditionGetPayload<T>>>>

    /**
     * Create a CustomerMedicalCondition.
     * @param {CustomerMedicalConditionCreateArgs} args - Arguments to create a CustomerMedicalCondition.
     * @example
     * // Create one CustomerMedicalCondition
     * const CustomerMedicalCondition = await prisma.customerMedicalCondition.create({
     *   data: {
     *     // ... data to create a CustomerMedicalCondition
     *   }
     * })
     * 
    **/
    create<T extends CustomerMedicalConditionCreateArgs>(
      args: SelectSubset<T, CustomerMedicalConditionCreateArgs>
    ): CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition>, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T>>>

    /**
     * Create many CustomerMedicalConditions.
     *     @param {CustomerMedicalConditionCreateManyArgs} args - Arguments to create many CustomerMedicalConditions.
     *     @example
     *     // Create many CustomerMedicalConditions
     *     const customerMedicalCondition = await prisma.customerMedicalCondition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerMedicalConditionCreateManyArgs>(
      args?: SelectSubset<T, CustomerMedicalConditionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerMedicalCondition.
     * @param {CustomerMedicalConditionDeleteArgs} args - Arguments to delete one CustomerMedicalCondition.
     * @example
     * // Delete one CustomerMedicalCondition
     * const CustomerMedicalCondition = await prisma.customerMedicalCondition.delete({
     *   where: {
     *     // ... filter to delete one CustomerMedicalCondition
     *   }
     * })
     * 
    **/
    delete<T extends CustomerMedicalConditionDeleteArgs>(
      args: SelectSubset<T, CustomerMedicalConditionDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition>, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T>>>

    /**
     * Update one CustomerMedicalCondition.
     * @param {CustomerMedicalConditionUpdateArgs} args - Arguments to update one CustomerMedicalCondition.
     * @example
     * // Update one CustomerMedicalCondition
     * const customerMedicalCondition = await prisma.customerMedicalCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerMedicalConditionUpdateArgs>(
      args: SelectSubset<T, CustomerMedicalConditionUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition>, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T>>>

    /**
     * Delete zero or more CustomerMedicalConditions.
     * @param {CustomerMedicalConditionDeleteManyArgs} args - Arguments to filter CustomerMedicalConditions to delete.
     * @example
     * // Delete a few CustomerMedicalConditions
     * const { count } = await prisma.customerMedicalCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerMedicalConditionDeleteManyArgs>(
      args?: SelectSubset<T, CustomerMedicalConditionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerMedicalConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMedicalConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerMedicalConditions
     * const customerMedicalCondition = await prisma.customerMedicalCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerMedicalConditionUpdateManyArgs>(
      args: SelectSubset<T, CustomerMedicalConditionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerMedicalCondition.
     * @param {CustomerMedicalConditionUpsertArgs} args - Arguments to update or create a CustomerMedicalCondition.
     * @example
     * // Update or create a CustomerMedicalCondition
     * const customerMedicalCondition = await prisma.customerMedicalCondition.upsert({
     *   create: {
     *     // ... data to create a CustomerMedicalCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerMedicalCondition we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerMedicalConditionUpsertArgs>(
      args: SelectSubset<T, CustomerMedicalConditionUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerMedicalConditionClient<CustomerMedicalCondition>, Prisma__CustomerMedicalConditionClient<CustomerMedicalConditionGetPayload<T>>>

    /**
     * Count the number of CustomerMedicalConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMedicalConditionCountArgs} args - Arguments to filter CustomerMedicalConditions to count.
     * @example
     * // Count the number of CustomerMedicalConditions
     * const count = await prisma.customerMedicalCondition.count({
     *   where: {
     *     // ... the filter for the CustomerMedicalConditions we want to count
     *   }
     * })
    **/
    count<T extends CustomerMedicalConditionCountArgs>(
      args?: Subset<T, CustomerMedicalConditionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerMedicalConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerMedicalCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMedicalConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerMedicalConditionAggregateArgs>(args: Subset<T, CustomerMedicalConditionAggregateArgs>): PrismaPromise<GetCustomerMedicalConditionAggregateType<T>>

    /**
     * Group by CustomerMedicalCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerMedicalConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerMedicalConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerMedicalConditionGroupByArgs['orderBy'] }
        : { orderBy?: CustomerMedicalConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerMedicalConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerMedicalConditionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerMedicalCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerMedicalConditionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateCustomerMedicalConditions<T extends IntermediateCustomerMedicalConditionFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerMedicalConditionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerMedicalCondition>>, PrismaPromise<Array<IntermediateCustomerMedicalConditionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CustomerMedicalCondition findUnique
   */
  export type CustomerMedicalConditionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalCondition
     * 
    **/
    select?: CustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerMedicalConditionInclude | null
    /**
     * Throw an Error if a CustomerMedicalCondition can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CustomerMedicalCondition to fetch.
     * 
    **/
    where: CustomerMedicalConditionWhereUniqueInput
  }


  /**
   * CustomerMedicalCondition findFirst
   */
  export type CustomerMedicalConditionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalCondition
     * 
    **/
    select?: CustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerMedicalConditionInclude | null
    /**
     * Throw an Error if a CustomerMedicalCondition can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CustomerMedicalCondition to fetch.
     * 
    **/
    where?: CustomerMedicalConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerMedicalConditions to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerMedicalConditionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerMedicalConditions.
     * 
    **/
    cursor?: CustomerMedicalConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerMedicalConditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerMedicalConditions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerMedicalConditions.
     * 
    **/
    distinct?: Enumerable<CustomerMedicalConditionScalarFieldEnum>
  }


  /**
   * CustomerMedicalCondition findMany
   */
  export type CustomerMedicalConditionFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalCondition
     * 
    **/
    select?: CustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerMedicalConditionInclude | null
    /**
     * Filter, which CustomerMedicalConditions to fetch.
     * 
    **/
    where?: CustomerMedicalConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerMedicalConditions to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerMedicalConditionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerMedicalConditions.
     * 
    **/
    cursor?: CustomerMedicalConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerMedicalConditions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerMedicalConditions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerMedicalConditionScalarFieldEnum>
  }


  /**
   * CustomerMedicalCondition create
   */
  export type CustomerMedicalConditionCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalCondition
     * 
    **/
    select?: CustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerMedicalConditionInclude | null
    /**
     * The data needed to create a CustomerMedicalCondition.
     * 
    **/
    data: XOR<CustomerMedicalConditionCreateInput, CustomerMedicalConditionUncheckedCreateInput>
  }


  /**
   * CustomerMedicalCondition createMany
   */
  export type CustomerMedicalConditionCreateManyArgs = {
    data: Enumerable<CustomerMedicalConditionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerMedicalCondition update
   */
  export type CustomerMedicalConditionUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalCondition
     * 
    **/
    select?: CustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerMedicalConditionInclude | null
    /**
     * The data needed to update a CustomerMedicalCondition.
     * 
    **/
    data: XOR<CustomerMedicalConditionUpdateInput, CustomerMedicalConditionUncheckedUpdateInput>
    /**
     * Choose, which CustomerMedicalCondition to update.
     * 
    **/
    where: CustomerMedicalConditionWhereUniqueInput
  }


  /**
   * CustomerMedicalCondition updateMany
   */
  export type CustomerMedicalConditionUpdateManyArgs = {
    data: XOR<CustomerMedicalConditionUpdateManyMutationInput, CustomerMedicalConditionUncheckedUpdateManyInput>
    where?: CustomerMedicalConditionWhereInput
  }


  /**
   * CustomerMedicalCondition upsert
   */
  export type CustomerMedicalConditionUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalCondition
     * 
    **/
    select?: CustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerMedicalConditionInclude | null
    /**
     * The filter to search for the CustomerMedicalCondition to update in case it exists.
     * 
    **/
    where: CustomerMedicalConditionWhereUniqueInput
    /**
     * In case the CustomerMedicalCondition found by the `where` argument doesn't exist, create a new CustomerMedicalCondition with this data.
     * 
    **/
    create: XOR<CustomerMedicalConditionCreateInput, CustomerMedicalConditionUncheckedCreateInput>
    /**
     * In case the CustomerMedicalCondition was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerMedicalConditionUpdateInput, CustomerMedicalConditionUncheckedUpdateInput>
  }


  /**
   * CustomerMedicalCondition delete
   */
  export type CustomerMedicalConditionDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalCondition
     * 
    **/
    select?: CustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerMedicalConditionInclude | null
    /**
     * Filter which CustomerMedicalCondition to delete.
     * 
    **/
    where: CustomerMedicalConditionWhereUniqueInput
  }


  /**
   * CustomerMedicalCondition deleteMany
   */
  export type CustomerMedicalConditionDeleteManyArgs = {
    where?: CustomerMedicalConditionWhereInput
  }


  /**
   * CustomerMedicalCondition without action
   */
  export type CustomerMedicalConditionArgs = {
    /**
     * Select specific fields to fetch from the CustomerMedicalCondition
     * 
    **/
    select?: CustomerMedicalConditionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerMedicalConditionInclude | null
  }



  /**
   * Model IntermediateCustomerFoodType
   */


  export type AggregateIntermediateCustomerFoodType = {
    _count: IntermediateCustomerFoodTypeCountAggregateOutputType | null
    _avg: IntermediateCustomerFoodTypeAvgAggregateOutputType | null
    _sum: IntermediateCustomerFoodTypeSumAggregateOutputType | null
    _min: IntermediateCustomerFoodTypeMinAggregateOutputType | null
    _max: IntermediateCustomerFoodTypeMaxAggregateOutputType | null
  }

  export type IntermediateCustomerFoodTypeAvgAggregateOutputType = {
    productFoodTypeId: number | null
    customerId: number | null
  }

  export type IntermediateCustomerFoodTypeSumAggregateOutputType = {
    productFoodTypeId: number | null
    customerId: number | null
  }

  export type IntermediateCustomerFoodTypeMinAggregateOutputType = {
    productFoodTypeId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerFoodTypeMaxAggregateOutputType = {
    productFoodTypeId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerFoodTypeCountAggregateOutputType = {
    productFoodTypeId: number
    customerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateCustomerFoodTypeAvgAggregateInputType = {
    productFoodTypeId?: true
    customerId?: true
  }

  export type IntermediateCustomerFoodTypeSumAggregateInputType = {
    productFoodTypeId?: true
    customerId?: true
  }

  export type IntermediateCustomerFoodTypeMinAggregateInputType = {
    productFoodTypeId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerFoodTypeMaxAggregateInputType = {
    productFoodTypeId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerFoodTypeCountAggregateInputType = {
    productFoodTypeId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateCustomerFoodTypeAggregateArgs = {
    /**
     * Filter which IntermediateCustomerFoodType to aggregate.
     * 
    **/
    where?: IntermediateCustomerFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateCustomerFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerFoodTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateCustomerFoodTypes
    **/
    _count?: true | IntermediateCustomerFoodTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateCustomerFoodTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateCustomerFoodTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateCustomerFoodTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateCustomerFoodTypeMaxAggregateInputType
  }

  export type GetIntermediateCustomerFoodTypeAggregateType<T extends IntermediateCustomerFoodTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateCustomerFoodType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateCustomerFoodType[P]>
      : GetScalarType<T[P], AggregateIntermediateCustomerFoodType[P]>
  }




  export type IntermediateCustomerFoodTypeGroupByArgs = {
    where?: IntermediateCustomerFoodTypeWhereInput
    orderBy?: Enumerable<IntermediateCustomerFoodTypeOrderByWithAggregationInput>
    by: Array<IntermediateCustomerFoodTypeScalarFieldEnum>
    having?: IntermediateCustomerFoodTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateCustomerFoodTypeCountAggregateInputType | true
    _avg?: IntermediateCustomerFoodTypeAvgAggregateInputType
    _sum?: IntermediateCustomerFoodTypeSumAggregateInputType
    _min?: IntermediateCustomerFoodTypeMinAggregateInputType
    _max?: IntermediateCustomerFoodTypeMaxAggregateInputType
  }


  export type IntermediateCustomerFoodTypeGroupByOutputType = {
    productFoodTypeId: number
    customerId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateCustomerFoodTypeCountAggregateOutputType | null
    _avg: IntermediateCustomerFoodTypeAvgAggregateOutputType | null
    _sum: IntermediateCustomerFoodTypeSumAggregateOutputType | null
    _min: IntermediateCustomerFoodTypeMinAggregateOutputType | null
    _max: IntermediateCustomerFoodTypeMaxAggregateOutputType | null
  }

  type GetIntermediateCustomerFoodTypeGroupByPayload<T extends IntermediateCustomerFoodTypeGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateCustomerFoodTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateCustomerFoodTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateCustomerFoodTypeGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateCustomerFoodTypeGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateCustomerFoodTypeSelect = {
    productFoodType?: boolean | ProductFoodTypeArgs
    productFoodTypeId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateCustomerFoodTypeInclude = {
    productFoodType?: boolean | ProductFoodTypeArgs
    customer?: boolean | CustomersArgs
  }

  export type IntermediateCustomerFoodTypeGetPayload<
    S extends boolean | null | undefined | IntermediateCustomerFoodTypeArgs,
    U = keyof S
      > = S extends true
        ? IntermediateCustomerFoodType
    : S extends undefined
    ? never
    : S extends IntermediateCustomerFoodTypeArgs | IntermediateCustomerFoodTypeFindManyArgs
    ?'include' extends U
    ? IntermediateCustomerFoodType  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'productFoodType'
        ? ProductFoodTypeGetPayload<S['include'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateCustomerFoodType ?IntermediateCustomerFoodType [P]
  : 
          P extends 'productFoodType'
        ? ProductFoodTypeGetPayload<S['select'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : IntermediateCustomerFoodType
  : IntermediateCustomerFoodType


  type IntermediateCustomerFoodTypeCountArgs = Merge<
    Omit<IntermediateCustomerFoodTypeFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateCustomerFoodTypeCountAggregateInputType | true
    }
  >

  export interface IntermediateCustomerFoodTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateCustomerFoodType that matches the filter.
     * @param {IntermediateCustomerFoodTypeFindUniqueArgs} args - Arguments to find a IntermediateCustomerFoodType
     * @example
     * // Get one IntermediateCustomerFoodType
     * const intermediateCustomerFoodType = await prisma.intermediateCustomerFoodType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateCustomerFoodTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateCustomerFoodTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateCustomerFoodType'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodType>, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodTypeGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodType | null >, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodTypeGetPayload<T> | null >>

    /**
     * Find the first IntermediateCustomerFoodType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFoodTypeFindFirstArgs} args - Arguments to find a IntermediateCustomerFoodType
     * @example
     * // Get one IntermediateCustomerFoodType
     * const intermediateCustomerFoodType = await prisma.intermediateCustomerFoodType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateCustomerFoodTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateCustomerFoodTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateCustomerFoodType'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodType>, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodTypeGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodType | null >, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodTypeGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateCustomerFoodTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFoodTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateCustomerFoodTypes
     * const intermediateCustomerFoodTypes = await prisma.intermediateCustomerFoodType.findMany()
     * 
     * // Get first 10 IntermediateCustomerFoodTypes
     * const intermediateCustomerFoodTypes = await prisma.intermediateCustomerFoodType.findMany({ take: 10 })
     * 
     * // Only select the `productFoodTypeId`
     * const intermediateCustomerFoodTypeWithProductFoodTypeIdOnly = await prisma.intermediateCustomerFoodType.findMany({ select: { productFoodTypeId: true } })
     * 
    **/
    findMany<T extends IntermediateCustomerFoodTypeFindManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerFoodTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerFoodType>>, PrismaPromise<Array<IntermediateCustomerFoodTypeGetPayload<T>>>>

    /**
     * Create a IntermediateCustomerFoodType.
     * @param {IntermediateCustomerFoodTypeCreateArgs} args - Arguments to create a IntermediateCustomerFoodType.
     * @example
     * // Create one IntermediateCustomerFoodType
     * const IntermediateCustomerFoodType = await prisma.intermediateCustomerFoodType.create({
     *   data: {
     *     // ... data to create a IntermediateCustomerFoodType
     *   }
     * })
     * 
    **/
    create<T extends IntermediateCustomerFoodTypeCreateArgs>(
      args: SelectSubset<T, IntermediateCustomerFoodTypeCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodType>, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodTypeGetPayload<T>>>

    /**
     * Create many IntermediateCustomerFoodTypes.
     *     @param {IntermediateCustomerFoodTypeCreateManyArgs} args - Arguments to create many IntermediateCustomerFoodTypes.
     *     @example
     *     // Create many IntermediateCustomerFoodTypes
     *     const intermediateCustomerFoodType = await prisma.intermediateCustomerFoodType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateCustomerFoodTypeCreateManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerFoodTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateCustomerFoodType.
     * @param {IntermediateCustomerFoodTypeDeleteArgs} args - Arguments to delete one IntermediateCustomerFoodType.
     * @example
     * // Delete one IntermediateCustomerFoodType
     * const IntermediateCustomerFoodType = await prisma.intermediateCustomerFoodType.delete({
     *   where: {
     *     // ... filter to delete one IntermediateCustomerFoodType
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateCustomerFoodTypeDeleteArgs>(
      args: SelectSubset<T, IntermediateCustomerFoodTypeDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodType>, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodTypeGetPayload<T>>>

    /**
     * Update one IntermediateCustomerFoodType.
     * @param {IntermediateCustomerFoodTypeUpdateArgs} args - Arguments to update one IntermediateCustomerFoodType.
     * @example
     * // Update one IntermediateCustomerFoodType
     * const intermediateCustomerFoodType = await prisma.intermediateCustomerFoodType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateCustomerFoodTypeUpdateArgs>(
      args: SelectSubset<T, IntermediateCustomerFoodTypeUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodType>, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodTypeGetPayload<T>>>

    /**
     * Delete zero or more IntermediateCustomerFoodTypes.
     * @param {IntermediateCustomerFoodTypeDeleteManyArgs} args - Arguments to filter IntermediateCustomerFoodTypes to delete.
     * @example
     * // Delete a few IntermediateCustomerFoodTypes
     * const { count } = await prisma.intermediateCustomerFoodType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateCustomerFoodTypeDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerFoodTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateCustomerFoodTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFoodTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateCustomerFoodTypes
     * const intermediateCustomerFoodType = await prisma.intermediateCustomerFoodType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateCustomerFoodTypeUpdateManyArgs>(
      args: SelectSubset<T, IntermediateCustomerFoodTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateCustomerFoodType.
     * @param {IntermediateCustomerFoodTypeUpsertArgs} args - Arguments to update or create a IntermediateCustomerFoodType.
     * @example
     * // Update or create a IntermediateCustomerFoodType
     * const intermediateCustomerFoodType = await prisma.intermediateCustomerFoodType.upsert({
     *   create: {
     *     // ... data to create a IntermediateCustomerFoodType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateCustomerFoodType we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateCustomerFoodTypeUpsertArgs>(
      args: SelectSubset<T, IntermediateCustomerFoodTypeUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodType>, Prisma__IntermediateCustomerFoodTypeClient<IntermediateCustomerFoodTypeGetPayload<T>>>

    /**
     * Count the number of IntermediateCustomerFoodTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFoodTypeCountArgs} args - Arguments to filter IntermediateCustomerFoodTypes to count.
     * @example
     * // Count the number of IntermediateCustomerFoodTypes
     * const count = await prisma.intermediateCustomerFoodType.count({
     *   where: {
     *     // ... the filter for the IntermediateCustomerFoodTypes we want to count
     *   }
     * })
    **/
    count<T extends IntermediateCustomerFoodTypeCountArgs>(
      args?: Subset<T, IntermediateCustomerFoodTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateCustomerFoodTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateCustomerFoodType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFoodTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateCustomerFoodTypeAggregateArgs>(args: Subset<T, IntermediateCustomerFoodTypeAggregateArgs>): PrismaPromise<GetIntermediateCustomerFoodTypeAggregateType<T>>

    /**
     * Group by IntermediateCustomerFoodType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFoodTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateCustomerFoodTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateCustomerFoodTypeGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateCustomerFoodTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateCustomerFoodTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateCustomerFoodTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateCustomerFoodType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateCustomerFoodTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productFoodType<T extends ProductFoodTypeArgs = {}>(args?: Subset<T, ProductFoodTypeArgs>): CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType | null >, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T> | null >>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateCustomerFoodType findUnique
   */
  export type IntermediateCustomerFoodTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFoodType
     * 
    **/
    select?: IntermediateCustomerFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFoodTypeInclude | null
    /**
     * Throw an Error if a IntermediateCustomerFoodType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerFoodType to fetch.
     * 
    **/
    where: IntermediateCustomerFoodTypeWhereUniqueInput
  }


  /**
   * IntermediateCustomerFoodType findFirst
   */
  export type IntermediateCustomerFoodTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFoodType
     * 
    **/
    select?: IntermediateCustomerFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFoodTypeInclude | null
    /**
     * Throw an Error if a IntermediateCustomerFoodType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerFoodType to fetch.
     * 
    **/
    where?: IntermediateCustomerFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateCustomerFoodTypes.
     * 
    **/
    cursor?: IntermediateCustomerFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerFoodTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateCustomerFoodTypes.
     * 
    **/
    distinct?: Enumerable<IntermediateCustomerFoodTypeScalarFieldEnum>
  }


  /**
   * IntermediateCustomerFoodType findMany
   */
  export type IntermediateCustomerFoodTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFoodType
     * 
    **/
    select?: IntermediateCustomerFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFoodTypeInclude | null
    /**
     * Filter, which IntermediateCustomerFoodTypes to fetch.
     * 
    **/
    where?: IntermediateCustomerFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateCustomerFoodTypes.
     * 
    **/
    cursor?: IntermediateCustomerFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerFoodTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateCustomerFoodTypeScalarFieldEnum>
  }


  /**
   * IntermediateCustomerFoodType create
   */
  export type IntermediateCustomerFoodTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFoodType
     * 
    **/
    select?: IntermediateCustomerFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFoodTypeInclude | null
    /**
     * The data needed to create a IntermediateCustomerFoodType.
     * 
    **/
    data: XOR<IntermediateCustomerFoodTypeCreateInput, IntermediateCustomerFoodTypeUncheckedCreateInput>
  }


  /**
   * IntermediateCustomerFoodType createMany
   */
  export type IntermediateCustomerFoodTypeCreateManyArgs = {
    data: Enumerable<IntermediateCustomerFoodTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateCustomerFoodType update
   */
  export type IntermediateCustomerFoodTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFoodType
     * 
    **/
    select?: IntermediateCustomerFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFoodTypeInclude | null
    /**
     * The data needed to update a IntermediateCustomerFoodType.
     * 
    **/
    data: XOR<IntermediateCustomerFoodTypeUpdateInput, IntermediateCustomerFoodTypeUncheckedUpdateInput>
    /**
     * Choose, which IntermediateCustomerFoodType to update.
     * 
    **/
    where: IntermediateCustomerFoodTypeWhereUniqueInput
  }


  /**
   * IntermediateCustomerFoodType updateMany
   */
  export type IntermediateCustomerFoodTypeUpdateManyArgs = {
    data: XOR<IntermediateCustomerFoodTypeUpdateManyMutationInput, IntermediateCustomerFoodTypeUncheckedUpdateManyInput>
    where?: IntermediateCustomerFoodTypeWhereInput
  }


  /**
   * IntermediateCustomerFoodType upsert
   */
  export type IntermediateCustomerFoodTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFoodType
     * 
    **/
    select?: IntermediateCustomerFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFoodTypeInclude | null
    /**
     * The filter to search for the IntermediateCustomerFoodType to update in case it exists.
     * 
    **/
    where: IntermediateCustomerFoodTypeWhereUniqueInput
    /**
     * In case the IntermediateCustomerFoodType found by the `where` argument doesn't exist, create a new IntermediateCustomerFoodType with this data.
     * 
    **/
    create: XOR<IntermediateCustomerFoodTypeCreateInput, IntermediateCustomerFoodTypeUncheckedCreateInput>
    /**
     * In case the IntermediateCustomerFoodType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateCustomerFoodTypeUpdateInput, IntermediateCustomerFoodTypeUncheckedUpdateInput>
  }


  /**
   * IntermediateCustomerFoodType delete
   */
  export type IntermediateCustomerFoodTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFoodType
     * 
    **/
    select?: IntermediateCustomerFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFoodTypeInclude | null
    /**
     * Filter which IntermediateCustomerFoodType to delete.
     * 
    **/
    where: IntermediateCustomerFoodTypeWhereUniqueInput
  }


  /**
   * IntermediateCustomerFoodType deleteMany
   */
  export type IntermediateCustomerFoodTypeDeleteManyArgs = {
    where?: IntermediateCustomerFoodTypeWhereInput
  }


  /**
   * IntermediateCustomerFoodType without action
   */
  export type IntermediateCustomerFoodTypeArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFoodType
     * 
    **/
    select?: IntermediateCustomerFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFoodTypeInclude | null
  }



  /**
   * Model ProductFoodType
   */


  export type AggregateProductFoodType = {
    _count: ProductFoodTypeCountAggregateOutputType | null
    _avg: ProductFoodTypeAvgAggregateOutputType | null
    _sum: ProductFoodTypeSumAggregateOutputType | null
    _min: ProductFoodTypeMinAggregateOutputType | null
    _max: ProductFoodTypeMaxAggregateOutputType | null
  }

  export type ProductFoodTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductFoodTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ProductFoodTypeMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductFoodTypeMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductFoodTypeCountAggregateOutputType = {
    id: number
    label: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductFoodTypeAvgAggregateInputType = {
    id?: true
  }

  export type ProductFoodTypeSumAggregateInputType = {
    id?: true
  }

  export type ProductFoodTypeMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductFoodTypeMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductFoodTypeCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductFoodTypeAggregateArgs = {
    /**
     * Filter which ProductFoodType to aggregate.
     * 
    **/
    where?: ProductFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFoodTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductFoodTypes
    **/
    _count?: true | ProductFoodTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductFoodTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductFoodTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductFoodTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductFoodTypeMaxAggregateInputType
  }

  export type GetProductFoodTypeAggregateType<T extends ProductFoodTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductFoodType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductFoodType[P]>
      : GetScalarType<T[P], AggregateProductFoodType[P]>
  }




  export type ProductFoodTypeGroupByArgs = {
    where?: ProductFoodTypeWhereInput
    orderBy?: Enumerable<ProductFoodTypeOrderByWithAggregationInput>
    by: Array<ProductFoodTypeScalarFieldEnum>
    having?: ProductFoodTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductFoodTypeCountAggregateInputType | true
    _avg?: ProductFoodTypeAvgAggregateInputType
    _sum?: ProductFoodTypeSumAggregateInputType
    _min?: ProductFoodTypeMinAggregateInputType
    _max?: ProductFoodTypeMaxAggregateInputType
  }


  export type ProductFoodTypeGroupByOutputType = {
    id: number
    label: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ProductFoodTypeCountAggregateOutputType | null
    _avg: ProductFoodTypeAvgAggregateOutputType | null
    _sum: ProductFoodTypeSumAggregateOutputType | null
    _min: ProductFoodTypeMinAggregateOutputType | null
    _max: ProductFoodTypeMaxAggregateOutputType | null
  }

  type GetProductFoodTypeGroupByPayload<T extends ProductFoodTypeGroupByArgs> = Promise<
    Array<
      PickArray<ProductFoodTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductFoodTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductFoodTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductFoodTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProductFoodTypeSelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    intermediateCustomerFoodTypes?: boolean | IntermediateCustomerFoodTypeFindManyArgs
    intermediateProductFoodTypes?: boolean | IntermediateProductFoodTypeFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductFoodTypeCountOutputTypeArgs
  }

  export type ProductFoodTypeInclude = {
    intermediateCustomerFoodTypes?: boolean | IntermediateCustomerFoodTypeFindManyArgs
    intermediateProductFoodTypes?: boolean | IntermediateProductFoodTypeFindManyArgs
    _count?: boolean | ProductFoodTypeCountOutputTypeArgs
  }

  export type ProductFoodTypeGetPayload<
    S extends boolean | null | undefined | ProductFoodTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductFoodType
    : S extends undefined
    ? never
    : S extends ProductFoodTypeArgs | ProductFoodTypeFindManyArgs
    ?'include' extends U
    ? ProductFoodType  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateCustomerFoodTypes'
        ? Array < IntermediateCustomerFoodTypeGetPayload<S['include'][P]>>  :
        P extends 'intermediateProductFoodTypes'
        ? Array < IntermediateProductFoodTypeGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductFoodTypeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductFoodType ?ProductFoodType [P]
  : 
          P extends 'intermediateCustomerFoodTypes'
        ? Array < IntermediateCustomerFoodTypeGetPayload<S['select'][P]>>  :
        P extends 'intermediateProductFoodTypes'
        ? Array < IntermediateProductFoodTypeGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductFoodTypeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductFoodType
  : ProductFoodType


  type ProductFoodTypeCountArgs = Merge<
    Omit<ProductFoodTypeFindManyArgs, 'select' | 'include'> & {
      select?: ProductFoodTypeCountAggregateInputType | true
    }
  >

  export interface ProductFoodTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductFoodType that matches the filter.
     * @param {ProductFoodTypeFindUniqueArgs} args - Arguments to find a ProductFoodType
     * @example
     * // Get one ProductFoodType
     * const productFoodType = await prisma.productFoodType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFoodTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFoodTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductFoodType'> extends True ? CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType>, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T>>> : CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType | null >, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T> | null >>

    /**
     * Find the first ProductFoodType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFoodTypeFindFirstArgs} args - Arguments to find a ProductFoodType
     * @example
     * // Get one ProductFoodType
     * const productFoodType = await prisma.productFoodType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFoodTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFoodTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductFoodType'> extends True ? CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType>, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T>>> : CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType | null >, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T> | null >>

    /**
     * Find zero or more ProductFoodTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFoodTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductFoodTypes
     * const productFoodTypes = await prisma.productFoodType.findMany()
     * 
     * // Get first 10 ProductFoodTypes
     * const productFoodTypes = await prisma.productFoodType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productFoodTypeWithIdOnly = await prisma.productFoodType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFoodTypeFindManyArgs>(
      args?: SelectSubset<T, ProductFoodTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductFoodType>>, PrismaPromise<Array<ProductFoodTypeGetPayload<T>>>>

    /**
     * Create a ProductFoodType.
     * @param {ProductFoodTypeCreateArgs} args - Arguments to create a ProductFoodType.
     * @example
     * // Create one ProductFoodType
     * const ProductFoodType = await prisma.productFoodType.create({
     *   data: {
     *     // ... data to create a ProductFoodType
     *   }
     * })
     * 
    **/
    create<T extends ProductFoodTypeCreateArgs>(
      args: SelectSubset<T, ProductFoodTypeCreateArgs>
    ): CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType>, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T>>>

    /**
     * Create many ProductFoodTypes.
     *     @param {ProductFoodTypeCreateManyArgs} args - Arguments to create many ProductFoodTypes.
     *     @example
     *     // Create many ProductFoodTypes
     *     const productFoodType = await prisma.productFoodType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductFoodTypeCreateManyArgs>(
      args?: SelectSubset<T, ProductFoodTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductFoodType.
     * @param {ProductFoodTypeDeleteArgs} args - Arguments to delete one ProductFoodType.
     * @example
     * // Delete one ProductFoodType
     * const ProductFoodType = await prisma.productFoodType.delete({
     *   where: {
     *     // ... filter to delete one ProductFoodType
     *   }
     * })
     * 
    **/
    delete<T extends ProductFoodTypeDeleteArgs>(
      args: SelectSubset<T, ProductFoodTypeDeleteArgs>
    ): CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType>, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T>>>

    /**
     * Update one ProductFoodType.
     * @param {ProductFoodTypeUpdateArgs} args - Arguments to update one ProductFoodType.
     * @example
     * // Update one ProductFoodType
     * const productFoodType = await prisma.productFoodType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductFoodTypeUpdateArgs>(
      args: SelectSubset<T, ProductFoodTypeUpdateArgs>
    ): CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType>, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T>>>

    /**
     * Delete zero or more ProductFoodTypes.
     * @param {ProductFoodTypeDeleteManyArgs} args - Arguments to filter ProductFoodTypes to delete.
     * @example
     * // Delete a few ProductFoodTypes
     * const { count } = await prisma.productFoodType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductFoodTypeDeleteManyArgs>(
      args?: SelectSubset<T, ProductFoodTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductFoodTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFoodTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductFoodTypes
     * const productFoodType = await prisma.productFoodType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductFoodTypeUpdateManyArgs>(
      args: SelectSubset<T, ProductFoodTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductFoodType.
     * @param {ProductFoodTypeUpsertArgs} args - Arguments to update or create a ProductFoodType.
     * @example
     * // Update or create a ProductFoodType
     * const productFoodType = await prisma.productFoodType.upsert({
     *   create: {
     *     // ... data to create a ProductFoodType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductFoodType we want to update
     *   }
     * })
    **/
    upsert<T extends ProductFoodTypeUpsertArgs>(
      args: SelectSubset<T, ProductFoodTypeUpsertArgs>
    ): CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType>, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T>>>

    /**
     * Count the number of ProductFoodTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFoodTypeCountArgs} args - Arguments to filter ProductFoodTypes to count.
     * @example
     * // Count the number of ProductFoodTypes
     * const count = await prisma.productFoodType.count({
     *   where: {
     *     // ... the filter for the ProductFoodTypes we want to count
     *   }
     * })
    **/
    count<T extends ProductFoodTypeCountArgs>(
      args?: Subset<T, ProductFoodTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductFoodTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductFoodType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFoodTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductFoodTypeAggregateArgs>(args: Subset<T, ProductFoodTypeAggregateArgs>): PrismaPromise<GetProductFoodTypeAggregateType<T>>

    /**
     * Group by ProductFoodType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFoodTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductFoodTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductFoodTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProductFoodTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductFoodTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductFoodTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductFoodType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductFoodTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateCustomerFoodTypes<T extends IntermediateCustomerFoodTypeFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerFoodTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerFoodType>>, PrismaPromise<Array<IntermediateCustomerFoodTypeGetPayload<T>>>>;

    intermediateProductFoodTypes<T extends IntermediateProductFoodTypeFindManyArgs = {}>(args?: Subset<T, IntermediateProductFoodTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateProductFoodType>>, PrismaPromise<Array<IntermediateProductFoodTypeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductFoodType findUnique
   */
  export type ProductFoodTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodType
     * 
    **/
    select?: ProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFoodTypeInclude | null
    /**
     * Throw an Error if a ProductFoodType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductFoodType to fetch.
     * 
    **/
    where: ProductFoodTypeWhereUniqueInput
  }


  /**
   * ProductFoodType findFirst
   */
  export type ProductFoodTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodType
     * 
    **/
    select?: ProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFoodTypeInclude | null
    /**
     * Throw an Error if a ProductFoodType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductFoodType to fetch.
     * 
    **/
    where?: ProductFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFoodTypes.
     * 
    **/
    cursor?: ProductFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFoodTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFoodTypes.
     * 
    **/
    distinct?: Enumerable<ProductFoodTypeScalarFieldEnum>
  }


  /**
   * ProductFoodType findMany
   */
  export type ProductFoodTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodType
     * 
    **/
    select?: ProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFoodTypeInclude | null
    /**
     * Filter, which ProductFoodTypes to fetch.
     * 
    **/
    where?: ProductFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductFoodTypes.
     * 
    **/
    cursor?: ProductFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFoodTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductFoodTypeScalarFieldEnum>
  }


  /**
   * ProductFoodType create
   */
  export type ProductFoodTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodType
     * 
    **/
    select?: ProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFoodTypeInclude | null
    /**
     * The data needed to create a ProductFoodType.
     * 
    **/
    data: XOR<ProductFoodTypeCreateInput, ProductFoodTypeUncheckedCreateInput>
  }


  /**
   * ProductFoodType createMany
   */
  export type ProductFoodTypeCreateManyArgs = {
    data: Enumerable<ProductFoodTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductFoodType update
   */
  export type ProductFoodTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodType
     * 
    **/
    select?: ProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFoodTypeInclude | null
    /**
     * The data needed to update a ProductFoodType.
     * 
    **/
    data: XOR<ProductFoodTypeUpdateInput, ProductFoodTypeUncheckedUpdateInput>
    /**
     * Choose, which ProductFoodType to update.
     * 
    **/
    where: ProductFoodTypeWhereUniqueInput
  }


  /**
   * ProductFoodType updateMany
   */
  export type ProductFoodTypeUpdateManyArgs = {
    data: XOR<ProductFoodTypeUpdateManyMutationInput, ProductFoodTypeUncheckedUpdateManyInput>
    where?: ProductFoodTypeWhereInput
  }


  /**
   * ProductFoodType upsert
   */
  export type ProductFoodTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodType
     * 
    **/
    select?: ProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFoodTypeInclude | null
    /**
     * The filter to search for the ProductFoodType to update in case it exists.
     * 
    **/
    where: ProductFoodTypeWhereUniqueInput
    /**
     * In case the ProductFoodType found by the `where` argument doesn't exist, create a new ProductFoodType with this data.
     * 
    **/
    create: XOR<ProductFoodTypeCreateInput, ProductFoodTypeUncheckedCreateInput>
    /**
     * In case the ProductFoodType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductFoodTypeUpdateInput, ProductFoodTypeUncheckedUpdateInput>
  }


  /**
   * ProductFoodType delete
   */
  export type ProductFoodTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodType
     * 
    **/
    select?: ProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFoodTypeInclude | null
    /**
     * Filter which ProductFoodType to delete.
     * 
    **/
    where: ProductFoodTypeWhereUniqueInput
  }


  /**
   * ProductFoodType deleteMany
   */
  export type ProductFoodTypeDeleteManyArgs = {
    where?: ProductFoodTypeWhereInput
  }


  /**
   * ProductFoodType without action
   */
  export type ProductFoodTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductFoodType
     * 
    **/
    select?: ProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFoodTypeInclude | null
  }



  /**
   * Model IntermediateProductFoodType
   */


  export type AggregateIntermediateProductFoodType = {
    _count: IntermediateProductFoodTypeCountAggregateOutputType | null
    _avg: IntermediateProductFoodTypeAvgAggregateOutputType | null
    _sum: IntermediateProductFoodTypeSumAggregateOutputType | null
    _min: IntermediateProductFoodTypeMinAggregateOutputType | null
    _max: IntermediateProductFoodTypeMaxAggregateOutputType | null
  }

  export type IntermediateProductFoodTypeAvgAggregateOutputType = {
    productFoodTypeId: number | null
    productId: number | null
  }

  export type IntermediateProductFoodTypeSumAggregateOutputType = {
    productFoodTypeId: number | null
    productId: number | null
  }

  export type IntermediateProductFoodTypeMinAggregateOutputType = {
    productFoodTypeId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateProductFoodTypeMaxAggregateOutputType = {
    productFoodTypeId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateProductFoodTypeCountAggregateOutputType = {
    productFoodTypeId: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateProductFoodTypeAvgAggregateInputType = {
    productFoodTypeId?: true
    productId?: true
  }

  export type IntermediateProductFoodTypeSumAggregateInputType = {
    productFoodTypeId?: true
    productId?: true
  }

  export type IntermediateProductFoodTypeMinAggregateInputType = {
    productFoodTypeId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateProductFoodTypeMaxAggregateInputType = {
    productFoodTypeId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateProductFoodTypeCountAggregateInputType = {
    productFoodTypeId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateProductFoodTypeAggregateArgs = {
    /**
     * Filter which IntermediateProductFoodType to aggregate.
     * 
    **/
    where?: IntermediateProductFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateProductFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductFoodTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateProductFoodTypes
    **/
    _count?: true | IntermediateProductFoodTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateProductFoodTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateProductFoodTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateProductFoodTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateProductFoodTypeMaxAggregateInputType
  }

  export type GetIntermediateProductFoodTypeAggregateType<T extends IntermediateProductFoodTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateProductFoodType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateProductFoodType[P]>
      : GetScalarType<T[P], AggregateIntermediateProductFoodType[P]>
  }




  export type IntermediateProductFoodTypeGroupByArgs = {
    where?: IntermediateProductFoodTypeWhereInput
    orderBy?: Enumerable<IntermediateProductFoodTypeOrderByWithAggregationInput>
    by: Array<IntermediateProductFoodTypeScalarFieldEnum>
    having?: IntermediateProductFoodTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateProductFoodTypeCountAggregateInputType | true
    _avg?: IntermediateProductFoodTypeAvgAggregateInputType
    _sum?: IntermediateProductFoodTypeSumAggregateInputType
    _min?: IntermediateProductFoodTypeMinAggregateInputType
    _max?: IntermediateProductFoodTypeMaxAggregateInputType
  }


  export type IntermediateProductFoodTypeGroupByOutputType = {
    productFoodTypeId: number
    productId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateProductFoodTypeCountAggregateOutputType | null
    _avg: IntermediateProductFoodTypeAvgAggregateOutputType | null
    _sum: IntermediateProductFoodTypeSumAggregateOutputType | null
    _min: IntermediateProductFoodTypeMinAggregateOutputType | null
    _max: IntermediateProductFoodTypeMaxAggregateOutputType | null
  }

  type GetIntermediateProductFoodTypeGroupByPayload<T extends IntermediateProductFoodTypeGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateProductFoodTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateProductFoodTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateProductFoodTypeGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateProductFoodTypeGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateProductFoodTypeSelect = {
    productFoodType?: boolean | ProductFoodTypeArgs
    productFoodTypeId?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateProductFoodTypeInclude = {
    productFoodType?: boolean | ProductFoodTypeArgs
    product?: boolean | ProductArgs
  }

  export type IntermediateProductFoodTypeGetPayload<
    S extends boolean | null | undefined | IntermediateProductFoodTypeArgs,
    U = keyof S
      > = S extends true
        ? IntermediateProductFoodType
    : S extends undefined
    ? never
    : S extends IntermediateProductFoodTypeArgs | IntermediateProductFoodTypeFindManyArgs
    ?'include' extends U
    ? IntermediateProductFoodType  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'productFoodType'
        ? ProductFoodTypeGetPayload<S['include'][P]> :
        P extends 'product'
        ? ProductGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateProductFoodType ?IntermediateProductFoodType [P]
  : 
          P extends 'productFoodType'
        ? ProductFoodTypeGetPayload<S['select'][P]> :
        P extends 'product'
        ? ProductGetPayload<S['select'][P]> : never
  } 
    : IntermediateProductFoodType
  : IntermediateProductFoodType


  type IntermediateProductFoodTypeCountArgs = Merge<
    Omit<IntermediateProductFoodTypeFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateProductFoodTypeCountAggregateInputType | true
    }
  >

  export interface IntermediateProductFoodTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateProductFoodType that matches the filter.
     * @param {IntermediateProductFoodTypeFindUniqueArgs} args - Arguments to find a IntermediateProductFoodType
     * @example
     * // Get one IntermediateProductFoodType
     * const intermediateProductFoodType = await prisma.intermediateProductFoodType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateProductFoodTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateProductFoodTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateProductFoodType'> extends True ? CheckSelect<T, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodType>, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodTypeGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodType | null >, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodTypeGetPayload<T> | null >>

    /**
     * Find the first IntermediateProductFoodType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductFoodTypeFindFirstArgs} args - Arguments to find a IntermediateProductFoodType
     * @example
     * // Get one IntermediateProductFoodType
     * const intermediateProductFoodType = await prisma.intermediateProductFoodType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateProductFoodTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateProductFoodTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateProductFoodType'> extends True ? CheckSelect<T, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodType>, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodTypeGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodType | null >, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodTypeGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateProductFoodTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductFoodTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateProductFoodTypes
     * const intermediateProductFoodTypes = await prisma.intermediateProductFoodType.findMany()
     * 
     * // Get first 10 IntermediateProductFoodTypes
     * const intermediateProductFoodTypes = await prisma.intermediateProductFoodType.findMany({ take: 10 })
     * 
     * // Only select the `productFoodTypeId`
     * const intermediateProductFoodTypeWithProductFoodTypeIdOnly = await prisma.intermediateProductFoodType.findMany({ select: { productFoodTypeId: true } })
     * 
    **/
    findMany<T extends IntermediateProductFoodTypeFindManyArgs>(
      args?: SelectSubset<T, IntermediateProductFoodTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateProductFoodType>>, PrismaPromise<Array<IntermediateProductFoodTypeGetPayload<T>>>>

    /**
     * Create a IntermediateProductFoodType.
     * @param {IntermediateProductFoodTypeCreateArgs} args - Arguments to create a IntermediateProductFoodType.
     * @example
     * // Create one IntermediateProductFoodType
     * const IntermediateProductFoodType = await prisma.intermediateProductFoodType.create({
     *   data: {
     *     // ... data to create a IntermediateProductFoodType
     *   }
     * })
     * 
    **/
    create<T extends IntermediateProductFoodTypeCreateArgs>(
      args: SelectSubset<T, IntermediateProductFoodTypeCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodType>, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodTypeGetPayload<T>>>

    /**
     * Create many IntermediateProductFoodTypes.
     *     @param {IntermediateProductFoodTypeCreateManyArgs} args - Arguments to create many IntermediateProductFoodTypes.
     *     @example
     *     // Create many IntermediateProductFoodTypes
     *     const intermediateProductFoodType = await prisma.intermediateProductFoodType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateProductFoodTypeCreateManyArgs>(
      args?: SelectSubset<T, IntermediateProductFoodTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateProductFoodType.
     * @param {IntermediateProductFoodTypeDeleteArgs} args - Arguments to delete one IntermediateProductFoodType.
     * @example
     * // Delete one IntermediateProductFoodType
     * const IntermediateProductFoodType = await prisma.intermediateProductFoodType.delete({
     *   where: {
     *     // ... filter to delete one IntermediateProductFoodType
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateProductFoodTypeDeleteArgs>(
      args: SelectSubset<T, IntermediateProductFoodTypeDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodType>, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodTypeGetPayload<T>>>

    /**
     * Update one IntermediateProductFoodType.
     * @param {IntermediateProductFoodTypeUpdateArgs} args - Arguments to update one IntermediateProductFoodType.
     * @example
     * // Update one IntermediateProductFoodType
     * const intermediateProductFoodType = await prisma.intermediateProductFoodType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateProductFoodTypeUpdateArgs>(
      args: SelectSubset<T, IntermediateProductFoodTypeUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodType>, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodTypeGetPayload<T>>>

    /**
     * Delete zero or more IntermediateProductFoodTypes.
     * @param {IntermediateProductFoodTypeDeleteManyArgs} args - Arguments to filter IntermediateProductFoodTypes to delete.
     * @example
     * // Delete a few IntermediateProductFoodTypes
     * const { count } = await prisma.intermediateProductFoodType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateProductFoodTypeDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateProductFoodTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateProductFoodTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductFoodTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateProductFoodTypes
     * const intermediateProductFoodType = await prisma.intermediateProductFoodType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateProductFoodTypeUpdateManyArgs>(
      args: SelectSubset<T, IntermediateProductFoodTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateProductFoodType.
     * @param {IntermediateProductFoodTypeUpsertArgs} args - Arguments to update or create a IntermediateProductFoodType.
     * @example
     * // Update or create a IntermediateProductFoodType
     * const intermediateProductFoodType = await prisma.intermediateProductFoodType.upsert({
     *   create: {
     *     // ... data to create a IntermediateProductFoodType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateProductFoodType we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateProductFoodTypeUpsertArgs>(
      args: SelectSubset<T, IntermediateProductFoodTypeUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodType>, Prisma__IntermediateProductFoodTypeClient<IntermediateProductFoodTypeGetPayload<T>>>

    /**
     * Count the number of IntermediateProductFoodTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductFoodTypeCountArgs} args - Arguments to filter IntermediateProductFoodTypes to count.
     * @example
     * // Count the number of IntermediateProductFoodTypes
     * const count = await prisma.intermediateProductFoodType.count({
     *   where: {
     *     // ... the filter for the IntermediateProductFoodTypes we want to count
     *   }
     * })
    **/
    count<T extends IntermediateProductFoodTypeCountArgs>(
      args?: Subset<T, IntermediateProductFoodTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateProductFoodTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateProductFoodType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductFoodTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateProductFoodTypeAggregateArgs>(args: Subset<T, IntermediateProductFoodTypeAggregateArgs>): PrismaPromise<GetIntermediateProductFoodTypeAggregateType<T>>

    /**
     * Group by IntermediateProductFoodType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductFoodTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateProductFoodTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateProductFoodTypeGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateProductFoodTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateProductFoodTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateProductFoodTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateProductFoodType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateProductFoodTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productFoodType<T extends ProductFoodTypeArgs = {}>(args?: Subset<T, ProductFoodTypeArgs>): CheckSelect<T, Prisma__ProductFoodTypeClient<ProductFoodType | null >, Prisma__ProductFoodTypeClient<ProductFoodTypeGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateProductFoodType findUnique
   */
  export type IntermediateProductFoodTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductFoodType
     * 
    **/
    select?: IntermediateProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductFoodTypeInclude | null
    /**
     * Throw an Error if a IntermediateProductFoodType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateProductFoodType to fetch.
     * 
    **/
    where: IntermediateProductFoodTypeWhereUniqueInput
  }


  /**
   * IntermediateProductFoodType findFirst
   */
  export type IntermediateProductFoodTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductFoodType
     * 
    **/
    select?: IntermediateProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductFoodTypeInclude | null
    /**
     * Throw an Error if a IntermediateProductFoodType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateProductFoodType to fetch.
     * 
    **/
    where?: IntermediateProductFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateProductFoodTypes.
     * 
    **/
    cursor?: IntermediateProductFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductFoodTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateProductFoodTypes.
     * 
    **/
    distinct?: Enumerable<IntermediateProductFoodTypeScalarFieldEnum>
  }


  /**
   * IntermediateProductFoodType findMany
   */
  export type IntermediateProductFoodTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductFoodType
     * 
    **/
    select?: IntermediateProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductFoodTypeInclude | null
    /**
     * Filter, which IntermediateProductFoodTypes to fetch.
     * 
    **/
    where?: IntermediateProductFoodTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductFoodTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductFoodTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateProductFoodTypes.
     * 
    **/
    cursor?: IntermediateProductFoodTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductFoodTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductFoodTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateProductFoodTypeScalarFieldEnum>
  }


  /**
   * IntermediateProductFoodType create
   */
  export type IntermediateProductFoodTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductFoodType
     * 
    **/
    select?: IntermediateProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductFoodTypeInclude | null
    /**
     * The data needed to create a IntermediateProductFoodType.
     * 
    **/
    data: XOR<IntermediateProductFoodTypeCreateInput, IntermediateProductFoodTypeUncheckedCreateInput>
  }


  /**
   * IntermediateProductFoodType createMany
   */
  export type IntermediateProductFoodTypeCreateManyArgs = {
    data: Enumerable<IntermediateProductFoodTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateProductFoodType update
   */
  export type IntermediateProductFoodTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductFoodType
     * 
    **/
    select?: IntermediateProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductFoodTypeInclude | null
    /**
     * The data needed to update a IntermediateProductFoodType.
     * 
    **/
    data: XOR<IntermediateProductFoodTypeUpdateInput, IntermediateProductFoodTypeUncheckedUpdateInput>
    /**
     * Choose, which IntermediateProductFoodType to update.
     * 
    **/
    where: IntermediateProductFoodTypeWhereUniqueInput
  }


  /**
   * IntermediateProductFoodType updateMany
   */
  export type IntermediateProductFoodTypeUpdateManyArgs = {
    data: XOR<IntermediateProductFoodTypeUpdateManyMutationInput, IntermediateProductFoodTypeUncheckedUpdateManyInput>
    where?: IntermediateProductFoodTypeWhereInput
  }


  /**
   * IntermediateProductFoodType upsert
   */
  export type IntermediateProductFoodTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductFoodType
     * 
    **/
    select?: IntermediateProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductFoodTypeInclude | null
    /**
     * The filter to search for the IntermediateProductFoodType to update in case it exists.
     * 
    **/
    where: IntermediateProductFoodTypeWhereUniqueInput
    /**
     * In case the IntermediateProductFoodType found by the `where` argument doesn't exist, create a new IntermediateProductFoodType with this data.
     * 
    **/
    create: XOR<IntermediateProductFoodTypeCreateInput, IntermediateProductFoodTypeUncheckedCreateInput>
    /**
     * In case the IntermediateProductFoodType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateProductFoodTypeUpdateInput, IntermediateProductFoodTypeUncheckedUpdateInput>
  }


  /**
   * IntermediateProductFoodType delete
   */
  export type IntermediateProductFoodTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductFoodType
     * 
    **/
    select?: IntermediateProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductFoodTypeInclude | null
    /**
     * Filter which IntermediateProductFoodType to delete.
     * 
    **/
    where: IntermediateProductFoodTypeWhereUniqueInput
  }


  /**
   * IntermediateProductFoodType deleteMany
   */
  export type IntermediateProductFoodTypeDeleteManyArgs = {
    where?: IntermediateProductFoodTypeWhereInput
  }


  /**
   * IntermediateProductFoodType without action
   */
  export type IntermediateProductFoodTypeArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductFoodType
     * 
    **/
    select?: IntermediateProductFoodTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductFoodTypeInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    productProviderId: number | null
    productCategoryId: number | null
    productFlavorId: number | null
    productVendorId: number | null
    MSP: number | null
    WSP: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    productProviderId: number | null
    productCategoryId: number | null
    productFlavorId: number | null
    productVendorId: number | null
    MSP: number | null
    WSP: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    activeStatus: ActiveStatus | null
    name: string | null
    label: string | null
    ingredientLabel: string | null
    allergenLabel: string | null
    expertComment: string | null
    productProviderId: number | null
    productCategoryId: number | null
    productFlavorId: number | null
    productVendorId: number | null
    externalSku: string | null
    upcCode: string | null
    MSP: number | null
    WSP: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    activeStatus: ActiveStatus | null
    name: string | null
    label: string | null
    ingredientLabel: string | null
    allergenLabel: string | null
    expertComment: string | null
    productProviderId: number | null
    productCategoryId: number | null
    productFlavorId: number | null
    productVendorId: number | null
    externalSku: string | null
    upcCode: string | null
    MSP: number | null
    WSP: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    activeStatus: number
    name: number
    label: number
    ingredientLabel: number
    allergenLabel: number
    expertComment: number
    productProviderId: number
    productCategoryId: number
    productFlavorId: number
    productVendorId: number
    externalSku: number
    upcCode: number
    MSP: number
    WSP: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    productProviderId?: true
    productCategoryId?: true
    productFlavorId?: true
    productVendorId?: true
    MSP?: true
    WSP?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    productProviderId?: true
    productCategoryId?: true
    productFlavorId?: true
    productVendorId?: true
    MSP?: true
    WSP?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    activeStatus?: true
    name?: true
    label?: true
    ingredientLabel?: true
    allergenLabel?: true
    expertComment?: true
    productProviderId?: true
    productCategoryId?: true
    productFlavorId?: true
    productVendorId?: true
    externalSku?: true
    upcCode?: true
    MSP?: true
    WSP?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    activeStatus?: true
    name?: true
    label?: true
    ingredientLabel?: true
    allergenLabel?: true
    expertComment?: true
    productProviderId?: true
    productCategoryId?: true
    productFlavorId?: true
    productVendorId?: true
    externalSku?: true
    upcCode?: true
    MSP?: true
    WSP?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    activeStatus?: true
    name?: true
    label?: true
    ingredientLabel?: true
    allergenLabel?: true
    expertComment?: true
    productProviderId?: true
    productCategoryId?: true
    productFlavorId?: true
    productVendorId?: true
    externalSku?: true
    upcCode?: true
    MSP?: true
    WSP?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    activeStatus: ActiveStatus | null
    name: string | null
    label: string | null
    ingredientLabel: string | null
    allergenLabel: string | null
    expertComment: string | null
    productProviderId: number
    productCategoryId: number | null
    productFlavorId: number | null
    productVendorId: number | null
    externalSku: string
    upcCode: string | null
    MSP: number | null
    WSP: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Promise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    activeStatus?: boolean
    name?: boolean
    label?: boolean
    ingredientLabel?: boolean
    allergenLabel?: boolean
    expertComment?: boolean
    productProvider?: boolean | ProductProviderArgs
    productProviderId?: boolean
    productCategory?: boolean | ProductCategoryArgs
    productCategoryId?: boolean
    productFlavor?: boolean | ProductFlavorArgs
    productFlavorId?: boolean
    productVendor?: boolean | ProductVendorArgs
    productVendorId?: boolean
    intermediateProductFoodTypes?: boolean | IntermediateProductFoodTypeFindManyArgs
    intermediateProductIngredients?: boolean | IntermediateProductIngredientFindManyArgs
    intermediateProductAllergens?: boolean | IntermediateProductAllergenFindManyArgs
    intermediateProductCookingMethods?: boolean | IntermediateProductCookingMethodFindManyArgs
    intermediatePractitionerBoxProduct?: boolean | IntermediatePractitionerBoxProductFindManyArgs
    productNutritionFact?: boolean | ProductNutritionFactArgs
    externalSku?: boolean
    upcCode?: boolean
    MSP?: boolean
    WSP?: boolean
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerFindManyArgs
    customerProductDistances?: boolean | CustomerProductDistanceFindManyArgs
    customerBoxItems?: boolean | CustomerBoxItemsFindManyArgs
    productImages?: boolean | ProductImageFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductInclude = {
    productProvider?: boolean | ProductProviderArgs
    productCategory?: boolean | ProductCategoryArgs
    productFlavor?: boolean | ProductFlavorArgs
    productVendor?: boolean | ProductVendorArgs
    intermediateProductFoodTypes?: boolean | IntermediateProductFoodTypeFindManyArgs
    intermediateProductIngredients?: boolean | IntermediateProductIngredientFindManyArgs
    intermediateProductAllergens?: boolean | IntermediateProductAllergenFindManyArgs
    intermediateProductCookingMethods?: boolean | IntermediateProductCookingMethodFindManyArgs
    intermediatePractitionerBoxProduct?: boolean | IntermediatePractitionerBoxProductFindManyArgs
    productNutritionFact?: boolean | ProductNutritionFactArgs
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerFindManyArgs
    customerProductDistances?: boolean | CustomerProductDistanceFindManyArgs
    customerBoxItems?: boolean | CustomerBoxItemsFindManyArgs
    productImages?: boolean | ProductImageFindManyArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'productProvider'
        ? ProductProviderGetPayload<S['include'][P]> :
        P extends 'productCategory'
        ? ProductCategoryGetPayload<S['include'][P]> | null :
        P extends 'productFlavor'
        ? ProductFlavorGetPayload<S['include'][P]> | null :
        P extends 'productVendor'
        ? ProductVendorGetPayload<S['include'][P]> | null :
        P extends 'intermediateProductFoodTypes'
        ? Array < IntermediateProductFoodTypeGetPayload<S['include'][P]>>  :
        P extends 'intermediateProductIngredients'
        ? Array < IntermediateProductIngredientGetPayload<S['include'][P]>>  :
        P extends 'intermediateProductAllergens'
        ? Array < IntermediateProductAllergenGetPayload<S['include'][P]>>  :
        P extends 'intermediateProductCookingMethods'
        ? Array < IntermediateProductCookingMethodGetPayload<S['include'][P]>>  :
        P extends 'intermediatePractitionerBoxProduct'
        ? Array < IntermediatePractitionerBoxProductGetPayload<S['include'][P]>>  :
        P extends 'productNutritionFact'
        ? ProductNutritionFactGetPayload<S['include'][P]> | null :
        P extends 'surveyQuestionAnswer'
        ? Array < SurveyQuestionAnswerGetPayload<S['include'][P]>>  :
        P extends 'customerProductDistances'
        ? Array < CustomerProductDistanceGetPayload<S['include'][P]>>  :
        P extends 'customerBoxItems'
        ? Array < CustomerBoxItemsGetPayload<S['include'][P]>>  :
        P extends 'productImages'
        ? Array < ProductImageGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Product ?Product [P]
  : 
          P extends 'productProvider'
        ? ProductProviderGetPayload<S['select'][P]> :
        P extends 'productCategory'
        ? ProductCategoryGetPayload<S['select'][P]> | null :
        P extends 'productFlavor'
        ? ProductFlavorGetPayload<S['select'][P]> | null :
        P extends 'productVendor'
        ? ProductVendorGetPayload<S['select'][P]> | null :
        P extends 'intermediateProductFoodTypes'
        ? Array < IntermediateProductFoodTypeGetPayload<S['select'][P]>>  :
        P extends 'intermediateProductIngredients'
        ? Array < IntermediateProductIngredientGetPayload<S['select'][P]>>  :
        P extends 'intermediateProductAllergens'
        ? Array < IntermediateProductAllergenGetPayload<S['select'][P]>>  :
        P extends 'intermediateProductCookingMethods'
        ? Array < IntermediateProductCookingMethodGetPayload<S['select'][P]>>  :
        P extends 'intermediatePractitionerBoxProduct'
        ? Array < IntermediatePractitionerBoxProductGetPayload<S['select'][P]>>  :
        P extends 'productNutritionFact'
        ? ProductNutritionFactGetPayload<S['select'][P]> | null :
        P extends 'surveyQuestionAnswer'
        ? Array < SurveyQuestionAnswerGetPayload<S['select'][P]>>  :
        P extends 'customerProductDistances'
        ? Array < CustomerProductDistanceGetPayload<S['select'][P]>>  :
        P extends 'customerBoxItems'
        ? Array < CustomerBoxItemsGetPayload<S['select'][P]>>  :
        P extends 'productImages'
        ? Array < ProductImageGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productProvider<T extends ProductProviderArgs = {}>(args?: Subset<T, ProductProviderArgs>): CheckSelect<T, Prisma__ProductProviderClient<ProductProvider | null >, Prisma__ProductProviderClient<ProductProviderGetPayload<T> | null >>;

    productCategory<T extends ProductCategoryArgs = {}>(args?: Subset<T, ProductCategoryArgs>): CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory | null >, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | null >>;

    productFlavor<T extends ProductFlavorArgs = {}>(args?: Subset<T, ProductFlavorArgs>): CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor | null >, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T> | null >>;

    productVendor<T extends ProductVendorArgs = {}>(args?: Subset<T, ProductVendorArgs>): CheckSelect<T, Prisma__ProductVendorClient<ProductVendor | null >, Prisma__ProductVendorClient<ProductVendorGetPayload<T> | null >>;

    intermediateProductFoodTypes<T extends IntermediateProductFoodTypeFindManyArgs = {}>(args?: Subset<T, IntermediateProductFoodTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateProductFoodType>>, PrismaPromise<Array<IntermediateProductFoodTypeGetPayload<T>>>>;

    intermediateProductIngredients<T extends IntermediateProductIngredientFindManyArgs = {}>(args?: Subset<T, IntermediateProductIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateProductIngredient>>, PrismaPromise<Array<IntermediateProductIngredientGetPayload<T>>>>;

    intermediateProductAllergens<T extends IntermediateProductAllergenFindManyArgs = {}>(args?: Subset<T, IntermediateProductAllergenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateProductAllergen>>, PrismaPromise<Array<IntermediateProductAllergenGetPayload<T>>>>;

    intermediateProductCookingMethods<T extends IntermediateProductCookingMethodFindManyArgs = {}>(args?: Subset<T, IntermediateProductCookingMethodFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateProductCookingMethod>>, PrismaPromise<Array<IntermediateProductCookingMethodGetPayload<T>>>>;

    intermediatePractitionerBoxProduct<T extends IntermediatePractitionerBoxProductFindManyArgs = {}>(args?: Subset<T, IntermediatePractitionerBoxProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediatePractitionerBoxProduct>>, PrismaPromise<Array<IntermediatePractitionerBoxProductGetPayload<T>>>>;

    productNutritionFact<T extends ProductNutritionFactArgs = {}>(args?: Subset<T, ProductNutritionFactArgs>): CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact | null >, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T> | null >>;

    surveyQuestionAnswer<T extends SurveyQuestionAnswerFindManyArgs = {}>(args?: Subset<T, SurveyQuestionAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SurveyQuestionAnswer>>, PrismaPromise<Array<SurveyQuestionAnswerGetPayload<T>>>>;

    customerProductDistances<T extends CustomerProductDistanceFindManyArgs = {}>(args?: Subset<T, CustomerProductDistanceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerProductDistance>>, PrismaPromise<Array<CustomerProductDistanceGetPayload<T>>>>;

    customerBoxItems<T extends CustomerBoxItemsFindManyArgs = {}>(args?: Subset<T, CustomerBoxItemsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CustomerBoxItems>>, PrismaPromise<Array<CustomerBoxItemsGetPayload<T>>>>;

    productImages<T extends ProductImageFindManyArgs = {}>(args?: Subset<T, ProductImageFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ProductImage>>, PrismaPromise<Array<ProductImageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model ProductImage
   */


  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    position: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    id: number | null
    productId: number | null
    position: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: number | null
    productId: number | null
    src: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    src: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    productId: number
    src: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    id?: true
    productId?: true
    position?: true
  }

  export type ProductImageSumAggregateInputType = {
    id?: true
    productId?: true
    position?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    productId?: true
    src?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    productId?: true
    src?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    productId?: true
    src?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductImageAggregateArgs = {
    /**
     * Filter which ProductImage to aggregate.
     * 
    **/
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs = {
    where?: ProductImageWhereInput
    orderBy?: Enumerable<ProductImageOrderByWithAggregationInput>
    by: Array<ProductImageScalarFieldEnum>
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }


  export type ProductImageGroupByOutputType = {
    id: number
    productId: number
    src: string
    position: number
    createdAt: Date
    updatedAt: Date
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Promise<
    Array<
      PickArray<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect = {
    id?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    src?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductImageInclude = {
    product?: boolean | ProductArgs
  }

  export type ProductImageGetPayload<
    S extends boolean | null | undefined | ProductImageArgs,
    U = keyof S
      > = S extends true
        ? ProductImage
    : S extends undefined
    ? never
    : S extends ProductImageArgs | ProductImageFindManyArgs
    ?'include' extends U
    ? ProductImage  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductImage ?ProductImage [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> : never
  } 
    : ProductImage
  : ProductImage


  type ProductImageCountArgs = Merge<
    Omit<ProductImageFindManyArgs, 'select' | 'include'> & {
      select?: ProductImageCountAggregateInputType | true
    }
  >

  export interface ProductImageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductImage'> extends True ? CheckSelect<T, Prisma__ProductImageClient<ProductImage>, Prisma__ProductImageClient<ProductImageGetPayload<T>>> : CheckSelect<T, Prisma__ProductImageClient<ProductImage | null >, Prisma__ProductImageClient<ProductImageGetPayload<T> | null >>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductImage'> extends True ? CheckSelect<T, Prisma__ProductImageClient<ProductImage>, Prisma__ProductImageClient<ProductImageGetPayload<T>>> : CheckSelect<T, Prisma__ProductImageClient<ProductImage | null >, Prisma__ProductImageClient<ProductImageGetPayload<T> | null >>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductImageFindManyArgs>(
      args?: SelectSubset<T, ProductImageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductImage>>, PrismaPromise<Array<ProductImageGetPayload<T>>>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
    **/
    create<T extends ProductImageCreateArgs>(
      args: SelectSubset<T, ProductImageCreateArgs>
    ): CheckSelect<T, Prisma__ProductImageClient<ProductImage>, Prisma__ProductImageClient<ProductImageGetPayload<T>>>

    /**
     * Create many ProductImages.
     *     @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     *     @example
     *     // Create many ProductImages
     *     const productImage = await prisma.productImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductImageCreateManyArgs>(
      args?: SelectSubset<T, ProductImageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
    **/
    delete<T extends ProductImageDeleteArgs>(
      args: SelectSubset<T, ProductImageDeleteArgs>
    ): CheckSelect<T, Prisma__ProductImageClient<ProductImage>, Prisma__ProductImageClient<ProductImageGetPayload<T>>>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductImageUpdateArgs>(
      args: SelectSubset<T, ProductImageUpdateArgs>
    ): CheckSelect<T, Prisma__ProductImageClient<ProductImage>, Prisma__ProductImageClient<ProductImageGetPayload<T>>>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductImageDeleteManyArgs>(
      args?: SelectSubset<T, ProductImageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductImageUpdateManyArgs>(
      args: SelectSubset<T, ProductImageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
    **/
    upsert<T extends ProductImageUpsertArgs>(
      args: SelectSubset<T, ProductImageUpsertArgs>
    ): CheckSelect<T, Prisma__ProductImageClient<ProductImage>, Prisma__ProductImageClient<ProductImageGetPayload<T>>>

    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductImageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Throw an Error if a ProductImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductImage to fetch.
     * 
    **/
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Throw an Error if a ProductImage can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductImage to fetch.
     * 
    **/
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     * 
    **/
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     * 
    **/
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }


  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Filter, which ProductImages to fetch.
     * 
    **/
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     * 
    **/
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductImageScalarFieldEnum>
  }


  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * The data needed to create a ProductImage.
     * 
    **/
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }


  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs = {
    data: Enumerable<ProductImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * The data needed to update a ProductImage.
     * 
    **/
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     * 
    **/
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs = {
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    where?: ProductImageWhereInput
  }


  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     * 
    **/
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     * 
    **/
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }


  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
    /**
     * Filter which ProductImage to delete.
     * 
    **/
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs = {
    where?: ProductImageWhereInput
  }


  /**
   * ProductImage without action
   */
  export type ProductImageArgs = {
    /**
     * Select specific fields to fetch from the ProductImage
     * 
    **/
    select?: ProductImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductImageInclude | null
  }



  /**
   * Model IntermediateProductCookingMethod
   */


  export type AggregateIntermediateProductCookingMethod = {
    _count: IntermediateProductCookingMethodCountAggregateOutputType | null
    _avg: IntermediateProductCookingMethodAvgAggregateOutputType | null
    _sum: IntermediateProductCookingMethodSumAggregateOutputType | null
    _min: IntermediateProductCookingMethodMinAggregateOutputType | null
    _max: IntermediateProductCookingMethodMaxAggregateOutputType | null
  }

  export type IntermediateProductCookingMethodAvgAggregateOutputType = {
    productId: number | null
    productCookingMethodId: number | null
  }

  export type IntermediateProductCookingMethodSumAggregateOutputType = {
    productId: number | null
    productCookingMethodId: number | null
  }

  export type IntermediateProductCookingMethodMinAggregateOutputType = {
    productId: number | null
    productCookingMethodId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateProductCookingMethodMaxAggregateOutputType = {
    productId: number | null
    productCookingMethodId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateProductCookingMethodCountAggregateOutputType = {
    productId: number
    productCookingMethodId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateProductCookingMethodAvgAggregateInputType = {
    productId?: true
    productCookingMethodId?: true
  }

  export type IntermediateProductCookingMethodSumAggregateInputType = {
    productId?: true
    productCookingMethodId?: true
  }

  export type IntermediateProductCookingMethodMinAggregateInputType = {
    productId?: true
    productCookingMethodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateProductCookingMethodMaxAggregateInputType = {
    productId?: true
    productCookingMethodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateProductCookingMethodCountAggregateInputType = {
    productId?: true
    productCookingMethodId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateProductCookingMethodAggregateArgs = {
    /**
     * Filter which IntermediateProductCookingMethod to aggregate.
     * 
    **/
    where?: IntermediateProductCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateProductCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductCookingMethods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateProductCookingMethods
    **/
    _count?: true | IntermediateProductCookingMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateProductCookingMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateProductCookingMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateProductCookingMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateProductCookingMethodMaxAggregateInputType
  }

  export type GetIntermediateProductCookingMethodAggregateType<T extends IntermediateProductCookingMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateProductCookingMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateProductCookingMethod[P]>
      : GetScalarType<T[P], AggregateIntermediateProductCookingMethod[P]>
  }




  export type IntermediateProductCookingMethodGroupByArgs = {
    where?: IntermediateProductCookingMethodWhereInput
    orderBy?: Enumerable<IntermediateProductCookingMethodOrderByWithAggregationInput>
    by: Array<IntermediateProductCookingMethodScalarFieldEnum>
    having?: IntermediateProductCookingMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateProductCookingMethodCountAggregateInputType | true
    _avg?: IntermediateProductCookingMethodAvgAggregateInputType
    _sum?: IntermediateProductCookingMethodSumAggregateInputType
    _min?: IntermediateProductCookingMethodMinAggregateInputType
    _max?: IntermediateProductCookingMethodMaxAggregateInputType
  }


  export type IntermediateProductCookingMethodGroupByOutputType = {
    productId: number
    productCookingMethodId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateProductCookingMethodCountAggregateOutputType | null
    _avg: IntermediateProductCookingMethodAvgAggregateOutputType | null
    _sum: IntermediateProductCookingMethodSumAggregateOutputType | null
    _min: IntermediateProductCookingMethodMinAggregateOutputType | null
    _max: IntermediateProductCookingMethodMaxAggregateOutputType | null
  }

  type GetIntermediateProductCookingMethodGroupByPayload<T extends IntermediateProductCookingMethodGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateProductCookingMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateProductCookingMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateProductCookingMethodGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateProductCookingMethodGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateProductCookingMethodSelect = {
    product?: boolean | ProductArgs
    productId?: boolean
    productCookingMethod?: boolean | ProductCookingMethodArgs
    productCookingMethodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateProductCookingMethodInclude = {
    product?: boolean | ProductArgs
    productCookingMethod?: boolean | ProductCookingMethodArgs
  }

  export type IntermediateProductCookingMethodGetPayload<
    S extends boolean | null | undefined | IntermediateProductCookingMethodArgs,
    U = keyof S
      > = S extends true
        ? IntermediateProductCookingMethod
    : S extends undefined
    ? never
    : S extends IntermediateProductCookingMethodArgs | IntermediateProductCookingMethodFindManyArgs
    ?'include' extends U
    ? IntermediateProductCookingMethod  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> :
        P extends 'productCookingMethod'
        ? ProductCookingMethodGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateProductCookingMethod ?IntermediateProductCookingMethod [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> :
        P extends 'productCookingMethod'
        ? ProductCookingMethodGetPayload<S['select'][P]> : never
  } 
    : IntermediateProductCookingMethod
  : IntermediateProductCookingMethod


  type IntermediateProductCookingMethodCountArgs = Merge<
    Omit<IntermediateProductCookingMethodFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateProductCookingMethodCountAggregateInputType | true
    }
  >

  export interface IntermediateProductCookingMethodDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateProductCookingMethod that matches the filter.
     * @param {IntermediateProductCookingMethodFindUniqueArgs} args - Arguments to find a IntermediateProductCookingMethod
     * @example
     * // Get one IntermediateProductCookingMethod
     * const intermediateProductCookingMethod = await prisma.intermediateProductCookingMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateProductCookingMethodFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateProductCookingMethodFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateProductCookingMethod'> extends True ? CheckSelect<T, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethod>, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethodGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethod | null >, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethodGetPayload<T> | null >>

    /**
     * Find the first IntermediateProductCookingMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductCookingMethodFindFirstArgs} args - Arguments to find a IntermediateProductCookingMethod
     * @example
     * // Get one IntermediateProductCookingMethod
     * const intermediateProductCookingMethod = await prisma.intermediateProductCookingMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateProductCookingMethodFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateProductCookingMethodFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateProductCookingMethod'> extends True ? CheckSelect<T, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethod>, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethodGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethod | null >, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethodGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateProductCookingMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductCookingMethodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateProductCookingMethods
     * const intermediateProductCookingMethods = await prisma.intermediateProductCookingMethod.findMany()
     * 
     * // Get first 10 IntermediateProductCookingMethods
     * const intermediateProductCookingMethods = await prisma.intermediateProductCookingMethod.findMany({ take: 10 })
     * 
     * // Only select the `productId`
     * const intermediateProductCookingMethodWithProductIdOnly = await prisma.intermediateProductCookingMethod.findMany({ select: { productId: true } })
     * 
    **/
    findMany<T extends IntermediateProductCookingMethodFindManyArgs>(
      args?: SelectSubset<T, IntermediateProductCookingMethodFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateProductCookingMethod>>, PrismaPromise<Array<IntermediateProductCookingMethodGetPayload<T>>>>

    /**
     * Create a IntermediateProductCookingMethod.
     * @param {IntermediateProductCookingMethodCreateArgs} args - Arguments to create a IntermediateProductCookingMethod.
     * @example
     * // Create one IntermediateProductCookingMethod
     * const IntermediateProductCookingMethod = await prisma.intermediateProductCookingMethod.create({
     *   data: {
     *     // ... data to create a IntermediateProductCookingMethod
     *   }
     * })
     * 
    **/
    create<T extends IntermediateProductCookingMethodCreateArgs>(
      args: SelectSubset<T, IntermediateProductCookingMethodCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethod>, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethodGetPayload<T>>>

    /**
     * Create many IntermediateProductCookingMethods.
     *     @param {IntermediateProductCookingMethodCreateManyArgs} args - Arguments to create many IntermediateProductCookingMethods.
     *     @example
     *     // Create many IntermediateProductCookingMethods
     *     const intermediateProductCookingMethod = await prisma.intermediateProductCookingMethod.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateProductCookingMethodCreateManyArgs>(
      args?: SelectSubset<T, IntermediateProductCookingMethodCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateProductCookingMethod.
     * @param {IntermediateProductCookingMethodDeleteArgs} args - Arguments to delete one IntermediateProductCookingMethod.
     * @example
     * // Delete one IntermediateProductCookingMethod
     * const IntermediateProductCookingMethod = await prisma.intermediateProductCookingMethod.delete({
     *   where: {
     *     // ... filter to delete one IntermediateProductCookingMethod
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateProductCookingMethodDeleteArgs>(
      args: SelectSubset<T, IntermediateProductCookingMethodDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethod>, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethodGetPayload<T>>>

    /**
     * Update one IntermediateProductCookingMethod.
     * @param {IntermediateProductCookingMethodUpdateArgs} args - Arguments to update one IntermediateProductCookingMethod.
     * @example
     * // Update one IntermediateProductCookingMethod
     * const intermediateProductCookingMethod = await prisma.intermediateProductCookingMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateProductCookingMethodUpdateArgs>(
      args: SelectSubset<T, IntermediateProductCookingMethodUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethod>, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethodGetPayload<T>>>

    /**
     * Delete zero or more IntermediateProductCookingMethods.
     * @param {IntermediateProductCookingMethodDeleteManyArgs} args - Arguments to filter IntermediateProductCookingMethods to delete.
     * @example
     * // Delete a few IntermediateProductCookingMethods
     * const { count } = await prisma.intermediateProductCookingMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateProductCookingMethodDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateProductCookingMethodDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateProductCookingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductCookingMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateProductCookingMethods
     * const intermediateProductCookingMethod = await prisma.intermediateProductCookingMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateProductCookingMethodUpdateManyArgs>(
      args: SelectSubset<T, IntermediateProductCookingMethodUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateProductCookingMethod.
     * @param {IntermediateProductCookingMethodUpsertArgs} args - Arguments to update or create a IntermediateProductCookingMethod.
     * @example
     * // Update or create a IntermediateProductCookingMethod
     * const intermediateProductCookingMethod = await prisma.intermediateProductCookingMethod.upsert({
     *   create: {
     *     // ... data to create a IntermediateProductCookingMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateProductCookingMethod we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateProductCookingMethodUpsertArgs>(
      args: SelectSubset<T, IntermediateProductCookingMethodUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethod>, Prisma__IntermediateProductCookingMethodClient<IntermediateProductCookingMethodGetPayload<T>>>

    /**
     * Count the number of IntermediateProductCookingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductCookingMethodCountArgs} args - Arguments to filter IntermediateProductCookingMethods to count.
     * @example
     * // Count the number of IntermediateProductCookingMethods
     * const count = await prisma.intermediateProductCookingMethod.count({
     *   where: {
     *     // ... the filter for the IntermediateProductCookingMethods we want to count
     *   }
     * })
    **/
    count<T extends IntermediateProductCookingMethodCountArgs>(
      args?: Subset<T, IntermediateProductCookingMethodCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateProductCookingMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateProductCookingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductCookingMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateProductCookingMethodAggregateArgs>(args: Subset<T, IntermediateProductCookingMethodAggregateArgs>): PrismaPromise<GetIntermediateProductCookingMethodAggregateType<T>>

    /**
     * Group by IntermediateProductCookingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductCookingMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateProductCookingMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateProductCookingMethodGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateProductCookingMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateProductCookingMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateProductCookingMethodGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateProductCookingMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateProductCookingMethodClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    productCookingMethod<T extends ProductCookingMethodArgs = {}>(args?: Subset<T, ProductCookingMethodArgs>): CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod | null >, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateProductCookingMethod findUnique
   */
  export type IntermediateProductCookingMethodFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductCookingMethod
     * 
    **/
    select?: IntermediateProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductCookingMethodInclude | null
    /**
     * Throw an Error if a IntermediateProductCookingMethod can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateProductCookingMethod to fetch.
     * 
    **/
    where: IntermediateProductCookingMethodWhereUniqueInput
  }


  /**
   * IntermediateProductCookingMethod findFirst
   */
  export type IntermediateProductCookingMethodFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductCookingMethod
     * 
    **/
    select?: IntermediateProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductCookingMethodInclude | null
    /**
     * Throw an Error if a IntermediateProductCookingMethod can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateProductCookingMethod to fetch.
     * 
    **/
    where?: IntermediateProductCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateProductCookingMethods.
     * 
    **/
    cursor?: IntermediateProductCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductCookingMethods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateProductCookingMethods.
     * 
    **/
    distinct?: Enumerable<IntermediateProductCookingMethodScalarFieldEnum>
  }


  /**
   * IntermediateProductCookingMethod findMany
   */
  export type IntermediateProductCookingMethodFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductCookingMethod
     * 
    **/
    select?: IntermediateProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductCookingMethodInclude | null
    /**
     * Filter, which IntermediateProductCookingMethods to fetch.
     * 
    **/
    where?: IntermediateProductCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateProductCookingMethods.
     * 
    **/
    cursor?: IntermediateProductCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductCookingMethods.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateProductCookingMethodScalarFieldEnum>
  }


  /**
   * IntermediateProductCookingMethod create
   */
  export type IntermediateProductCookingMethodCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductCookingMethod
     * 
    **/
    select?: IntermediateProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductCookingMethodInclude | null
    /**
     * The data needed to create a IntermediateProductCookingMethod.
     * 
    **/
    data: XOR<IntermediateProductCookingMethodCreateInput, IntermediateProductCookingMethodUncheckedCreateInput>
  }


  /**
   * IntermediateProductCookingMethod createMany
   */
  export type IntermediateProductCookingMethodCreateManyArgs = {
    data: Enumerable<IntermediateProductCookingMethodCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateProductCookingMethod update
   */
  export type IntermediateProductCookingMethodUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductCookingMethod
     * 
    **/
    select?: IntermediateProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductCookingMethodInclude | null
    /**
     * The data needed to update a IntermediateProductCookingMethod.
     * 
    **/
    data: XOR<IntermediateProductCookingMethodUpdateInput, IntermediateProductCookingMethodUncheckedUpdateInput>
    /**
     * Choose, which IntermediateProductCookingMethod to update.
     * 
    **/
    where: IntermediateProductCookingMethodWhereUniqueInput
  }


  /**
   * IntermediateProductCookingMethod updateMany
   */
  export type IntermediateProductCookingMethodUpdateManyArgs = {
    data: XOR<IntermediateProductCookingMethodUpdateManyMutationInput, IntermediateProductCookingMethodUncheckedUpdateManyInput>
    where?: IntermediateProductCookingMethodWhereInput
  }


  /**
   * IntermediateProductCookingMethod upsert
   */
  export type IntermediateProductCookingMethodUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductCookingMethod
     * 
    **/
    select?: IntermediateProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductCookingMethodInclude | null
    /**
     * The filter to search for the IntermediateProductCookingMethod to update in case it exists.
     * 
    **/
    where: IntermediateProductCookingMethodWhereUniqueInput
    /**
     * In case the IntermediateProductCookingMethod found by the `where` argument doesn't exist, create a new IntermediateProductCookingMethod with this data.
     * 
    **/
    create: XOR<IntermediateProductCookingMethodCreateInput, IntermediateProductCookingMethodUncheckedCreateInput>
    /**
     * In case the IntermediateProductCookingMethod was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateProductCookingMethodUpdateInput, IntermediateProductCookingMethodUncheckedUpdateInput>
  }


  /**
   * IntermediateProductCookingMethod delete
   */
  export type IntermediateProductCookingMethodDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductCookingMethod
     * 
    **/
    select?: IntermediateProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductCookingMethodInclude | null
    /**
     * Filter which IntermediateProductCookingMethod to delete.
     * 
    **/
    where: IntermediateProductCookingMethodWhereUniqueInput
  }


  /**
   * IntermediateProductCookingMethod deleteMany
   */
  export type IntermediateProductCookingMethodDeleteManyArgs = {
    where?: IntermediateProductCookingMethodWhereInput
  }


  /**
   * IntermediateProductCookingMethod without action
   */
  export type IntermediateProductCookingMethodArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductCookingMethod
     * 
    **/
    select?: IntermediateProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductCookingMethodInclude | null
  }



  /**
   * Model IntermediateCustomerUnavailableCookingMethod
   */


  export type AggregateIntermediateCustomerUnavailableCookingMethod = {
    _count: IntermediateCustomerUnavailableCookingMethodCountAggregateOutputType | null
    _avg: IntermediateCustomerUnavailableCookingMethodAvgAggregateOutputType | null
    _sum: IntermediateCustomerUnavailableCookingMethodSumAggregateOutputType | null
    _min: IntermediateCustomerUnavailableCookingMethodMinAggregateOutputType | null
    _max: IntermediateCustomerUnavailableCookingMethodMaxAggregateOutputType | null
  }

  export type IntermediateCustomerUnavailableCookingMethodAvgAggregateOutputType = {
    customerId: number | null
    productCookingMethodId: number | null
  }

  export type IntermediateCustomerUnavailableCookingMethodSumAggregateOutputType = {
    customerId: number | null
    productCookingMethodId: number | null
  }

  export type IntermediateCustomerUnavailableCookingMethodMinAggregateOutputType = {
    customerId: number | null
    productCookingMethodId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerUnavailableCookingMethodMaxAggregateOutputType = {
    customerId: number | null
    productCookingMethodId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerUnavailableCookingMethodCountAggregateOutputType = {
    customerId: number
    productCookingMethodId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateCustomerUnavailableCookingMethodAvgAggregateInputType = {
    customerId?: true
    productCookingMethodId?: true
  }

  export type IntermediateCustomerUnavailableCookingMethodSumAggregateInputType = {
    customerId?: true
    productCookingMethodId?: true
  }

  export type IntermediateCustomerUnavailableCookingMethodMinAggregateInputType = {
    customerId?: true
    productCookingMethodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerUnavailableCookingMethodMaxAggregateInputType = {
    customerId?: true
    productCookingMethodId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerUnavailableCookingMethodCountAggregateInputType = {
    customerId?: true
    productCookingMethodId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateCustomerUnavailableCookingMethodAggregateArgs = {
    /**
     * Filter which IntermediateCustomerUnavailableCookingMethod to aggregate.
     * 
    **/
    where?: IntermediateCustomerUnavailableCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerUnavailableCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerUnavailableCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerUnavailableCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerUnavailableCookingMethods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateCustomerUnavailableCookingMethods
    **/
    _count?: true | IntermediateCustomerUnavailableCookingMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateCustomerUnavailableCookingMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateCustomerUnavailableCookingMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateCustomerUnavailableCookingMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateCustomerUnavailableCookingMethodMaxAggregateInputType
  }

  export type GetIntermediateCustomerUnavailableCookingMethodAggregateType<T extends IntermediateCustomerUnavailableCookingMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateCustomerUnavailableCookingMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateCustomerUnavailableCookingMethod[P]>
      : GetScalarType<T[P], AggregateIntermediateCustomerUnavailableCookingMethod[P]>
  }




  export type IntermediateCustomerUnavailableCookingMethodGroupByArgs = {
    where?: IntermediateCustomerUnavailableCookingMethodWhereInput
    orderBy?: Enumerable<IntermediateCustomerUnavailableCookingMethodOrderByWithAggregationInput>
    by: Array<IntermediateCustomerUnavailableCookingMethodScalarFieldEnum>
    having?: IntermediateCustomerUnavailableCookingMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateCustomerUnavailableCookingMethodCountAggregateInputType | true
    _avg?: IntermediateCustomerUnavailableCookingMethodAvgAggregateInputType
    _sum?: IntermediateCustomerUnavailableCookingMethodSumAggregateInputType
    _min?: IntermediateCustomerUnavailableCookingMethodMinAggregateInputType
    _max?: IntermediateCustomerUnavailableCookingMethodMaxAggregateInputType
  }


  export type IntermediateCustomerUnavailableCookingMethodGroupByOutputType = {
    customerId: number
    productCookingMethodId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateCustomerUnavailableCookingMethodCountAggregateOutputType | null
    _avg: IntermediateCustomerUnavailableCookingMethodAvgAggregateOutputType | null
    _sum: IntermediateCustomerUnavailableCookingMethodSumAggregateOutputType | null
    _min: IntermediateCustomerUnavailableCookingMethodMinAggregateOutputType | null
    _max: IntermediateCustomerUnavailableCookingMethodMaxAggregateOutputType | null
  }

  type GetIntermediateCustomerUnavailableCookingMethodGroupByPayload<T extends IntermediateCustomerUnavailableCookingMethodGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateCustomerUnavailableCookingMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateCustomerUnavailableCookingMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateCustomerUnavailableCookingMethodGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateCustomerUnavailableCookingMethodGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateCustomerUnavailableCookingMethodSelect = {
    customer?: boolean | CustomersArgs
    customerId?: boolean
    productCookingMethod?: boolean | ProductCookingMethodArgs
    productCookingMethodId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateCustomerUnavailableCookingMethodInclude = {
    customer?: boolean | CustomersArgs
    productCookingMethod?: boolean | ProductCookingMethodArgs
  }

  export type IntermediateCustomerUnavailableCookingMethodGetPayload<
    S extends boolean | null | undefined | IntermediateCustomerUnavailableCookingMethodArgs,
    U = keyof S
      > = S extends true
        ? IntermediateCustomerUnavailableCookingMethod
    : S extends undefined
    ? never
    : S extends IntermediateCustomerUnavailableCookingMethodArgs | IntermediateCustomerUnavailableCookingMethodFindManyArgs
    ?'include' extends U
    ? IntermediateCustomerUnavailableCookingMethod  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> :
        P extends 'productCookingMethod'
        ? ProductCookingMethodGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateCustomerUnavailableCookingMethod ?IntermediateCustomerUnavailableCookingMethod [P]
  : 
          P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> :
        P extends 'productCookingMethod'
        ? ProductCookingMethodGetPayload<S['select'][P]> : never
  } 
    : IntermediateCustomerUnavailableCookingMethod
  : IntermediateCustomerUnavailableCookingMethod


  type IntermediateCustomerUnavailableCookingMethodCountArgs = Merge<
    Omit<IntermediateCustomerUnavailableCookingMethodFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateCustomerUnavailableCookingMethodCountAggregateInputType | true
    }
  >

  export interface IntermediateCustomerUnavailableCookingMethodDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateCustomerUnavailableCookingMethod that matches the filter.
     * @param {IntermediateCustomerUnavailableCookingMethodFindUniqueArgs} args - Arguments to find a IntermediateCustomerUnavailableCookingMethod
     * @example
     * // Get one IntermediateCustomerUnavailableCookingMethod
     * const intermediateCustomerUnavailableCookingMethod = await prisma.intermediateCustomerUnavailableCookingMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateCustomerUnavailableCookingMethodFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateCustomerUnavailableCookingMethod'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethod>, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethod | null >, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethodGetPayload<T> | null >>

    /**
     * Find the first IntermediateCustomerUnavailableCookingMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerUnavailableCookingMethodFindFirstArgs} args - Arguments to find a IntermediateCustomerUnavailableCookingMethod
     * @example
     * // Get one IntermediateCustomerUnavailableCookingMethod
     * const intermediateCustomerUnavailableCookingMethod = await prisma.intermediateCustomerUnavailableCookingMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateCustomerUnavailableCookingMethodFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateCustomerUnavailableCookingMethod'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethod>, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethod | null >, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethodGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateCustomerUnavailableCookingMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerUnavailableCookingMethodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateCustomerUnavailableCookingMethods
     * const intermediateCustomerUnavailableCookingMethods = await prisma.intermediateCustomerUnavailableCookingMethod.findMany()
     * 
     * // Get first 10 IntermediateCustomerUnavailableCookingMethods
     * const intermediateCustomerUnavailableCookingMethods = await prisma.intermediateCustomerUnavailableCookingMethod.findMany({ take: 10 })
     * 
     * // Only select the `customerId`
     * const intermediateCustomerUnavailableCookingMethodWithCustomerIdOnly = await prisma.intermediateCustomerUnavailableCookingMethod.findMany({ select: { customerId: true } })
     * 
    **/
    findMany<T extends IntermediateCustomerUnavailableCookingMethodFindManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerUnavailableCookingMethod>>, PrismaPromise<Array<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>>>

    /**
     * Create a IntermediateCustomerUnavailableCookingMethod.
     * @param {IntermediateCustomerUnavailableCookingMethodCreateArgs} args - Arguments to create a IntermediateCustomerUnavailableCookingMethod.
     * @example
     * // Create one IntermediateCustomerUnavailableCookingMethod
     * const IntermediateCustomerUnavailableCookingMethod = await prisma.intermediateCustomerUnavailableCookingMethod.create({
     *   data: {
     *     // ... data to create a IntermediateCustomerUnavailableCookingMethod
     *   }
     * })
     * 
    **/
    create<T extends IntermediateCustomerUnavailableCookingMethodCreateArgs>(
      args: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethod>, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>>

    /**
     * Create many IntermediateCustomerUnavailableCookingMethods.
     *     @param {IntermediateCustomerUnavailableCookingMethodCreateManyArgs} args - Arguments to create many IntermediateCustomerUnavailableCookingMethods.
     *     @example
     *     // Create many IntermediateCustomerUnavailableCookingMethods
     *     const intermediateCustomerUnavailableCookingMethod = await prisma.intermediateCustomerUnavailableCookingMethod.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateCustomerUnavailableCookingMethodCreateManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateCustomerUnavailableCookingMethod.
     * @param {IntermediateCustomerUnavailableCookingMethodDeleteArgs} args - Arguments to delete one IntermediateCustomerUnavailableCookingMethod.
     * @example
     * // Delete one IntermediateCustomerUnavailableCookingMethod
     * const IntermediateCustomerUnavailableCookingMethod = await prisma.intermediateCustomerUnavailableCookingMethod.delete({
     *   where: {
     *     // ... filter to delete one IntermediateCustomerUnavailableCookingMethod
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateCustomerUnavailableCookingMethodDeleteArgs>(
      args: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethod>, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>>

    /**
     * Update one IntermediateCustomerUnavailableCookingMethod.
     * @param {IntermediateCustomerUnavailableCookingMethodUpdateArgs} args - Arguments to update one IntermediateCustomerUnavailableCookingMethod.
     * @example
     * // Update one IntermediateCustomerUnavailableCookingMethod
     * const intermediateCustomerUnavailableCookingMethod = await prisma.intermediateCustomerUnavailableCookingMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateCustomerUnavailableCookingMethodUpdateArgs>(
      args: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethod>, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>>

    /**
     * Delete zero or more IntermediateCustomerUnavailableCookingMethods.
     * @param {IntermediateCustomerUnavailableCookingMethodDeleteManyArgs} args - Arguments to filter IntermediateCustomerUnavailableCookingMethods to delete.
     * @example
     * // Delete a few IntermediateCustomerUnavailableCookingMethods
     * const { count } = await prisma.intermediateCustomerUnavailableCookingMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateCustomerUnavailableCookingMethodDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateCustomerUnavailableCookingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerUnavailableCookingMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateCustomerUnavailableCookingMethods
     * const intermediateCustomerUnavailableCookingMethod = await prisma.intermediateCustomerUnavailableCookingMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateCustomerUnavailableCookingMethodUpdateManyArgs>(
      args: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateCustomerUnavailableCookingMethod.
     * @param {IntermediateCustomerUnavailableCookingMethodUpsertArgs} args - Arguments to update or create a IntermediateCustomerUnavailableCookingMethod.
     * @example
     * // Update or create a IntermediateCustomerUnavailableCookingMethod
     * const intermediateCustomerUnavailableCookingMethod = await prisma.intermediateCustomerUnavailableCookingMethod.upsert({
     *   create: {
     *     // ... data to create a IntermediateCustomerUnavailableCookingMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateCustomerUnavailableCookingMethod we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateCustomerUnavailableCookingMethodUpsertArgs>(
      args: SelectSubset<T, IntermediateCustomerUnavailableCookingMethodUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethod>, Prisma__IntermediateCustomerUnavailableCookingMethodClient<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>>

    /**
     * Count the number of IntermediateCustomerUnavailableCookingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerUnavailableCookingMethodCountArgs} args - Arguments to filter IntermediateCustomerUnavailableCookingMethods to count.
     * @example
     * // Count the number of IntermediateCustomerUnavailableCookingMethods
     * const count = await prisma.intermediateCustomerUnavailableCookingMethod.count({
     *   where: {
     *     // ... the filter for the IntermediateCustomerUnavailableCookingMethods we want to count
     *   }
     * })
    **/
    count<T extends IntermediateCustomerUnavailableCookingMethodCountArgs>(
      args?: Subset<T, IntermediateCustomerUnavailableCookingMethodCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateCustomerUnavailableCookingMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateCustomerUnavailableCookingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerUnavailableCookingMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateCustomerUnavailableCookingMethodAggregateArgs>(args: Subset<T, IntermediateCustomerUnavailableCookingMethodAggregateArgs>): PrismaPromise<GetIntermediateCustomerUnavailableCookingMethodAggregateType<T>>

    /**
     * Group by IntermediateCustomerUnavailableCookingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerUnavailableCookingMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateCustomerUnavailableCookingMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateCustomerUnavailableCookingMethodGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateCustomerUnavailableCookingMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateCustomerUnavailableCookingMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateCustomerUnavailableCookingMethodGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateCustomerUnavailableCookingMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateCustomerUnavailableCookingMethodClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    productCookingMethod<T extends ProductCookingMethodArgs = {}>(args?: Subset<T, ProductCookingMethodArgs>): CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod | null >, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateCustomerUnavailableCookingMethod findUnique
   */
  export type IntermediateCustomerUnavailableCookingMethodFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerUnavailableCookingMethod
     * 
    **/
    select?: IntermediateCustomerUnavailableCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerUnavailableCookingMethodInclude | null
    /**
     * Throw an Error if a IntermediateCustomerUnavailableCookingMethod can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerUnavailableCookingMethod to fetch.
     * 
    **/
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod findFirst
   */
  export type IntermediateCustomerUnavailableCookingMethodFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerUnavailableCookingMethod
     * 
    **/
    select?: IntermediateCustomerUnavailableCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerUnavailableCookingMethodInclude | null
    /**
     * Throw an Error if a IntermediateCustomerUnavailableCookingMethod can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerUnavailableCookingMethod to fetch.
     * 
    **/
    where?: IntermediateCustomerUnavailableCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerUnavailableCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerUnavailableCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateCustomerUnavailableCookingMethods.
     * 
    **/
    cursor?: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerUnavailableCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerUnavailableCookingMethods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateCustomerUnavailableCookingMethods.
     * 
    **/
    distinct?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarFieldEnum>
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod findMany
   */
  export type IntermediateCustomerUnavailableCookingMethodFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerUnavailableCookingMethod
     * 
    **/
    select?: IntermediateCustomerUnavailableCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerUnavailableCookingMethodInclude | null
    /**
     * Filter, which IntermediateCustomerUnavailableCookingMethods to fetch.
     * 
    **/
    where?: IntermediateCustomerUnavailableCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerUnavailableCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerUnavailableCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateCustomerUnavailableCookingMethods.
     * 
    **/
    cursor?: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerUnavailableCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerUnavailableCookingMethods.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarFieldEnum>
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod create
   */
  export type IntermediateCustomerUnavailableCookingMethodCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerUnavailableCookingMethod
     * 
    **/
    select?: IntermediateCustomerUnavailableCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerUnavailableCookingMethodInclude | null
    /**
     * The data needed to create a IntermediateCustomerUnavailableCookingMethod.
     * 
    **/
    data: XOR<IntermediateCustomerUnavailableCookingMethodCreateInput, IntermediateCustomerUnavailableCookingMethodUncheckedCreateInput>
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod createMany
   */
  export type IntermediateCustomerUnavailableCookingMethodCreateManyArgs = {
    data: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod update
   */
  export type IntermediateCustomerUnavailableCookingMethodUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerUnavailableCookingMethod
     * 
    **/
    select?: IntermediateCustomerUnavailableCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerUnavailableCookingMethodInclude | null
    /**
     * The data needed to update a IntermediateCustomerUnavailableCookingMethod.
     * 
    **/
    data: XOR<IntermediateCustomerUnavailableCookingMethodUpdateInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateInput>
    /**
     * Choose, which IntermediateCustomerUnavailableCookingMethod to update.
     * 
    **/
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod updateMany
   */
  export type IntermediateCustomerUnavailableCookingMethodUpdateManyArgs = {
    data: XOR<IntermediateCustomerUnavailableCookingMethodUpdateManyMutationInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyInput>
    where?: IntermediateCustomerUnavailableCookingMethodWhereInput
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod upsert
   */
  export type IntermediateCustomerUnavailableCookingMethodUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerUnavailableCookingMethod
     * 
    **/
    select?: IntermediateCustomerUnavailableCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerUnavailableCookingMethodInclude | null
    /**
     * The filter to search for the IntermediateCustomerUnavailableCookingMethod to update in case it exists.
     * 
    **/
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    /**
     * In case the IntermediateCustomerUnavailableCookingMethod found by the `where` argument doesn't exist, create a new IntermediateCustomerUnavailableCookingMethod with this data.
     * 
    **/
    create: XOR<IntermediateCustomerUnavailableCookingMethodCreateInput, IntermediateCustomerUnavailableCookingMethodUncheckedCreateInput>
    /**
     * In case the IntermediateCustomerUnavailableCookingMethod was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateCustomerUnavailableCookingMethodUpdateInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateInput>
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod delete
   */
  export type IntermediateCustomerUnavailableCookingMethodDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerUnavailableCookingMethod
     * 
    **/
    select?: IntermediateCustomerUnavailableCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerUnavailableCookingMethodInclude | null
    /**
     * Filter which IntermediateCustomerUnavailableCookingMethod to delete.
     * 
    **/
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod deleteMany
   */
  export type IntermediateCustomerUnavailableCookingMethodDeleteManyArgs = {
    where?: IntermediateCustomerUnavailableCookingMethodWhereInput
  }


  /**
   * IntermediateCustomerUnavailableCookingMethod without action
   */
  export type IntermediateCustomerUnavailableCookingMethodArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerUnavailableCookingMethod
     * 
    **/
    select?: IntermediateCustomerUnavailableCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerUnavailableCookingMethodInclude | null
  }



  /**
   * Model ProductCookingMethod
   */


  export type AggregateProductCookingMethod = {
    _count: ProductCookingMethodCountAggregateOutputType | null
    _avg: ProductCookingMethodAvgAggregateOutputType | null
    _sum: ProductCookingMethodSumAggregateOutputType | null
    _min: ProductCookingMethodMinAggregateOutputType | null
    _max: ProductCookingMethodMaxAggregateOutputType | null
  }

  export type ProductCookingMethodAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductCookingMethodSumAggregateOutputType = {
    id: number | null
  }

  export type ProductCookingMethodMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCookingMethodMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCookingMethodCountAggregateOutputType = {
    id: number
    label: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCookingMethodAvgAggregateInputType = {
    id?: true
  }

  export type ProductCookingMethodSumAggregateInputType = {
    id?: true
  }

  export type ProductCookingMethodMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCookingMethodMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCookingMethodCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCookingMethodAggregateArgs = {
    /**
     * Filter which ProductCookingMethod to aggregate.
     * 
    **/
    where?: ProductCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCookingMethods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCookingMethods
    **/
    _count?: true | ProductCookingMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCookingMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCookingMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCookingMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCookingMethodMaxAggregateInputType
  }

  export type GetProductCookingMethodAggregateType<T extends ProductCookingMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCookingMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCookingMethod[P]>
      : GetScalarType<T[P], AggregateProductCookingMethod[P]>
  }




  export type ProductCookingMethodGroupByArgs = {
    where?: ProductCookingMethodWhereInput
    orderBy?: Enumerable<ProductCookingMethodOrderByWithAggregationInput>
    by: Array<ProductCookingMethodScalarFieldEnum>
    having?: ProductCookingMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCookingMethodCountAggregateInputType | true
    _avg?: ProductCookingMethodAvgAggregateInputType
    _sum?: ProductCookingMethodSumAggregateInputType
    _min?: ProductCookingMethodMinAggregateInputType
    _max?: ProductCookingMethodMaxAggregateInputType
  }


  export type ProductCookingMethodGroupByOutputType = {
    id: number
    label: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ProductCookingMethodCountAggregateOutputType | null
    _avg: ProductCookingMethodAvgAggregateOutputType | null
    _sum: ProductCookingMethodSumAggregateOutputType | null
    _min: ProductCookingMethodMinAggregateOutputType | null
    _max: ProductCookingMethodMaxAggregateOutputType | null
  }

  type GetProductCookingMethodGroupByPayload<T extends ProductCookingMethodGroupByArgs> = Promise<
    Array<
      PickArray<ProductCookingMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCookingMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCookingMethodGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCookingMethodGroupByOutputType[P]>
        }
      >
    >


  export type ProductCookingMethodSelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    intermediateProductCookingMethods?: boolean | IntermediateProductCookingMethodFindManyArgs
    intermediateCustomerUnavailableCookingMethods?: boolean | IntermediateCustomerUnavailableCookingMethodFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductCookingMethodCountOutputTypeArgs
  }

  export type ProductCookingMethodInclude = {
    intermediateProductCookingMethods?: boolean | IntermediateProductCookingMethodFindManyArgs
    intermediateCustomerUnavailableCookingMethods?: boolean | IntermediateCustomerUnavailableCookingMethodFindManyArgs
    _count?: boolean | ProductCookingMethodCountOutputTypeArgs
  }

  export type ProductCookingMethodGetPayload<
    S extends boolean | null | undefined | ProductCookingMethodArgs,
    U = keyof S
      > = S extends true
        ? ProductCookingMethod
    : S extends undefined
    ? never
    : S extends ProductCookingMethodArgs | ProductCookingMethodFindManyArgs
    ?'include' extends U
    ? ProductCookingMethod  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateProductCookingMethods'
        ? Array < IntermediateProductCookingMethodGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerUnavailableCookingMethods'
        ? Array < IntermediateCustomerUnavailableCookingMethodGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductCookingMethodCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductCookingMethod ?ProductCookingMethod [P]
  : 
          P extends 'intermediateProductCookingMethods'
        ? Array < IntermediateProductCookingMethodGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerUnavailableCookingMethods'
        ? Array < IntermediateCustomerUnavailableCookingMethodGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductCookingMethodCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductCookingMethod
  : ProductCookingMethod


  type ProductCookingMethodCountArgs = Merge<
    Omit<ProductCookingMethodFindManyArgs, 'select' | 'include'> & {
      select?: ProductCookingMethodCountAggregateInputType | true
    }
  >

  export interface ProductCookingMethodDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductCookingMethod that matches the filter.
     * @param {ProductCookingMethodFindUniqueArgs} args - Arguments to find a ProductCookingMethod
     * @example
     * // Get one ProductCookingMethod
     * const productCookingMethod = await prisma.productCookingMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductCookingMethodFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductCookingMethodFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductCookingMethod'> extends True ? CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod>, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T>>> : CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod | null >, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T> | null >>

    /**
     * Find the first ProductCookingMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCookingMethodFindFirstArgs} args - Arguments to find a ProductCookingMethod
     * @example
     * // Get one ProductCookingMethod
     * const productCookingMethod = await prisma.productCookingMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductCookingMethodFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductCookingMethodFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductCookingMethod'> extends True ? CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod>, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T>>> : CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod | null >, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T> | null >>

    /**
     * Find zero or more ProductCookingMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCookingMethodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCookingMethods
     * const productCookingMethods = await prisma.productCookingMethod.findMany()
     * 
     * // Get first 10 ProductCookingMethods
     * const productCookingMethods = await prisma.productCookingMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCookingMethodWithIdOnly = await prisma.productCookingMethod.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductCookingMethodFindManyArgs>(
      args?: SelectSubset<T, ProductCookingMethodFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductCookingMethod>>, PrismaPromise<Array<ProductCookingMethodGetPayload<T>>>>

    /**
     * Create a ProductCookingMethod.
     * @param {ProductCookingMethodCreateArgs} args - Arguments to create a ProductCookingMethod.
     * @example
     * // Create one ProductCookingMethod
     * const ProductCookingMethod = await prisma.productCookingMethod.create({
     *   data: {
     *     // ... data to create a ProductCookingMethod
     *   }
     * })
     * 
    **/
    create<T extends ProductCookingMethodCreateArgs>(
      args: SelectSubset<T, ProductCookingMethodCreateArgs>
    ): CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod>, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T>>>

    /**
     * Create many ProductCookingMethods.
     *     @param {ProductCookingMethodCreateManyArgs} args - Arguments to create many ProductCookingMethods.
     *     @example
     *     // Create many ProductCookingMethods
     *     const productCookingMethod = await prisma.productCookingMethod.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCookingMethodCreateManyArgs>(
      args?: SelectSubset<T, ProductCookingMethodCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductCookingMethod.
     * @param {ProductCookingMethodDeleteArgs} args - Arguments to delete one ProductCookingMethod.
     * @example
     * // Delete one ProductCookingMethod
     * const ProductCookingMethod = await prisma.productCookingMethod.delete({
     *   where: {
     *     // ... filter to delete one ProductCookingMethod
     *   }
     * })
     * 
    **/
    delete<T extends ProductCookingMethodDeleteArgs>(
      args: SelectSubset<T, ProductCookingMethodDeleteArgs>
    ): CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod>, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T>>>

    /**
     * Update one ProductCookingMethod.
     * @param {ProductCookingMethodUpdateArgs} args - Arguments to update one ProductCookingMethod.
     * @example
     * // Update one ProductCookingMethod
     * const productCookingMethod = await prisma.productCookingMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductCookingMethodUpdateArgs>(
      args: SelectSubset<T, ProductCookingMethodUpdateArgs>
    ): CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod>, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T>>>

    /**
     * Delete zero or more ProductCookingMethods.
     * @param {ProductCookingMethodDeleteManyArgs} args - Arguments to filter ProductCookingMethods to delete.
     * @example
     * // Delete a few ProductCookingMethods
     * const { count } = await prisma.productCookingMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductCookingMethodDeleteManyArgs>(
      args?: SelectSubset<T, ProductCookingMethodDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCookingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCookingMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCookingMethods
     * const productCookingMethod = await prisma.productCookingMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductCookingMethodUpdateManyArgs>(
      args: SelectSubset<T, ProductCookingMethodUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCookingMethod.
     * @param {ProductCookingMethodUpsertArgs} args - Arguments to update or create a ProductCookingMethod.
     * @example
     * // Update or create a ProductCookingMethod
     * const productCookingMethod = await prisma.productCookingMethod.upsert({
     *   create: {
     *     // ... data to create a ProductCookingMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCookingMethod we want to update
     *   }
     * })
    **/
    upsert<T extends ProductCookingMethodUpsertArgs>(
      args: SelectSubset<T, ProductCookingMethodUpsertArgs>
    ): CheckSelect<T, Prisma__ProductCookingMethodClient<ProductCookingMethod>, Prisma__ProductCookingMethodClient<ProductCookingMethodGetPayload<T>>>

    /**
     * Count the number of ProductCookingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCookingMethodCountArgs} args - Arguments to filter ProductCookingMethods to count.
     * @example
     * // Count the number of ProductCookingMethods
     * const count = await prisma.productCookingMethod.count({
     *   where: {
     *     // ... the filter for the ProductCookingMethods we want to count
     *   }
     * })
    **/
    count<T extends ProductCookingMethodCountArgs>(
      args?: Subset<T, ProductCookingMethodCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCookingMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCookingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCookingMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCookingMethodAggregateArgs>(args: Subset<T, ProductCookingMethodAggregateArgs>): PrismaPromise<GetProductCookingMethodAggregateType<T>>

    /**
     * Group by ProductCookingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCookingMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCookingMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCookingMethodGroupByArgs['orderBy'] }
        : { orderBy?: ProductCookingMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCookingMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCookingMethodGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCookingMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductCookingMethodClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateProductCookingMethods<T extends IntermediateProductCookingMethodFindManyArgs = {}>(args?: Subset<T, IntermediateProductCookingMethodFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateProductCookingMethod>>, PrismaPromise<Array<IntermediateProductCookingMethodGetPayload<T>>>>;

    intermediateCustomerUnavailableCookingMethods<T extends IntermediateCustomerUnavailableCookingMethodFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerUnavailableCookingMethodFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerUnavailableCookingMethod>>, PrismaPromise<Array<IntermediateCustomerUnavailableCookingMethodGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductCookingMethod findUnique
   */
  export type ProductCookingMethodFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethod
     * 
    **/
    select?: ProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCookingMethodInclude | null
    /**
     * Throw an Error if a ProductCookingMethod can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductCookingMethod to fetch.
     * 
    **/
    where: ProductCookingMethodWhereUniqueInput
  }


  /**
   * ProductCookingMethod findFirst
   */
  export type ProductCookingMethodFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethod
     * 
    **/
    select?: ProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCookingMethodInclude | null
    /**
     * Throw an Error if a ProductCookingMethod can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductCookingMethod to fetch.
     * 
    **/
    where?: ProductCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCookingMethods.
     * 
    **/
    cursor?: ProductCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCookingMethods.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCookingMethods.
     * 
    **/
    distinct?: Enumerable<ProductCookingMethodScalarFieldEnum>
  }


  /**
   * ProductCookingMethod findMany
   */
  export type ProductCookingMethodFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethod
     * 
    **/
    select?: ProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCookingMethodInclude | null
    /**
     * Filter, which ProductCookingMethods to fetch.
     * 
    **/
    where?: ProductCookingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCookingMethods to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCookingMethodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCookingMethods.
     * 
    **/
    cursor?: ProductCookingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCookingMethods from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCookingMethods.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductCookingMethodScalarFieldEnum>
  }


  /**
   * ProductCookingMethod create
   */
  export type ProductCookingMethodCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethod
     * 
    **/
    select?: ProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCookingMethodInclude | null
    /**
     * The data needed to create a ProductCookingMethod.
     * 
    **/
    data: XOR<ProductCookingMethodCreateInput, ProductCookingMethodUncheckedCreateInput>
  }


  /**
   * ProductCookingMethod createMany
   */
  export type ProductCookingMethodCreateManyArgs = {
    data: Enumerable<ProductCookingMethodCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductCookingMethod update
   */
  export type ProductCookingMethodUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethod
     * 
    **/
    select?: ProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCookingMethodInclude | null
    /**
     * The data needed to update a ProductCookingMethod.
     * 
    **/
    data: XOR<ProductCookingMethodUpdateInput, ProductCookingMethodUncheckedUpdateInput>
    /**
     * Choose, which ProductCookingMethod to update.
     * 
    **/
    where: ProductCookingMethodWhereUniqueInput
  }


  /**
   * ProductCookingMethod updateMany
   */
  export type ProductCookingMethodUpdateManyArgs = {
    data: XOR<ProductCookingMethodUpdateManyMutationInput, ProductCookingMethodUncheckedUpdateManyInput>
    where?: ProductCookingMethodWhereInput
  }


  /**
   * ProductCookingMethod upsert
   */
  export type ProductCookingMethodUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethod
     * 
    **/
    select?: ProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCookingMethodInclude | null
    /**
     * The filter to search for the ProductCookingMethod to update in case it exists.
     * 
    **/
    where: ProductCookingMethodWhereUniqueInput
    /**
     * In case the ProductCookingMethod found by the `where` argument doesn't exist, create a new ProductCookingMethod with this data.
     * 
    **/
    create: XOR<ProductCookingMethodCreateInput, ProductCookingMethodUncheckedCreateInput>
    /**
     * In case the ProductCookingMethod was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductCookingMethodUpdateInput, ProductCookingMethodUncheckedUpdateInput>
  }


  /**
   * ProductCookingMethod delete
   */
  export type ProductCookingMethodDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethod
     * 
    **/
    select?: ProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCookingMethodInclude | null
    /**
     * Filter which ProductCookingMethod to delete.
     * 
    **/
    where: ProductCookingMethodWhereUniqueInput
  }


  /**
   * ProductCookingMethod deleteMany
   */
  export type ProductCookingMethodDeleteManyArgs = {
    where?: ProductCookingMethodWhereInput
  }


  /**
   * ProductCookingMethod without action
   */
  export type ProductCookingMethodArgs = {
    /**
     * Select specific fields to fetch from the ProductCookingMethod
     * 
    **/
    select?: ProductCookingMethodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCookingMethodInclude | null
  }



  /**
   * Model ProductFlavor
   */


  export type AggregateProductFlavor = {
    _count: ProductFlavorCountAggregateOutputType | null
    _avg: ProductFlavorAvgAggregateOutputType | null
    _sum: ProductFlavorSumAggregateOutputType | null
    _min: ProductFlavorMinAggregateOutputType | null
    _max: ProductFlavorMaxAggregateOutputType | null
  }

  export type ProductFlavorAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductFlavorSumAggregateOutputType = {
    id: number | null
  }

  export type ProductFlavorMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductFlavorMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductFlavorCountAggregateOutputType = {
    id: number
    label: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductFlavorAvgAggregateInputType = {
    id?: true
  }

  export type ProductFlavorSumAggregateInputType = {
    id?: true
  }

  export type ProductFlavorMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductFlavorMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductFlavorCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductFlavorAggregateArgs = {
    /**
     * Filter which ProductFlavor to aggregate.
     * 
    **/
    where?: ProductFlavorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFlavors to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductFlavorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductFlavorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFlavors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFlavors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductFlavors
    **/
    _count?: true | ProductFlavorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductFlavorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductFlavorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductFlavorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductFlavorMaxAggregateInputType
  }

  export type GetProductFlavorAggregateType<T extends ProductFlavorAggregateArgs> = {
        [P in keyof T & keyof AggregateProductFlavor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductFlavor[P]>
      : GetScalarType<T[P], AggregateProductFlavor[P]>
  }




  export type ProductFlavorGroupByArgs = {
    where?: ProductFlavorWhereInput
    orderBy?: Enumerable<ProductFlavorOrderByWithAggregationInput>
    by: Array<ProductFlavorScalarFieldEnum>
    having?: ProductFlavorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductFlavorCountAggregateInputType | true
    _avg?: ProductFlavorAvgAggregateInputType
    _sum?: ProductFlavorSumAggregateInputType
    _min?: ProductFlavorMinAggregateInputType
    _max?: ProductFlavorMaxAggregateInputType
  }


  export type ProductFlavorGroupByOutputType = {
    id: number
    label: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ProductFlavorCountAggregateOutputType | null
    _avg: ProductFlavorAvgAggregateOutputType | null
    _sum: ProductFlavorSumAggregateOutputType | null
    _min: ProductFlavorMinAggregateOutputType | null
    _max: ProductFlavorMaxAggregateOutputType | null
  }

  type GetProductFlavorGroupByPayload<T extends ProductFlavorGroupByArgs> = Promise<
    Array<
      PickArray<ProductFlavorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductFlavorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductFlavorGroupByOutputType[P]>
            : GetScalarType<T[P], ProductFlavorGroupByOutputType[P]>
        }
      >
    >


  export type ProductFlavorSelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    products?: boolean | ProductFindManyArgs
    intermediateCustomerFlavorDislikes?: boolean | IntermediateCustomerFlavorDislikeFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductFlavorCountOutputTypeArgs
  }

  export type ProductFlavorInclude = {
    products?: boolean | ProductFindManyArgs
    intermediateCustomerFlavorDislikes?: boolean | IntermediateCustomerFlavorDislikeFindManyArgs
    _count?: boolean | ProductFlavorCountOutputTypeArgs
  }

  export type ProductFlavorGetPayload<
    S extends boolean | null | undefined | ProductFlavorArgs,
    U = keyof S
      > = S extends true
        ? ProductFlavor
    : S extends undefined
    ? never
    : S extends ProductFlavorArgs | ProductFlavorFindManyArgs
    ?'include' extends U
    ? ProductFlavor  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerFlavorDislikes'
        ? Array < IntermediateCustomerFlavorDislikeGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductFlavorCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductFlavor ?ProductFlavor [P]
  : 
          P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerFlavorDislikes'
        ? Array < IntermediateCustomerFlavorDislikeGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductFlavorCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductFlavor
  : ProductFlavor


  type ProductFlavorCountArgs = Merge<
    Omit<ProductFlavorFindManyArgs, 'select' | 'include'> & {
      select?: ProductFlavorCountAggregateInputType | true
    }
  >

  export interface ProductFlavorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductFlavor that matches the filter.
     * @param {ProductFlavorFindUniqueArgs} args - Arguments to find a ProductFlavor
     * @example
     * // Get one ProductFlavor
     * const productFlavor = await prisma.productFlavor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFlavorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFlavorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductFlavor'> extends True ? CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor>, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T>>> : CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor | null >, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T> | null >>

    /**
     * Find the first ProductFlavor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorFindFirstArgs} args - Arguments to find a ProductFlavor
     * @example
     * // Get one ProductFlavor
     * const productFlavor = await prisma.productFlavor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFlavorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFlavorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductFlavor'> extends True ? CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor>, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T>>> : CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor | null >, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T> | null >>

    /**
     * Find zero or more ProductFlavors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductFlavors
     * const productFlavors = await prisma.productFlavor.findMany()
     * 
     * // Get first 10 ProductFlavors
     * const productFlavors = await prisma.productFlavor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productFlavorWithIdOnly = await prisma.productFlavor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFlavorFindManyArgs>(
      args?: SelectSubset<T, ProductFlavorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductFlavor>>, PrismaPromise<Array<ProductFlavorGetPayload<T>>>>

    /**
     * Create a ProductFlavor.
     * @param {ProductFlavorCreateArgs} args - Arguments to create a ProductFlavor.
     * @example
     * // Create one ProductFlavor
     * const ProductFlavor = await prisma.productFlavor.create({
     *   data: {
     *     // ... data to create a ProductFlavor
     *   }
     * })
     * 
    **/
    create<T extends ProductFlavorCreateArgs>(
      args: SelectSubset<T, ProductFlavorCreateArgs>
    ): CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor>, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T>>>

    /**
     * Create many ProductFlavors.
     *     @param {ProductFlavorCreateManyArgs} args - Arguments to create many ProductFlavors.
     *     @example
     *     // Create many ProductFlavors
     *     const productFlavor = await prisma.productFlavor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductFlavorCreateManyArgs>(
      args?: SelectSubset<T, ProductFlavorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductFlavor.
     * @param {ProductFlavorDeleteArgs} args - Arguments to delete one ProductFlavor.
     * @example
     * // Delete one ProductFlavor
     * const ProductFlavor = await prisma.productFlavor.delete({
     *   where: {
     *     // ... filter to delete one ProductFlavor
     *   }
     * })
     * 
    **/
    delete<T extends ProductFlavorDeleteArgs>(
      args: SelectSubset<T, ProductFlavorDeleteArgs>
    ): CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor>, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T>>>

    /**
     * Update one ProductFlavor.
     * @param {ProductFlavorUpdateArgs} args - Arguments to update one ProductFlavor.
     * @example
     * // Update one ProductFlavor
     * const productFlavor = await prisma.productFlavor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductFlavorUpdateArgs>(
      args: SelectSubset<T, ProductFlavorUpdateArgs>
    ): CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor>, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T>>>

    /**
     * Delete zero or more ProductFlavors.
     * @param {ProductFlavorDeleteManyArgs} args - Arguments to filter ProductFlavors to delete.
     * @example
     * // Delete a few ProductFlavors
     * const { count } = await prisma.productFlavor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductFlavorDeleteManyArgs>(
      args?: SelectSubset<T, ProductFlavorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductFlavors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductFlavors
     * const productFlavor = await prisma.productFlavor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductFlavorUpdateManyArgs>(
      args: SelectSubset<T, ProductFlavorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductFlavor.
     * @param {ProductFlavorUpsertArgs} args - Arguments to update or create a ProductFlavor.
     * @example
     * // Update or create a ProductFlavor
     * const productFlavor = await prisma.productFlavor.upsert({
     *   create: {
     *     // ... data to create a ProductFlavor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductFlavor we want to update
     *   }
     * })
    **/
    upsert<T extends ProductFlavorUpsertArgs>(
      args: SelectSubset<T, ProductFlavorUpsertArgs>
    ): CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor>, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T>>>

    /**
     * Count the number of ProductFlavors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorCountArgs} args - Arguments to filter ProductFlavors to count.
     * @example
     * // Count the number of ProductFlavors
     * const count = await prisma.productFlavor.count({
     *   where: {
     *     // ... the filter for the ProductFlavors we want to count
     *   }
     * })
    **/
    count<T extends ProductFlavorCountArgs>(
      args?: Subset<T, ProductFlavorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductFlavorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductFlavor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductFlavorAggregateArgs>(args: Subset<T, ProductFlavorAggregateArgs>): PrismaPromise<GetProductFlavorAggregateType<T>>

    /**
     * Group by ProductFlavor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductFlavorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductFlavorGroupByArgs['orderBy'] }
        : { orderBy?: ProductFlavorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductFlavorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductFlavorGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductFlavor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductFlavorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    intermediateCustomerFlavorDislikes<T extends IntermediateCustomerFlavorDislikeFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerFlavorDislikeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerFlavorDislike>>, PrismaPromise<Array<IntermediateCustomerFlavorDislikeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductFlavor findUnique
   */
  export type ProductFlavorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     * 
    **/
    select?: ProductFlavorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFlavorInclude | null
    /**
     * Throw an Error if a ProductFlavor can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductFlavor to fetch.
     * 
    **/
    where: ProductFlavorWhereUniqueInput
  }


  /**
   * ProductFlavor findFirst
   */
  export type ProductFlavorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     * 
    **/
    select?: ProductFlavorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFlavorInclude | null
    /**
     * Throw an Error if a ProductFlavor can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductFlavor to fetch.
     * 
    **/
    where?: ProductFlavorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFlavors to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductFlavorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFlavors.
     * 
    **/
    cursor?: ProductFlavorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFlavors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFlavors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFlavors.
     * 
    **/
    distinct?: Enumerable<ProductFlavorScalarFieldEnum>
  }


  /**
   * ProductFlavor findMany
   */
  export type ProductFlavorFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     * 
    **/
    select?: ProductFlavorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFlavorInclude | null
    /**
     * Filter, which ProductFlavors to fetch.
     * 
    **/
    where?: ProductFlavorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFlavors to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductFlavorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductFlavors.
     * 
    **/
    cursor?: ProductFlavorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFlavors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFlavors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductFlavorScalarFieldEnum>
  }


  /**
   * ProductFlavor create
   */
  export type ProductFlavorCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     * 
    **/
    select?: ProductFlavorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFlavorInclude | null
    /**
     * The data needed to create a ProductFlavor.
     * 
    **/
    data: XOR<ProductFlavorCreateInput, ProductFlavorUncheckedCreateInput>
  }


  /**
   * ProductFlavor createMany
   */
  export type ProductFlavorCreateManyArgs = {
    data: Enumerable<ProductFlavorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductFlavor update
   */
  export type ProductFlavorUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     * 
    **/
    select?: ProductFlavorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFlavorInclude | null
    /**
     * The data needed to update a ProductFlavor.
     * 
    **/
    data: XOR<ProductFlavorUpdateInput, ProductFlavorUncheckedUpdateInput>
    /**
     * Choose, which ProductFlavor to update.
     * 
    **/
    where: ProductFlavorWhereUniqueInput
  }


  /**
   * ProductFlavor updateMany
   */
  export type ProductFlavorUpdateManyArgs = {
    data: XOR<ProductFlavorUpdateManyMutationInput, ProductFlavorUncheckedUpdateManyInput>
    where?: ProductFlavorWhereInput
  }


  /**
   * ProductFlavor upsert
   */
  export type ProductFlavorUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     * 
    **/
    select?: ProductFlavorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFlavorInclude | null
    /**
     * The filter to search for the ProductFlavor to update in case it exists.
     * 
    **/
    where: ProductFlavorWhereUniqueInput
    /**
     * In case the ProductFlavor found by the `where` argument doesn't exist, create a new ProductFlavor with this data.
     * 
    **/
    create: XOR<ProductFlavorCreateInput, ProductFlavorUncheckedCreateInput>
    /**
     * In case the ProductFlavor was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductFlavorUpdateInput, ProductFlavorUncheckedUpdateInput>
  }


  /**
   * ProductFlavor delete
   */
  export type ProductFlavorDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     * 
    **/
    select?: ProductFlavorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFlavorInclude | null
    /**
     * Filter which ProductFlavor to delete.
     * 
    **/
    where: ProductFlavorWhereUniqueInput
  }


  /**
   * ProductFlavor deleteMany
   */
  export type ProductFlavorDeleteManyArgs = {
    where?: ProductFlavorWhereInput
  }


  /**
   * ProductFlavor without action
   */
  export type ProductFlavorArgs = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     * 
    **/
    select?: ProductFlavorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductFlavorInclude | null
  }



  /**
   * Model ProductVendor
   */


  export type AggregateProductVendor = {
    _count: ProductVendorCountAggregateOutputType | null
    _avg: ProductVendorAvgAggregateOutputType | null
    _sum: ProductVendorSumAggregateOutputType | null
    _min: ProductVendorMinAggregateOutputType | null
    _max: ProductVendorMaxAggregateOutputType | null
  }

  export type ProductVendorAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductVendorSumAggregateOutputType = {
    id: number | null
  }

  export type ProductVendorMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVendorMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVendorCountAggregateOutputType = {
    id: number
    label: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVendorAvgAggregateInputType = {
    id?: true
  }

  export type ProductVendorSumAggregateInputType = {
    id?: true
  }

  export type ProductVendorMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVendorMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVendorCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVendorAggregateArgs = {
    /**
     * Filter which ProductVendor to aggregate.
     * 
    **/
    where?: ProductVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVendors to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductVendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVendors
    **/
    _count?: true | ProductVendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVendorMaxAggregateInputType
  }

  export type GetProductVendorAggregateType<T extends ProductVendorAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVendor[P]>
      : GetScalarType<T[P], AggregateProductVendor[P]>
  }




  export type ProductVendorGroupByArgs = {
    where?: ProductVendorWhereInput
    orderBy?: Enumerable<ProductVendorOrderByWithAggregationInput>
    by: Array<ProductVendorScalarFieldEnum>
    having?: ProductVendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVendorCountAggregateInputType | true
    _avg?: ProductVendorAvgAggregateInputType
    _sum?: ProductVendorSumAggregateInputType
    _min?: ProductVendorMinAggregateInputType
    _max?: ProductVendorMaxAggregateInputType
  }


  export type ProductVendorGroupByOutputType = {
    id: number
    label: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ProductVendorCountAggregateOutputType | null
    _avg: ProductVendorAvgAggregateOutputType | null
    _sum: ProductVendorSumAggregateOutputType | null
    _min: ProductVendorMinAggregateOutputType | null
    _max: ProductVendorMaxAggregateOutputType | null
  }

  type GetProductVendorGroupByPayload<T extends ProductVendorGroupByArgs> = Promise<
    Array<
      PickArray<ProductVendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVendorGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVendorGroupByOutputType[P]>
        }
      >
    >


  export type ProductVendorSelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    products?: boolean | ProductFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductVendorCountOutputTypeArgs
  }

  export type ProductVendorInclude = {
    products?: boolean | ProductFindManyArgs
    _count?: boolean | ProductVendorCountOutputTypeArgs
  }

  export type ProductVendorGetPayload<
    S extends boolean | null | undefined | ProductVendorArgs,
    U = keyof S
      > = S extends true
        ? ProductVendor
    : S extends undefined
    ? never
    : S extends ProductVendorArgs | ProductVendorFindManyArgs
    ?'include' extends U
    ? ProductVendor  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductVendorCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductVendor ?ProductVendor [P]
  : 
          P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductVendorCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductVendor
  : ProductVendor


  type ProductVendorCountArgs = Merge<
    Omit<ProductVendorFindManyArgs, 'select' | 'include'> & {
      select?: ProductVendorCountAggregateInputType | true
    }
  >

  export interface ProductVendorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductVendor that matches the filter.
     * @param {ProductVendorFindUniqueArgs} args - Arguments to find a ProductVendor
     * @example
     * // Get one ProductVendor
     * const productVendor = await prisma.productVendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductVendorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductVendorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductVendor'> extends True ? CheckSelect<T, Prisma__ProductVendorClient<ProductVendor>, Prisma__ProductVendorClient<ProductVendorGetPayload<T>>> : CheckSelect<T, Prisma__ProductVendorClient<ProductVendor | null >, Prisma__ProductVendorClient<ProductVendorGetPayload<T> | null >>

    /**
     * Find the first ProductVendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVendorFindFirstArgs} args - Arguments to find a ProductVendor
     * @example
     * // Get one ProductVendor
     * const productVendor = await prisma.productVendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductVendorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductVendorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductVendor'> extends True ? CheckSelect<T, Prisma__ProductVendorClient<ProductVendor>, Prisma__ProductVendorClient<ProductVendorGetPayload<T>>> : CheckSelect<T, Prisma__ProductVendorClient<ProductVendor | null >, Prisma__ProductVendorClient<ProductVendorGetPayload<T> | null >>

    /**
     * Find zero or more ProductVendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVendorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVendors
     * const productVendors = await prisma.productVendor.findMany()
     * 
     * // Get first 10 ProductVendors
     * const productVendors = await prisma.productVendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVendorWithIdOnly = await prisma.productVendor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductVendorFindManyArgs>(
      args?: SelectSubset<T, ProductVendorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductVendor>>, PrismaPromise<Array<ProductVendorGetPayload<T>>>>

    /**
     * Create a ProductVendor.
     * @param {ProductVendorCreateArgs} args - Arguments to create a ProductVendor.
     * @example
     * // Create one ProductVendor
     * const ProductVendor = await prisma.productVendor.create({
     *   data: {
     *     // ... data to create a ProductVendor
     *   }
     * })
     * 
    **/
    create<T extends ProductVendorCreateArgs>(
      args: SelectSubset<T, ProductVendorCreateArgs>
    ): CheckSelect<T, Prisma__ProductVendorClient<ProductVendor>, Prisma__ProductVendorClient<ProductVendorGetPayload<T>>>

    /**
     * Create many ProductVendors.
     *     @param {ProductVendorCreateManyArgs} args - Arguments to create many ProductVendors.
     *     @example
     *     // Create many ProductVendors
     *     const productVendor = await prisma.productVendor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductVendorCreateManyArgs>(
      args?: SelectSubset<T, ProductVendorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductVendor.
     * @param {ProductVendorDeleteArgs} args - Arguments to delete one ProductVendor.
     * @example
     * // Delete one ProductVendor
     * const ProductVendor = await prisma.productVendor.delete({
     *   where: {
     *     // ... filter to delete one ProductVendor
     *   }
     * })
     * 
    **/
    delete<T extends ProductVendorDeleteArgs>(
      args: SelectSubset<T, ProductVendorDeleteArgs>
    ): CheckSelect<T, Prisma__ProductVendorClient<ProductVendor>, Prisma__ProductVendorClient<ProductVendorGetPayload<T>>>

    /**
     * Update one ProductVendor.
     * @param {ProductVendorUpdateArgs} args - Arguments to update one ProductVendor.
     * @example
     * // Update one ProductVendor
     * const productVendor = await prisma.productVendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductVendorUpdateArgs>(
      args: SelectSubset<T, ProductVendorUpdateArgs>
    ): CheckSelect<T, Prisma__ProductVendorClient<ProductVendor>, Prisma__ProductVendorClient<ProductVendorGetPayload<T>>>

    /**
     * Delete zero or more ProductVendors.
     * @param {ProductVendorDeleteManyArgs} args - Arguments to filter ProductVendors to delete.
     * @example
     * // Delete a few ProductVendors
     * const { count } = await prisma.productVendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductVendorDeleteManyArgs>(
      args?: SelectSubset<T, ProductVendorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVendors
     * const productVendor = await prisma.productVendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductVendorUpdateManyArgs>(
      args: SelectSubset<T, ProductVendorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductVendor.
     * @param {ProductVendorUpsertArgs} args - Arguments to update or create a ProductVendor.
     * @example
     * // Update or create a ProductVendor
     * const productVendor = await prisma.productVendor.upsert({
     *   create: {
     *     // ... data to create a ProductVendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVendor we want to update
     *   }
     * })
    **/
    upsert<T extends ProductVendorUpsertArgs>(
      args: SelectSubset<T, ProductVendorUpsertArgs>
    ): CheckSelect<T, Prisma__ProductVendorClient<ProductVendor>, Prisma__ProductVendorClient<ProductVendorGetPayload<T>>>

    /**
     * Count the number of ProductVendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVendorCountArgs} args - Arguments to filter ProductVendors to count.
     * @example
     * // Count the number of ProductVendors
     * const count = await prisma.productVendor.count({
     *   where: {
     *     // ... the filter for the ProductVendors we want to count
     *   }
     * })
    **/
    count<T extends ProductVendorCountArgs>(
      args?: Subset<T, ProductVendorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVendorAggregateArgs>(args: Subset<T, ProductVendorAggregateArgs>): PrismaPromise<GetProductVendorAggregateType<T>>

    /**
     * Group by ProductVendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVendorGroupByArgs['orderBy'] }
        : { orderBy?: ProductVendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVendorGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductVendorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductVendor findUnique
   */
  export type ProductVendorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductVendor
     * 
    **/
    select?: ProductVendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductVendorInclude | null
    /**
     * Throw an Error if a ProductVendor can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductVendor to fetch.
     * 
    **/
    where: ProductVendorWhereUniqueInput
  }


  /**
   * ProductVendor findFirst
   */
  export type ProductVendorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductVendor
     * 
    **/
    select?: ProductVendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductVendorInclude | null
    /**
     * Throw an Error if a ProductVendor can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductVendor to fetch.
     * 
    **/
    where?: ProductVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVendors to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductVendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVendors.
     * 
    **/
    cursor?: ProductVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVendors.
     * 
    **/
    distinct?: Enumerable<ProductVendorScalarFieldEnum>
  }


  /**
   * ProductVendor findMany
   */
  export type ProductVendorFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductVendor
     * 
    **/
    select?: ProductVendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductVendorInclude | null
    /**
     * Filter, which ProductVendors to fetch.
     * 
    **/
    where?: ProductVendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVendors to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductVendorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVendors.
     * 
    **/
    cursor?: ProductVendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVendors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductVendorScalarFieldEnum>
  }


  /**
   * ProductVendor create
   */
  export type ProductVendorCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductVendor
     * 
    **/
    select?: ProductVendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductVendorInclude | null
    /**
     * The data needed to create a ProductVendor.
     * 
    **/
    data: XOR<ProductVendorCreateInput, ProductVendorUncheckedCreateInput>
  }


  /**
   * ProductVendor createMany
   */
  export type ProductVendorCreateManyArgs = {
    data: Enumerable<ProductVendorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductVendor update
   */
  export type ProductVendorUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductVendor
     * 
    **/
    select?: ProductVendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductVendorInclude | null
    /**
     * The data needed to update a ProductVendor.
     * 
    **/
    data: XOR<ProductVendorUpdateInput, ProductVendorUncheckedUpdateInput>
    /**
     * Choose, which ProductVendor to update.
     * 
    **/
    where: ProductVendorWhereUniqueInput
  }


  /**
   * ProductVendor updateMany
   */
  export type ProductVendorUpdateManyArgs = {
    data: XOR<ProductVendorUpdateManyMutationInput, ProductVendorUncheckedUpdateManyInput>
    where?: ProductVendorWhereInput
  }


  /**
   * ProductVendor upsert
   */
  export type ProductVendorUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductVendor
     * 
    **/
    select?: ProductVendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductVendorInclude | null
    /**
     * The filter to search for the ProductVendor to update in case it exists.
     * 
    **/
    where: ProductVendorWhereUniqueInput
    /**
     * In case the ProductVendor found by the `where` argument doesn't exist, create a new ProductVendor with this data.
     * 
    **/
    create: XOR<ProductVendorCreateInput, ProductVendorUncheckedCreateInput>
    /**
     * In case the ProductVendor was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductVendorUpdateInput, ProductVendorUncheckedUpdateInput>
  }


  /**
   * ProductVendor delete
   */
  export type ProductVendorDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductVendor
     * 
    **/
    select?: ProductVendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductVendorInclude | null
    /**
     * Filter which ProductVendor to delete.
     * 
    **/
    where: ProductVendorWhereUniqueInput
  }


  /**
   * ProductVendor deleteMany
   */
  export type ProductVendorDeleteManyArgs = {
    where?: ProductVendorWhereInput
  }


  /**
   * ProductVendor without action
   */
  export type ProductVendorArgs = {
    /**
     * Select specific fields to fetch from the ProductVendor
     * 
    **/
    select?: ProductVendorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductVendorInclude | null
  }



  /**
   * Model IntermediateCustomerFlavorDislike
   */


  export type AggregateIntermediateCustomerFlavorDislike = {
    _count: IntermediateCustomerFlavorDislikeCountAggregateOutputType | null
    _avg: IntermediateCustomerFlavorDislikeAvgAggregateOutputType | null
    _sum: IntermediateCustomerFlavorDislikeSumAggregateOutputType | null
    _min: IntermediateCustomerFlavorDislikeMinAggregateOutputType | null
    _max: IntermediateCustomerFlavorDislikeMaxAggregateOutputType | null
  }

  export type IntermediateCustomerFlavorDislikeAvgAggregateOutputType = {
    productFlavorId: number | null
    customerId: number | null
  }

  export type IntermediateCustomerFlavorDislikeSumAggregateOutputType = {
    productFlavorId: number | null
    customerId: number | null
  }

  export type IntermediateCustomerFlavorDislikeMinAggregateOutputType = {
    productFlavorId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerFlavorDislikeMaxAggregateOutputType = {
    productFlavorId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerFlavorDislikeCountAggregateOutputType = {
    productFlavorId: number
    customerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateCustomerFlavorDislikeAvgAggregateInputType = {
    productFlavorId?: true
    customerId?: true
  }

  export type IntermediateCustomerFlavorDislikeSumAggregateInputType = {
    productFlavorId?: true
    customerId?: true
  }

  export type IntermediateCustomerFlavorDislikeMinAggregateInputType = {
    productFlavorId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerFlavorDislikeMaxAggregateInputType = {
    productFlavorId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerFlavorDislikeCountAggregateInputType = {
    productFlavorId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateCustomerFlavorDislikeAggregateArgs = {
    /**
     * Filter which IntermediateCustomerFlavorDislike to aggregate.
     * 
    **/
    where?: IntermediateCustomerFlavorDislikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerFlavorDislikes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerFlavorDislikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateCustomerFlavorDislikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerFlavorDislikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerFlavorDislikes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateCustomerFlavorDislikes
    **/
    _count?: true | IntermediateCustomerFlavorDislikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateCustomerFlavorDislikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateCustomerFlavorDislikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateCustomerFlavorDislikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateCustomerFlavorDislikeMaxAggregateInputType
  }

  export type GetIntermediateCustomerFlavorDislikeAggregateType<T extends IntermediateCustomerFlavorDislikeAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateCustomerFlavorDislike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateCustomerFlavorDislike[P]>
      : GetScalarType<T[P], AggregateIntermediateCustomerFlavorDislike[P]>
  }




  export type IntermediateCustomerFlavorDislikeGroupByArgs = {
    where?: IntermediateCustomerFlavorDislikeWhereInput
    orderBy?: Enumerable<IntermediateCustomerFlavorDislikeOrderByWithAggregationInput>
    by: Array<IntermediateCustomerFlavorDislikeScalarFieldEnum>
    having?: IntermediateCustomerFlavorDislikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateCustomerFlavorDislikeCountAggregateInputType | true
    _avg?: IntermediateCustomerFlavorDislikeAvgAggregateInputType
    _sum?: IntermediateCustomerFlavorDislikeSumAggregateInputType
    _min?: IntermediateCustomerFlavorDislikeMinAggregateInputType
    _max?: IntermediateCustomerFlavorDislikeMaxAggregateInputType
  }


  export type IntermediateCustomerFlavorDislikeGroupByOutputType = {
    productFlavorId: number
    customerId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateCustomerFlavorDislikeCountAggregateOutputType | null
    _avg: IntermediateCustomerFlavorDislikeAvgAggregateOutputType | null
    _sum: IntermediateCustomerFlavorDislikeSumAggregateOutputType | null
    _min: IntermediateCustomerFlavorDislikeMinAggregateOutputType | null
    _max: IntermediateCustomerFlavorDislikeMaxAggregateOutputType | null
  }

  type GetIntermediateCustomerFlavorDislikeGroupByPayload<T extends IntermediateCustomerFlavorDislikeGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateCustomerFlavorDislikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateCustomerFlavorDislikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateCustomerFlavorDislikeGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateCustomerFlavorDislikeGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateCustomerFlavorDislikeSelect = {
    productFlavor?: boolean | ProductFlavorArgs
    productFlavorId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateCustomerFlavorDislikeInclude = {
    productFlavor?: boolean | ProductFlavorArgs
    customer?: boolean | CustomersArgs
  }

  export type IntermediateCustomerFlavorDislikeGetPayload<
    S extends boolean | null | undefined | IntermediateCustomerFlavorDislikeArgs,
    U = keyof S
      > = S extends true
        ? IntermediateCustomerFlavorDislike
    : S extends undefined
    ? never
    : S extends IntermediateCustomerFlavorDislikeArgs | IntermediateCustomerFlavorDislikeFindManyArgs
    ?'include' extends U
    ? IntermediateCustomerFlavorDislike  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'productFlavor'
        ? ProductFlavorGetPayload<S['include'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateCustomerFlavorDislike ?IntermediateCustomerFlavorDislike [P]
  : 
          P extends 'productFlavor'
        ? ProductFlavorGetPayload<S['select'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : IntermediateCustomerFlavorDislike
  : IntermediateCustomerFlavorDislike


  type IntermediateCustomerFlavorDislikeCountArgs = Merge<
    Omit<IntermediateCustomerFlavorDislikeFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateCustomerFlavorDislikeCountAggregateInputType | true
    }
  >

  export interface IntermediateCustomerFlavorDislikeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateCustomerFlavorDislike that matches the filter.
     * @param {IntermediateCustomerFlavorDislikeFindUniqueArgs} args - Arguments to find a IntermediateCustomerFlavorDislike
     * @example
     * // Get one IntermediateCustomerFlavorDislike
     * const intermediateCustomerFlavorDislike = await prisma.intermediateCustomerFlavorDislike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateCustomerFlavorDislikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateCustomerFlavorDislikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateCustomerFlavorDislike'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislike>, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislikeGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislike | null >, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislikeGetPayload<T> | null >>

    /**
     * Find the first IntermediateCustomerFlavorDislike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFlavorDislikeFindFirstArgs} args - Arguments to find a IntermediateCustomerFlavorDislike
     * @example
     * // Get one IntermediateCustomerFlavorDislike
     * const intermediateCustomerFlavorDislike = await prisma.intermediateCustomerFlavorDislike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateCustomerFlavorDislikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateCustomerFlavorDislikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateCustomerFlavorDislike'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislike>, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislikeGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislike | null >, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislikeGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateCustomerFlavorDislikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFlavorDislikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateCustomerFlavorDislikes
     * const intermediateCustomerFlavorDislikes = await prisma.intermediateCustomerFlavorDislike.findMany()
     * 
     * // Get first 10 IntermediateCustomerFlavorDislikes
     * const intermediateCustomerFlavorDislikes = await prisma.intermediateCustomerFlavorDislike.findMany({ take: 10 })
     * 
     * // Only select the `productFlavorId`
     * const intermediateCustomerFlavorDislikeWithProductFlavorIdOnly = await prisma.intermediateCustomerFlavorDislike.findMany({ select: { productFlavorId: true } })
     * 
    **/
    findMany<T extends IntermediateCustomerFlavorDislikeFindManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerFlavorDislikeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerFlavorDislike>>, PrismaPromise<Array<IntermediateCustomerFlavorDislikeGetPayload<T>>>>

    /**
     * Create a IntermediateCustomerFlavorDislike.
     * @param {IntermediateCustomerFlavorDislikeCreateArgs} args - Arguments to create a IntermediateCustomerFlavorDislike.
     * @example
     * // Create one IntermediateCustomerFlavorDislike
     * const IntermediateCustomerFlavorDislike = await prisma.intermediateCustomerFlavorDislike.create({
     *   data: {
     *     // ... data to create a IntermediateCustomerFlavorDislike
     *   }
     * })
     * 
    **/
    create<T extends IntermediateCustomerFlavorDislikeCreateArgs>(
      args: SelectSubset<T, IntermediateCustomerFlavorDislikeCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislike>, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislikeGetPayload<T>>>

    /**
     * Create many IntermediateCustomerFlavorDislikes.
     *     @param {IntermediateCustomerFlavorDislikeCreateManyArgs} args - Arguments to create many IntermediateCustomerFlavorDislikes.
     *     @example
     *     // Create many IntermediateCustomerFlavorDislikes
     *     const intermediateCustomerFlavorDislike = await prisma.intermediateCustomerFlavorDislike.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateCustomerFlavorDislikeCreateManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerFlavorDislikeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateCustomerFlavorDislike.
     * @param {IntermediateCustomerFlavorDislikeDeleteArgs} args - Arguments to delete one IntermediateCustomerFlavorDislike.
     * @example
     * // Delete one IntermediateCustomerFlavorDislike
     * const IntermediateCustomerFlavorDislike = await prisma.intermediateCustomerFlavorDislike.delete({
     *   where: {
     *     // ... filter to delete one IntermediateCustomerFlavorDislike
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateCustomerFlavorDislikeDeleteArgs>(
      args: SelectSubset<T, IntermediateCustomerFlavorDislikeDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislike>, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislikeGetPayload<T>>>

    /**
     * Update one IntermediateCustomerFlavorDislike.
     * @param {IntermediateCustomerFlavorDislikeUpdateArgs} args - Arguments to update one IntermediateCustomerFlavorDislike.
     * @example
     * // Update one IntermediateCustomerFlavorDislike
     * const intermediateCustomerFlavorDislike = await prisma.intermediateCustomerFlavorDislike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateCustomerFlavorDislikeUpdateArgs>(
      args: SelectSubset<T, IntermediateCustomerFlavorDislikeUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislike>, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislikeGetPayload<T>>>

    /**
     * Delete zero or more IntermediateCustomerFlavorDislikes.
     * @param {IntermediateCustomerFlavorDislikeDeleteManyArgs} args - Arguments to filter IntermediateCustomerFlavorDislikes to delete.
     * @example
     * // Delete a few IntermediateCustomerFlavorDislikes
     * const { count } = await prisma.intermediateCustomerFlavorDislike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateCustomerFlavorDislikeDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerFlavorDislikeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateCustomerFlavorDislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFlavorDislikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateCustomerFlavorDislikes
     * const intermediateCustomerFlavorDislike = await prisma.intermediateCustomerFlavorDislike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateCustomerFlavorDislikeUpdateManyArgs>(
      args: SelectSubset<T, IntermediateCustomerFlavorDislikeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateCustomerFlavorDislike.
     * @param {IntermediateCustomerFlavorDislikeUpsertArgs} args - Arguments to update or create a IntermediateCustomerFlavorDislike.
     * @example
     * // Update or create a IntermediateCustomerFlavorDislike
     * const intermediateCustomerFlavorDislike = await prisma.intermediateCustomerFlavorDislike.upsert({
     *   create: {
     *     // ... data to create a IntermediateCustomerFlavorDislike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateCustomerFlavorDislike we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateCustomerFlavorDislikeUpsertArgs>(
      args: SelectSubset<T, IntermediateCustomerFlavorDislikeUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislike>, Prisma__IntermediateCustomerFlavorDislikeClient<IntermediateCustomerFlavorDislikeGetPayload<T>>>

    /**
     * Count the number of IntermediateCustomerFlavorDislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFlavorDislikeCountArgs} args - Arguments to filter IntermediateCustomerFlavorDislikes to count.
     * @example
     * // Count the number of IntermediateCustomerFlavorDislikes
     * const count = await prisma.intermediateCustomerFlavorDislike.count({
     *   where: {
     *     // ... the filter for the IntermediateCustomerFlavorDislikes we want to count
     *   }
     * })
    **/
    count<T extends IntermediateCustomerFlavorDislikeCountArgs>(
      args?: Subset<T, IntermediateCustomerFlavorDislikeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateCustomerFlavorDislikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateCustomerFlavorDislike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFlavorDislikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateCustomerFlavorDislikeAggregateArgs>(args: Subset<T, IntermediateCustomerFlavorDislikeAggregateArgs>): PrismaPromise<GetIntermediateCustomerFlavorDislikeAggregateType<T>>

    /**
     * Group by IntermediateCustomerFlavorDislike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerFlavorDislikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateCustomerFlavorDislikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateCustomerFlavorDislikeGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateCustomerFlavorDislikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateCustomerFlavorDislikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateCustomerFlavorDislikeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateCustomerFlavorDislike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateCustomerFlavorDislikeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productFlavor<T extends ProductFlavorArgs = {}>(args?: Subset<T, ProductFlavorArgs>): CheckSelect<T, Prisma__ProductFlavorClient<ProductFlavor | null >, Prisma__ProductFlavorClient<ProductFlavorGetPayload<T> | null >>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateCustomerFlavorDislike findUnique
   */
  export type IntermediateCustomerFlavorDislikeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFlavorDislike
     * 
    **/
    select?: IntermediateCustomerFlavorDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFlavorDislikeInclude | null
    /**
     * Throw an Error if a IntermediateCustomerFlavorDislike can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerFlavorDislike to fetch.
     * 
    **/
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
  }


  /**
   * IntermediateCustomerFlavorDislike findFirst
   */
  export type IntermediateCustomerFlavorDislikeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFlavorDislike
     * 
    **/
    select?: IntermediateCustomerFlavorDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFlavorDislikeInclude | null
    /**
     * Throw an Error if a IntermediateCustomerFlavorDislike can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerFlavorDislike to fetch.
     * 
    **/
    where?: IntermediateCustomerFlavorDislikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerFlavorDislikes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerFlavorDislikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateCustomerFlavorDislikes.
     * 
    **/
    cursor?: IntermediateCustomerFlavorDislikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerFlavorDislikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerFlavorDislikes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateCustomerFlavorDislikes.
     * 
    **/
    distinct?: Enumerable<IntermediateCustomerFlavorDislikeScalarFieldEnum>
  }


  /**
   * IntermediateCustomerFlavorDislike findMany
   */
  export type IntermediateCustomerFlavorDislikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFlavorDislike
     * 
    **/
    select?: IntermediateCustomerFlavorDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFlavorDislikeInclude | null
    /**
     * Filter, which IntermediateCustomerFlavorDislikes to fetch.
     * 
    **/
    where?: IntermediateCustomerFlavorDislikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerFlavorDislikes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerFlavorDislikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateCustomerFlavorDislikes.
     * 
    **/
    cursor?: IntermediateCustomerFlavorDislikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerFlavorDislikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerFlavorDislikes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateCustomerFlavorDislikeScalarFieldEnum>
  }


  /**
   * IntermediateCustomerFlavorDislike create
   */
  export type IntermediateCustomerFlavorDislikeCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFlavorDislike
     * 
    **/
    select?: IntermediateCustomerFlavorDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFlavorDislikeInclude | null
    /**
     * The data needed to create a IntermediateCustomerFlavorDislike.
     * 
    **/
    data: XOR<IntermediateCustomerFlavorDislikeCreateInput, IntermediateCustomerFlavorDislikeUncheckedCreateInput>
  }


  /**
   * IntermediateCustomerFlavorDislike createMany
   */
  export type IntermediateCustomerFlavorDislikeCreateManyArgs = {
    data: Enumerable<IntermediateCustomerFlavorDislikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateCustomerFlavorDislike update
   */
  export type IntermediateCustomerFlavorDislikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFlavorDislike
     * 
    **/
    select?: IntermediateCustomerFlavorDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFlavorDislikeInclude | null
    /**
     * The data needed to update a IntermediateCustomerFlavorDislike.
     * 
    **/
    data: XOR<IntermediateCustomerFlavorDislikeUpdateInput, IntermediateCustomerFlavorDislikeUncheckedUpdateInput>
    /**
     * Choose, which IntermediateCustomerFlavorDislike to update.
     * 
    **/
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
  }


  /**
   * IntermediateCustomerFlavorDislike updateMany
   */
  export type IntermediateCustomerFlavorDislikeUpdateManyArgs = {
    data: XOR<IntermediateCustomerFlavorDislikeUpdateManyMutationInput, IntermediateCustomerFlavorDislikeUncheckedUpdateManyInput>
    where?: IntermediateCustomerFlavorDislikeWhereInput
  }


  /**
   * IntermediateCustomerFlavorDislike upsert
   */
  export type IntermediateCustomerFlavorDislikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFlavorDislike
     * 
    **/
    select?: IntermediateCustomerFlavorDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFlavorDislikeInclude | null
    /**
     * The filter to search for the IntermediateCustomerFlavorDislike to update in case it exists.
     * 
    **/
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
    /**
     * In case the IntermediateCustomerFlavorDislike found by the `where` argument doesn't exist, create a new IntermediateCustomerFlavorDislike with this data.
     * 
    **/
    create: XOR<IntermediateCustomerFlavorDislikeCreateInput, IntermediateCustomerFlavorDislikeUncheckedCreateInput>
    /**
     * In case the IntermediateCustomerFlavorDislike was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateCustomerFlavorDislikeUpdateInput, IntermediateCustomerFlavorDislikeUncheckedUpdateInput>
  }


  /**
   * IntermediateCustomerFlavorDislike delete
   */
  export type IntermediateCustomerFlavorDislikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFlavorDislike
     * 
    **/
    select?: IntermediateCustomerFlavorDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFlavorDislikeInclude | null
    /**
     * Filter which IntermediateCustomerFlavorDislike to delete.
     * 
    **/
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
  }


  /**
   * IntermediateCustomerFlavorDislike deleteMany
   */
  export type IntermediateCustomerFlavorDislikeDeleteManyArgs = {
    where?: IntermediateCustomerFlavorDislikeWhereInput
  }


  /**
   * IntermediateCustomerFlavorDislike without action
   */
  export type IntermediateCustomerFlavorDislikeArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerFlavorDislike
     * 
    **/
    select?: IntermediateCustomerFlavorDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerFlavorDislikeInclude | null
  }



  /**
   * Model ProductCategory
   */


  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    src: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    src: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    label: number
    name: number
    src: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    src?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    src?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    src?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs = {
    /**
     * Filter which ProductCategory to aggregate.
     * 
    **/
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs = {
    where?: ProductCategoryWhereInput
    orderBy?: Enumerable<ProductCategoryOrderByWithAggregationInput>
    by: Array<ProductCategoryScalarFieldEnum>
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }


  export type ProductCategoryGroupByOutputType = {
    id: number
    label: string
    name: string
    src: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Promise<
    Array<
      PickArray<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    src?: boolean
    products?: boolean | ProductFindManyArgs
    intermediateCustomerCategoryPreferences?: boolean | IntermediateCustomerCategoryPreferenceFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductCategoryCountOutputTypeArgs
  }

  export type ProductCategoryInclude = {
    products?: boolean | ProductFindManyArgs
    intermediateCustomerCategoryPreferences?: boolean | IntermediateCustomerCategoryPreferenceFindManyArgs
    _count?: boolean | ProductCategoryCountOutputTypeArgs
  }

  export type ProductCategoryGetPayload<
    S extends boolean | null | undefined | ProductCategoryArgs,
    U = keyof S
      > = S extends true
        ? ProductCategory
    : S extends undefined
    ? never
    : S extends ProductCategoryArgs | ProductCategoryFindManyArgs
    ?'include' extends U
    ? ProductCategory  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerCategoryPreferences'
        ? Array < IntermediateCustomerCategoryPreferenceGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductCategoryCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductCategory ?ProductCategory [P]
  : 
          P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerCategoryPreferences'
        ? Array < IntermediateCustomerCategoryPreferenceGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductCategoryCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductCategory
  : ProductCategory


  type ProductCategoryCountArgs = Merge<
    Omit<ProductCategoryFindManyArgs, 'select' | 'include'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }
  >

  export interface ProductCategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductCategory'> extends True ? CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory>, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>> : CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory | null >, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | null >>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductCategory'> extends True ? CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory>, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>> : CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory | null >, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | null >>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductCategoryFindManyArgs>(
      args?: SelectSubset<T, ProductCategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductCategory>>, PrismaPromise<Array<ProductCategoryGetPayload<T>>>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
    **/
    create<T extends ProductCategoryCreateArgs>(
      args: SelectSubset<T, ProductCategoryCreateArgs>
    ): CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory>, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>>

    /**
     * Create many ProductCategories.
     *     @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     *     @example
     *     // Create many ProductCategories
     *     const productCategory = await prisma.productCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCategoryCreateManyArgs>(
      args?: SelectSubset<T, ProductCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
    **/
    delete<T extends ProductCategoryDeleteArgs>(
      args: SelectSubset<T, ProductCategoryDeleteArgs>
    ): CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory>, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductCategoryUpdateArgs>(
      args: SelectSubset<T, ProductCategoryUpdateArgs>
    ): CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory>, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductCategoryDeleteManyArgs>(
      args?: SelectSubset<T, ProductCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductCategoryUpdateManyArgs>(
      args: SelectSubset<T, ProductCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ProductCategoryUpsertArgs>(
      args: SelectSubset<T, ProductCategoryUpsertArgs>
    ): CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory>, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T>>>

    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductCategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    intermediateCustomerCategoryPreferences<T extends IntermediateCustomerCategoryPreferenceFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerCategoryPreferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerCategoryPreference>>, PrismaPromise<Array<IntermediateCustomerCategoryPreferenceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Throw an Error if a ProductCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductCategory to fetch.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Throw an Error if a ProductCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductCategory to fetch.
     * 
    **/
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     * 
    **/
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     * 
    **/
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }


  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Filter, which ProductCategories to fetch.
     * 
    **/
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     * 
    **/
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }


  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * The data needed to create a ProductCategory.
     * 
    **/
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }


  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs = {
    data: Enumerable<ProductCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * The data needed to update a ProductCategory.
     * 
    **/
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs = {
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    where?: ProductCategoryWhereInput
  }


  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     * 
    **/
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }


  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
    /**
     * Filter which ProductCategory to delete.
     * 
    **/
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs = {
    where?: ProductCategoryWhereInput
  }


  /**
   * ProductCategory without action
   */
  export type ProductCategoryArgs = {
    /**
     * Select specific fields to fetch from the ProductCategory
     * 
    **/
    select?: ProductCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductCategoryInclude | null
  }



  /**
   * Model IntermediateCustomerCategoryPreference
   */


  export type AggregateIntermediateCustomerCategoryPreference = {
    _count: IntermediateCustomerCategoryPreferenceCountAggregateOutputType | null
    _avg: IntermediateCustomerCategoryPreferenceAvgAggregateOutputType | null
    _sum: IntermediateCustomerCategoryPreferenceSumAggregateOutputType | null
    _min: IntermediateCustomerCategoryPreferenceMinAggregateOutputType | null
    _max: IntermediateCustomerCategoryPreferenceMaxAggregateOutputType | null
  }

  export type IntermediateCustomerCategoryPreferenceAvgAggregateOutputType = {
    productCategoryId: number | null
    customerId: number | null
    rank: number | null
  }

  export type IntermediateCustomerCategoryPreferenceSumAggregateOutputType = {
    productCategoryId: number | null
    customerId: number | null
    rank: number | null
  }

  export type IntermediateCustomerCategoryPreferenceMinAggregateOutputType = {
    productCategoryId: number | null
    customerId: number | null
    rank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerCategoryPreferenceMaxAggregateOutputType = {
    productCategoryId: number | null
    customerId: number | null
    rank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerCategoryPreferenceCountAggregateOutputType = {
    productCategoryId: number
    customerId: number
    rank: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateCustomerCategoryPreferenceAvgAggregateInputType = {
    productCategoryId?: true
    customerId?: true
    rank?: true
  }

  export type IntermediateCustomerCategoryPreferenceSumAggregateInputType = {
    productCategoryId?: true
    customerId?: true
    rank?: true
  }

  export type IntermediateCustomerCategoryPreferenceMinAggregateInputType = {
    productCategoryId?: true
    customerId?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerCategoryPreferenceMaxAggregateInputType = {
    productCategoryId?: true
    customerId?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerCategoryPreferenceCountAggregateInputType = {
    productCategoryId?: true
    customerId?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateCustomerCategoryPreferenceAggregateArgs = {
    /**
     * Filter which IntermediateCustomerCategoryPreference to aggregate.
     * 
    **/
    where?: IntermediateCustomerCategoryPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerCategoryPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerCategoryPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerCategoryPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerCategoryPreferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateCustomerCategoryPreferences
    **/
    _count?: true | IntermediateCustomerCategoryPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateCustomerCategoryPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateCustomerCategoryPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateCustomerCategoryPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateCustomerCategoryPreferenceMaxAggregateInputType
  }

  export type GetIntermediateCustomerCategoryPreferenceAggregateType<T extends IntermediateCustomerCategoryPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateCustomerCategoryPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateCustomerCategoryPreference[P]>
      : GetScalarType<T[P], AggregateIntermediateCustomerCategoryPreference[P]>
  }




  export type IntermediateCustomerCategoryPreferenceGroupByArgs = {
    where?: IntermediateCustomerCategoryPreferenceWhereInput
    orderBy?: Enumerable<IntermediateCustomerCategoryPreferenceOrderByWithAggregationInput>
    by: Array<IntermediateCustomerCategoryPreferenceScalarFieldEnum>
    having?: IntermediateCustomerCategoryPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateCustomerCategoryPreferenceCountAggregateInputType | true
    _avg?: IntermediateCustomerCategoryPreferenceAvgAggregateInputType
    _sum?: IntermediateCustomerCategoryPreferenceSumAggregateInputType
    _min?: IntermediateCustomerCategoryPreferenceMinAggregateInputType
    _max?: IntermediateCustomerCategoryPreferenceMaxAggregateInputType
  }


  export type IntermediateCustomerCategoryPreferenceGroupByOutputType = {
    productCategoryId: number
    customerId: number
    rank: number | null
    createdAt: Date
    updatedAt: Date
    _count: IntermediateCustomerCategoryPreferenceCountAggregateOutputType | null
    _avg: IntermediateCustomerCategoryPreferenceAvgAggregateOutputType | null
    _sum: IntermediateCustomerCategoryPreferenceSumAggregateOutputType | null
    _min: IntermediateCustomerCategoryPreferenceMinAggregateOutputType | null
    _max: IntermediateCustomerCategoryPreferenceMaxAggregateOutputType | null
  }

  type GetIntermediateCustomerCategoryPreferenceGroupByPayload<T extends IntermediateCustomerCategoryPreferenceGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateCustomerCategoryPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateCustomerCategoryPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateCustomerCategoryPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateCustomerCategoryPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateCustomerCategoryPreferenceSelect = {
    productCategory?: boolean | ProductCategoryArgs
    productCategoryId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateCustomerCategoryPreferenceInclude = {
    productCategory?: boolean | ProductCategoryArgs
    customer?: boolean | CustomersArgs
  }

  export type IntermediateCustomerCategoryPreferenceGetPayload<
    S extends boolean | null | undefined | IntermediateCustomerCategoryPreferenceArgs,
    U = keyof S
      > = S extends true
        ? IntermediateCustomerCategoryPreference
    : S extends undefined
    ? never
    : S extends IntermediateCustomerCategoryPreferenceArgs | IntermediateCustomerCategoryPreferenceFindManyArgs
    ?'include' extends U
    ? IntermediateCustomerCategoryPreference  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'productCategory'
        ? ProductCategoryGetPayload<S['include'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateCustomerCategoryPreference ?IntermediateCustomerCategoryPreference [P]
  : 
          P extends 'productCategory'
        ? ProductCategoryGetPayload<S['select'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : IntermediateCustomerCategoryPreference
  : IntermediateCustomerCategoryPreference


  type IntermediateCustomerCategoryPreferenceCountArgs = Merge<
    Omit<IntermediateCustomerCategoryPreferenceFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateCustomerCategoryPreferenceCountAggregateInputType | true
    }
  >

  export interface IntermediateCustomerCategoryPreferenceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateCustomerCategoryPreference that matches the filter.
     * @param {IntermediateCustomerCategoryPreferenceFindUniqueArgs} args - Arguments to find a IntermediateCustomerCategoryPreference
     * @example
     * // Get one IntermediateCustomerCategoryPreference
     * const intermediateCustomerCategoryPreference = await prisma.intermediateCustomerCategoryPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateCustomerCategoryPreferenceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateCustomerCategoryPreferenceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateCustomerCategoryPreference'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreference>, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreferenceGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreference | null >, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreferenceGetPayload<T> | null >>

    /**
     * Find the first IntermediateCustomerCategoryPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerCategoryPreferenceFindFirstArgs} args - Arguments to find a IntermediateCustomerCategoryPreference
     * @example
     * // Get one IntermediateCustomerCategoryPreference
     * const intermediateCustomerCategoryPreference = await prisma.intermediateCustomerCategoryPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateCustomerCategoryPreferenceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateCustomerCategoryPreferenceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateCustomerCategoryPreference'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreference>, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreferenceGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreference | null >, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreferenceGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateCustomerCategoryPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerCategoryPreferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateCustomerCategoryPreferences
     * const intermediateCustomerCategoryPreferences = await prisma.intermediateCustomerCategoryPreference.findMany()
     * 
     * // Get first 10 IntermediateCustomerCategoryPreferences
     * const intermediateCustomerCategoryPreferences = await prisma.intermediateCustomerCategoryPreference.findMany({ take: 10 })
     * 
     * // Only select the `productCategoryId`
     * const intermediateCustomerCategoryPreferenceWithProductCategoryIdOnly = await prisma.intermediateCustomerCategoryPreference.findMany({ select: { productCategoryId: true } })
     * 
    **/
    findMany<T extends IntermediateCustomerCategoryPreferenceFindManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerCategoryPreferenceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerCategoryPreference>>, PrismaPromise<Array<IntermediateCustomerCategoryPreferenceGetPayload<T>>>>

    /**
     * Create a IntermediateCustomerCategoryPreference.
     * @param {IntermediateCustomerCategoryPreferenceCreateArgs} args - Arguments to create a IntermediateCustomerCategoryPreference.
     * @example
     * // Create one IntermediateCustomerCategoryPreference
     * const IntermediateCustomerCategoryPreference = await prisma.intermediateCustomerCategoryPreference.create({
     *   data: {
     *     // ... data to create a IntermediateCustomerCategoryPreference
     *   }
     * })
     * 
    **/
    create<T extends IntermediateCustomerCategoryPreferenceCreateArgs>(
      args: SelectSubset<T, IntermediateCustomerCategoryPreferenceCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreference>, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreferenceGetPayload<T>>>

    /**
     * Create many IntermediateCustomerCategoryPreferences.
     *     @param {IntermediateCustomerCategoryPreferenceCreateManyArgs} args - Arguments to create many IntermediateCustomerCategoryPreferences.
     *     @example
     *     // Create many IntermediateCustomerCategoryPreferences
     *     const intermediateCustomerCategoryPreference = await prisma.intermediateCustomerCategoryPreference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateCustomerCategoryPreferenceCreateManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerCategoryPreferenceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateCustomerCategoryPreference.
     * @param {IntermediateCustomerCategoryPreferenceDeleteArgs} args - Arguments to delete one IntermediateCustomerCategoryPreference.
     * @example
     * // Delete one IntermediateCustomerCategoryPreference
     * const IntermediateCustomerCategoryPreference = await prisma.intermediateCustomerCategoryPreference.delete({
     *   where: {
     *     // ... filter to delete one IntermediateCustomerCategoryPreference
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateCustomerCategoryPreferenceDeleteArgs>(
      args: SelectSubset<T, IntermediateCustomerCategoryPreferenceDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreference>, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreferenceGetPayload<T>>>

    /**
     * Update one IntermediateCustomerCategoryPreference.
     * @param {IntermediateCustomerCategoryPreferenceUpdateArgs} args - Arguments to update one IntermediateCustomerCategoryPreference.
     * @example
     * // Update one IntermediateCustomerCategoryPreference
     * const intermediateCustomerCategoryPreference = await prisma.intermediateCustomerCategoryPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateCustomerCategoryPreferenceUpdateArgs>(
      args: SelectSubset<T, IntermediateCustomerCategoryPreferenceUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreference>, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreferenceGetPayload<T>>>

    /**
     * Delete zero or more IntermediateCustomerCategoryPreferences.
     * @param {IntermediateCustomerCategoryPreferenceDeleteManyArgs} args - Arguments to filter IntermediateCustomerCategoryPreferences to delete.
     * @example
     * // Delete a few IntermediateCustomerCategoryPreferences
     * const { count } = await prisma.intermediateCustomerCategoryPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateCustomerCategoryPreferenceDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerCategoryPreferenceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateCustomerCategoryPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerCategoryPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateCustomerCategoryPreferences
     * const intermediateCustomerCategoryPreference = await prisma.intermediateCustomerCategoryPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateCustomerCategoryPreferenceUpdateManyArgs>(
      args: SelectSubset<T, IntermediateCustomerCategoryPreferenceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateCustomerCategoryPreference.
     * @param {IntermediateCustomerCategoryPreferenceUpsertArgs} args - Arguments to update or create a IntermediateCustomerCategoryPreference.
     * @example
     * // Update or create a IntermediateCustomerCategoryPreference
     * const intermediateCustomerCategoryPreference = await prisma.intermediateCustomerCategoryPreference.upsert({
     *   create: {
     *     // ... data to create a IntermediateCustomerCategoryPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateCustomerCategoryPreference we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateCustomerCategoryPreferenceUpsertArgs>(
      args: SelectSubset<T, IntermediateCustomerCategoryPreferenceUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreference>, Prisma__IntermediateCustomerCategoryPreferenceClient<IntermediateCustomerCategoryPreferenceGetPayload<T>>>

    /**
     * Count the number of IntermediateCustomerCategoryPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerCategoryPreferenceCountArgs} args - Arguments to filter IntermediateCustomerCategoryPreferences to count.
     * @example
     * // Count the number of IntermediateCustomerCategoryPreferences
     * const count = await prisma.intermediateCustomerCategoryPreference.count({
     *   where: {
     *     // ... the filter for the IntermediateCustomerCategoryPreferences we want to count
     *   }
     * })
    **/
    count<T extends IntermediateCustomerCategoryPreferenceCountArgs>(
      args?: Subset<T, IntermediateCustomerCategoryPreferenceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateCustomerCategoryPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateCustomerCategoryPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerCategoryPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateCustomerCategoryPreferenceAggregateArgs>(args: Subset<T, IntermediateCustomerCategoryPreferenceAggregateArgs>): PrismaPromise<GetIntermediateCustomerCategoryPreferenceAggregateType<T>>

    /**
     * Group by IntermediateCustomerCategoryPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerCategoryPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateCustomerCategoryPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateCustomerCategoryPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateCustomerCategoryPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateCustomerCategoryPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateCustomerCategoryPreferenceGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateCustomerCategoryPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateCustomerCategoryPreferenceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productCategory<T extends ProductCategoryArgs = {}>(args?: Subset<T, ProductCategoryArgs>): CheckSelect<T, Prisma__ProductCategoryClient<ProductCategory | null >, Prisma__ProductCategoryClient<ProductCategoryGetPayload<T> | null >>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateCustomerCategoryPreference findUnique
   */
  export type IntermediateCustomerCategoryPreferenceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerCategoryPreference
     * 
    **/
    select?: IntermediateCustomerCategoryPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerCategoryPreferenceInclude | null
    /**
     * Throw an Error if a IntermediateCustomerCategoryPreference can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerCategoryPreference to fetch.
     * 
    **/
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
  }


  /**
   * IntermediateCustomerCategoryPreference findFirst
   */
  export type IntermediateCustomerCategoryPreferenceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerCategoryPreference
     * 
    **/
    select?: IntermediateCustomerCategoryPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerCategoryPreferenceInclude | null
    /**
     * Throw an Error if a IntermediateCustomerCategoryPreference can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerCategoryPreference to fetch.
     * 
    **/
    where?: IntermediateCustomerCategoryPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerCategoryPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerCategoryPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateCustomerCategoryPreferences.
     * 
    **/
    cursor?: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerCategoryPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerCategoryPreferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateCustomerCategoryPreferences.
     * 
    **/
    distinct?: Enumerable<IntermediateCustomerCategoryPreferenceScalarFieldEnum>
  }


  /**
   * IntermediateCustomerCategoryPreference findMany
   */
  export type IntermediateCustomerCategoryPreferenceFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerCategoryPreference
     * 
    **/
    select?: IntermediateCustomerCategoryPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerCategoryPreferenceInclude | null
    /**
     * Filter, which IntermediateCustomerCategoryPreferences to fetch.
     * 
    **/
    where?: IntermediateCustomerCategoryPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerCategoryPreferences to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerCategoryPreferenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateCustomerCategoryPreferences.
     * 
    **/
    cursor?: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerCategoryPreferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerCategoryPreferences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateCustomerCategoryPreferenceScalarFieldEnum>
  }


  /**
   * IntermediateCustomerCategoryPreference create
   */
  export type IntermediateCustomerCategoryPreferenceCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerCategoryPreference
     * 
    **/
    select?: IntermediateCustomerCategoryPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerCategoryPreferenceInclude | null
    /**
     * The data needed to create a IntermediateCustomerCategoryPreference.
     * 
    **/
    data: XOR<IntermediateCustomerCategoryPreferenceCreateInput, IntermediateCustomerCategoryPreferenceUncheckedCreateInput>
  }


  /**
   * IntermediateCustomerCategoryPreference createMany
   */
  export type IntermediateCustomerCategoryPreferenceCreateManyArgs = {
    data: Enumerable<IntermediateCustomerCategoryPreferenceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateCustomerCategoryPreference update
   */
  export type IntermediateCustomerCategoryPreferenceUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerCategoryPreference
     * 
    **/
    select?: IntermediateCustomerCategoryPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerCategoryPreferenceInclude | null
    /**
     * The data needed to update a IntermediateCustomerCategoryPreference.
     * 
    **/
    data: XOR<IntermediateCustomerCategoryPreferenceUpdateInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateInput>
    /**
     * Choose, which IntermediateCustomerCategoryPreference to update.
     * 
    **/
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
  }


  /**
   * IntermediateCustomerCategoryPreference updateMany
   */
  export type IntermediateCustomerCategoryPreferenceUpdateManyArgs = {
    data: XOR<IntermediateCustomerCategoryPreferenceUpdateManyMutationInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateManyInput>
    where?: IntermediateCustomerCategoryPreferenceWhereInput
  }


  /**
   * IntermediateCustomerCategoryPreference upsert
   */
  export type IntermediateCustomerCategoryPreferenceUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerCategoryPreference
     * 
    **/
    select?: IntermediateCustomerCategoryPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerCategoryPreferenceInclude | null
    /**
     * The filter to search for the IntermediateCustomerCategoryPreference to update in case it exists.
     * 
    **/
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    /**
     * In case the IntermediateCustomerCategoryPreference found by the `where` argument doesn't exist, create a new IntermediateCustomerCategoryPreference with this data.
     * 
    **/
    create: XOR<IntermediateCustomerCategoryPreferenceCreateInput, IntermediateCustomerCategoryPreferenceUncheckedCreateInput>
    /**
     * In case the IntermediateCustomerCategoryPreference was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateCustomerCategoryPreferenceUpdateInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateInput>
  }


  /**
   * IntermediateCustomerCategoryPreference delete
   */
  export type IntermediateCustomerCategoryPreferenceDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerCategoryPreference
     * 
    **/
    select?: IntermediateCustomerCategoryPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerCategoryPreferenceInclude | null
    /**
     * Filter which IntermediateCustomerCategoryPreference to delete.
     * 
    **/
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
  }


  /**
   * IntermediateCustomerCategoryPreference deleteMany
   */
  export type IntermediateCustomerCategoryPreferenceDeleteManyArgs = {
    where?: IntermediateCustomerCategoryPreferenceWhereInput
  }


  /**
   * IntermediateCustomerCategoryPreference without action
   */
  export type IntermediateCustomerCategoryPreferenceArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerCategoryPreference
     * 
    **/
    select?: IntermediateCustomerCategoryPreferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerCategoryPreferenceInclude | null
  }



  /**
   * Model IntermediateProductIngredient
   */


  export type AggregateIntermediateProductIngredient = {
    _count: IntermediateProductIngredientCountAggregateOutputType | null
    _avg: IntermediateProductIngredientAvgAggregateOutputType | null
    _sum: IntermediateProductIngredientSumAggregateOutputType | null
    _min: IntermediateProductIngredientMinAggregateOutputType | null
    _max: IntermediateProductIngredientMaxAggregateOutputType | null
  }

  export type IntermediateProductIngredientAvgAggregateOutputType = {
    productId: number | null
    productIngredientId: number | null
  }

  export type IntermediateProductIngredientSumAggregateOutputType = {
    productId: number | null
    productIngredientId: number | null
  }

  export type IntermediateProductIngredientMinAggregateOutputType = {
    productId: number | null
    productIngredientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateProductIngredientMaxAggregateOutputType = {
    productId: number | null
    productIngredientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateProductIngredientCountAggregateOutputType = {
    productId: number
    productIngredientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateProductIngredientAvgAggregateInputType = {
    productId?: true
    productIngredientId?: true
  }

  export type IntermediateProductIngredientSumAggregateInputType = {
    productId?: true
    productIngredientId?: true
  }

  export type IntermediateProductIngredientMinAggregateInputType = {
    productId?: true
    productIngredientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateProductIngredientMaxAggregateInputType = {
    productId?: true
    productIngredientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateProductIngredientCountAggregateInputType = {
    productId?: true
    productIngredientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateProductIngredientAggregateArgs = {
    /**
     * Filter which IntermediateProductIngredient to aggregate.
     * 
    **/
    where?: IntermediateProductIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateProductIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateProductIngredients
    **/
    _count?: true | IntermediateProductIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateProductIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateProductIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateProductIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateProductIngredientMaxAggregateInputType
  }

  export type GetIntermediateProductIngredientAggregateType<T extends IntermediateProductIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateProductIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateProductIngredient[P]>
      : GetScalarType<T[P], AggregateIntermediateProductIngredient[P]>
  }




  export type IntermediateProductIngredientGroupByArgs = {
    where?: IntermediateProductIngredientWhereInput
    orderBy?: Enumerable<IntermediateProductIngredientOrderByWithAggregationInput>
    by: Array<IntermediateProductIngredientScalarFieldEnum>
    having?: IntermediateProductIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateProductIngredientCountAggregateInputType | true
    _avg?: IntermediateProductIngredientAvgAggregateInputType
    _sum?: IntermediateProductIngredientSumAggregateInputType
    _min?: IntermediateProductIngredientMinAggregateInputType
    _max?: IntermediateProductIngredientMaxAggregateInputType
  }


  export type IntermediateProductIngredientGroupByOutputType = {
    productId: number
    productIngredientId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateProductIngredientCountAggregateOutputType | null
    _avg: IntermediateProductIngredientAvgAggregateOutputType | null
    _sum: IntermediateProductIngredientSumAggregateOutputType | null
    _min: IntermediateProductIngredientMinAggregateOutputType | null
    _max: IntermediateProductIngredientMaxAggregateOutputType | null
  }

  type GetIntermediateProductIngredientGroupByPayload<T extends IntermediateProductIngredientGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateProductIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateProductIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateProductIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateProductIngredientGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateProductIngredientSelect = {
    product?: boolean | ProductArgs
    productId?: boolean
    productIngredient?: boolean | ProductIngredientArgs
    productIngredientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateProductIngredientInclude = {
    product?: boolean | ProductArgs
    productIngredient?: boolean | ProductIngredientArgs
  }

  export type IntermediateProductIngredientGetPayload<
    S extends boolean | null | undefined | IntermediateProductIngredientArgs,
    U = keyof S
      > = S extends true
        ? IntermediateProductIngredient
    : S extends undefined
    ? never
    : S extends IntermediateProductIngredientArgs | IntermediateProductIngredientFindManyArgs
    ?'include' extends U
    ? IntermediateProductIngredient  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> :
        P extends 'productIngredient'
        ? ProductIngredientGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateProductIngredient ?IntermediateProductIngredient [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> :
        P extends 'productIngredient'
        ? ProductIngredientGetPayload<S['select'][P]> : never
  } 
    : IntermediateProductIngredient
  : IntermediateProductIngredient


  type IntermediateProductIngredientCountArgs = Merge<
    Omit<IntermediateProductIngredientFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateProductIngredientCountAggregateInputType | true
    }
  >

  export interface IntermediateProductIngredientDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateProductIngredient that matches the filter.
     * @param {IntermediateProductIngredientFindUniqueArgs} args - Arguments to find a IntermediateProductIngredient
     * @example
     * // Get one IntermediateProductIngredient
     * const intermediateProductIngredient = await prisma.intermediateProductIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateProductIngredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateProductIngredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateProductIngredient'> extends True ? CheckSelect<T, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredient>, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredientGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredient | null >, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredientGetPayload<T> | null >>

    /**
     * Find the first IntermediateProductIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductIngredientFindFirstArgs} args - Arguments to find a IntermediateProductIngredient
     * @example
     * // Get one IntermediateProductIngredient
     * const intermediateProductIngredient = await prisma.intermediateProductIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateProductIngredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateProductIngredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateProductIngredient'> extends True ? CheckSelect<T, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredient>, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredientGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredient | null >, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredientGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateProductIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateProductIngredients
     * const intermediateProductIngredients = await prisma.intermediateProductIngredient.findMany()
     * 
     * // Get first 10 IntermediateProductIngredients
     * const intermediateProductIngredients = await prisma.intermediateProductIngredient.findMany({ take: 10 })
     * 
     * // Only select the `productId`
     * const intermediateProductIngredientWithProductIdOnly = await prisma.intermediateProductIngredient.findMany({ select: { productId: true } })
     * 
    **/
    findMany<T extends IntermediateProductIngredientFindManyArgs>(
      args?: SelectSubset<T, IntermediateProductIngredientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateProductIngredient>>, PrismaPromise<Array<IntermediateProductIngredientGetPayload<T>>>>

    /**
     * Create a IntermediateProductIngredient.
     * @param {IntermediateProductIngredientCreateArgs} args - Arguments to create a IntermediateProductIngredient.
     * @example
     * // Create one IntermediateProductIngredient
     * const IntermediateProductIngredient = await prisma.intermediateProductIngredient.create({
     *   data: {
     *     // ... data to create a IntermediateProductIngredient
     *   }
     * })
     * 
    **/
    create<T extends IntermediateProductIngredientCreateArgs>(
      args: SelectSubset<T, IntermediateProductIngredientCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredient>, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredientGetPayload<T>>>

    /**
     * Create many IntermediateProductIngredients.
     *     @param {IntermediateProductIngredientCreateManyArgs} args - Arguments to create many IntermediateProductIngredients.
     *     @example
     *     // Create many IntermediateProductIngredients
     *     const intermediateProductIngredient = await prisma.intermediateProductIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateProductIngredientCreateManyArgs>(
      args?: SelectSubset<T, IntermediateProductIngredientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateProductIngredient.
     * @param {IntermediateProductIngredientDeleteArgs} args - Arguments to delete one IntermediateProductIngredient.
     * @example
     * // Delete one IntermediateProductIngredient
     * const IntermediateProductIngredient = await prisma.intermediateProductIngredient.delete({
     *   where: {
     *     // ... filter to delete one IntermediateProductIngredient
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateProductIngredientDeleteArgs>(
      args: SelectSubset<T, IntermediateProductIngredientDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredient>, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredientGetPayload<T>>>

    /**
     * Update one IntermediateProductIngredient.
     * @param {IntermediateProductIngredientUpdateArgs} args - Arguments to update one IntermediateProductIngredient.
     * @example
     * // Update one IntermediateProductIngredient
     * const intermediateProductIngredient = await prisma.intermediateProductIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateProductIngredientUpdateArgs>(
      args: SelectSubset<T, IntermediateProductIngredientUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredient>, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredientGetPayload<T>>>

    /**
     * Delete zero or more IntermediateProductIngredients.
     * @param {IntermediateProductIngredientDeleteManyArgs} args - Arguments to filter IntermediateProductIngredients to delete.
     * @example
     * // Delete a few IntermediateProductIngredients
     * const { count } = await prisma.intermediateProductIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateProductIngredientDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateProductIngredientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateProductIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateProductIngredients
     * const intermediateProductIngredient = await prisma.intermediateProductIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateProductIngredientUpdateManyArgs>(
      args: SelectSubset<T, IntermediateProductIngredientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateProductIngredient.
     * @param {IntermediateProductIngredientUpsertArgs} args - Arguments to update or create a IntermediateProductIngredient.
     * @example
     * // Update or create a IntermediateProductIngredient
     * const intermediateProductIngredient = await prisma.intermediateProductIngredient.upsert({
     *   create: {
     *     // ... data to create a IntermediateProductIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateProductIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateProductIngredientUpsertArgs>(
      args: SelectSubset<T, IntermediateProductIngredientUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredient>, Prisma__IntermediateProductIngredientClient<IntermediateProductIngredientGetPayload<T>>>

    /**
     * Count the number of IntermediateProductIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductIngredientCountArgs} args - Arguments to filter IntermediateProductIngredients to count.
     * @example
     * // Count the number of IntermediateProductIngredients
     * const count = await prisma.intermediateProductIngredient.count({
     *   where: {
     *     // ... the filter for the IntermediateProductIngredients we want to count
     *   }
     * })
    **/
    count<T extends IntermediateProductIngredientCountArgs>(
      args?: Subset<T, IntermediateProductIngredientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateProductIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateProductIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateProductIngredientAggregateArgs>(args: Subset<T, IntermediateProductIngredientAggregateArgs>): PrismaPromise<GetIntermediateProductIngredientAggregateType<T>>

    /**
     * Group by IntermediateProductIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateProductIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateProductIngredientGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateProductIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateProductIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateProductIngredientGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateProductIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateProductIngredientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    productIngredient<T extends ProductIngredientArgs = {}>(args?: Subset<T, ProductIngredientArgs>): CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient | null >, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateProductIngredient findUnique
   */
  export type IntermediateProductIngredientFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductIngredient
     * 
    **/
    select?: IntermediateProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductIngredientInclude | null
    /**
     * Throw an Error if a IntermediateProductIngredient can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateProductIngredient to fetch.
     * 
    **/
    where: IntermediateProductIngredientWhereUniqueInput
  }


  /**
   * IntermediateProductIngredient findFirst
   */
  export type IntermediateProductIngredientFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductIngredient
     * 
    **/
    select?: IntermediateProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductIngredientInclude | null
    /**
     * Throw an Error if a IntermediateProductIngredient can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateProductIngredient to fetch.
     * 
    **/
    where?: IntermediateProductIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateProductIngredients.
     * 
    **/
    cursor?: IntermediateProductIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateProductIngredients.
     * 
    **/
    distinct?: Enumerable<IntermediateProductIngredientScalarFieldEnum>
  }


  /**
   * IntermediateProductIngredient findMany
   */
  export type IntermediateProductIngredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductIngredient
     * 
    **/
    select?: IntermediateProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductIngredientInclude | null
    /**
     * Filter, which IntermediateProductIngredients to fetch.
     * 
    **/
    where?: IntermediateProductIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateProductIngredients.
     * 
    **/
    cursor?: IntermediateProductIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductIngredients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateProductIngredientScalarFieldEnum>
  }


  /**
   * IntermediateProductIngredient create
   */
  export type IntermediateProductIngredientCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductIngredient
     * 
    **/
    select?: IntermediateProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductIngredientInclude | null
    /**
     * The data needed to create a IntermediateProductIngredient.
     * 
    **/
    data: XOR<IntermediateProductIngredientCreateInput, IntermediateProductIngredientUncheckedCreateInput>
  }


  /**
   * IntermediateProductIngredient createMany
   */
  export type IntermediateProductIngredientCreateManyArgs = {
    data: Enumerable<IntermediateProductIngredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateProductIngredient update
   */
  export type IntermediateProductIngredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductIngredient
     * 
    **/
    select?: IntermediateProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductIngredientInclude | null
    /**
     * The data needed to update a IntermediateProductIngredient.
     * 
    **/
    data: XOR<IntermediateProductIngredientUpdateInput, IntermediateProductIngredientUncheckedUpdateInput>
    /**
     * Choose, which IntermediateProductIngredient to update.
     * 
    **/
    where: IntermediateProductIngredientWhereUniqueInput
  }


  /**
   * IntermediateProductIngredient updateMany
   */
  export type IntermediateProductIngredientUpdateManyArgs = {
    data: XOR<IntermediateProductIngredientUpdateManyMutationInput, IntermediateProductIngredientUncheckedUpdateManyInput>
    where?: IntermediateProductIngredientWhereInput
  }


  /**
   * IntermediateProductIngredient upsert
   */
  export type IntermediateProductIngredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductIngredient
     * 
    **/
    select?: IntermediateProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductIngredientInclude | null
    /**
     * The filter to search for the IntermediateProductIngredient to update in case it exists.
     * 
    **/
    where: IntermediateProductIngredientWhereUniqueInput
    /**
     * In case the IntermediateProductIngredient found by the `where` argument doesn't exist, create a new IntermediateProductIngredient with this data.
     * 
    **/
    create: XOR<IntermediateProductIngredientCreateInput, IntermediateProductIngredientUncheckedCreateInput>
    /**
     * In case the IntermediateProductIngredient was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateProductIngredientUpdateInput, IntermediateProductIngredientUncheckedUpdateInput>
  }


  /**
   * IntermediateProductIngredient delete
   */
  export type IntermediateProductIngredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductIngredient
     * 
    **/
    select?: IntermediateProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductIngredientInclude | null
    /**
     * Filter which IntermediateProductIngredient to delete.
     * 
    **/
    where: IntermediateProductIngredientWhereUniqueInput
  }


  /**
   * IntermediateProductIngredient deleteMany
   */
  export type IntermediateProductIngredientDeleteManyArgs = {
    where?: IntermediateProductIngredientWhereInput
  }


  /**
   * IntermediateProductIngredient without action
   */
  export type IntermediateProductIngredientArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductIngredient
     * 
    **/
    select?: IntermediateProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductIngredientInclude | null
  }



  /**
   * Model ProductIngredient
   */


  export type AggregateProductIngredient = {
    _count: ProductIngredientCountAggregateOutputType | null
    _avg: ProductIngredientAvgAggregateOutputType | null
    _sum: ProductIngredientSumAggregateOutputType | null
    _min: ProductIngredientMinAggregateOutputType | null
    _max: ProductIngredientMaxAggregateOutputType | null
  }

  export type ProductIngredientAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductIngredientSumAggregateOutputType = {
    id: number | null
  }

  export type ProductIngredientMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductIngredientMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductIngredientCountAggregateOutputType = {
    id: number
    label: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductIngredientAvgAggregateInputType = {
    id?: true
  }

  export type ProductIngredientSumAggregateInputType = {
    id?: true
  }

  export type ProductIngredientMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductIngredientMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductIngredientCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductIngredientAggregateArgs = {
    /**
     * Filter which ProductIngredient to aggregate.
     * 
    **/
    where?: ProductIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductIngredients
    **/
    _count?: true | ProductIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductIngredientMaxAggregateInputType
  }

  export type GetProductIngredientAggregateType<T extends ProductIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateProductIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductIngredient[P]>
      : GetScalarType<T[P], AggregateProductIngredient[P]>
  }




  export type ProductIngredientGroupByArgs = {
    where?: ProductIngredientWhereInput
    orderBy?: Enumerable<ProductIngredientOrderByWithAggregationInput>
    by: Array<ProductIngredientScalarFieldEnum>
    having?: ProductIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductIngredientCountAggregateInputType | true
    _avg?: ProductIngredientAvgAggregateInputType
    _sum?: ProductIngredientSumAggregateInputType
    _min?: ProductIngredientMinAggregateInputType
    _max?: ProductIngredientMaxAggregateInputType
  }


  export type ProductIngredientGroupByOutputType = {
    id: number
    label: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ProductIngredientCountAggregateOutputType | null
    _avg: ProductIngredientAvgAggregateOutputType | null
    _sum: ProductIngredientSumAggregateOutputType | null
    _min: ProductIngredientMinAggregateOutputType | null
    _max: ProductIngredientMaxAggregateOutputType | null
  }

  type GetProductIngredientGroupByPayload<T extends ProductIngredientGroupByArgs> = Promise<
    Array<
      PickArray<ProductIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], ProductIngredientGroupByOutputType[P]>
        }
      >
    >


  export type ProductIngredientSelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    intermediateProductIngredients?: boolean | IntermediateProductIngredientFindManyArgs
    intermediateCustomerIngredientDislikes?: boolean | IntermediateCustomerIngredientDislikeFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductIngredientCountOutputTypeArgs
  }

  export type ProductIngredientInclude = {
    intermediateProductIngredients?: boolean | IntermediateProductIngredientFindManyArgs
    intermediateCustomerIngredientDislikes?: boolean | IntermediateCustomerIngredientDislikeFindManyArgs
    _count?: boolean | ProductIngredientCountOutputTypeArgs
  }

  export type ProductIngredientGetPayload<
    S extends boolean | null | undefined | ProductIngredientArgs,
    U = keyof S
      > = S extends true
        ? ProductIngredient
    : S extends undefined
    ? never
    : S extends ProductIngredientArgs | ProductIngredientFindManyArgs
    ?'include' extends U
    ? ProductIngredient  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateProductIngredients'
        ? Array < IntermediateProductIngredientGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerIngredientDislikes'
        ? Array < IntermediateCustomerIngredientDislikeGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductIngredientCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductIngredient ?ProductIngredient [P]
  : 
          P extends 'intermediateProductIngredients'
        ? Array < IntermediateProductIngredientGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerIngredientDislikes'
        ? Array < IntermediateCustomerIngredientDislikeGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductIngredientCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductIngredient
  : ProductIngredient


  type ProductIngredientCountArgs = Merge<
    Omit<ProductIngredientFindManyArgs, 'select' | 'include'> & {
      select?: ProductIngredientCountAggregateInputType | true
    }
  >

  export interface ProductIngredientDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductIngredient that matches the filter.
     * @param {ProductIngredientFindUniqueArgs} args - Arguments to find a ProductIngredient
     * @example
     * // Get one ProductIngredient
     * const productIngredient = await prisma.productIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductIngredientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductIngredientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductIngredient'> extends True ? CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient>, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T>>> : CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient | null >, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T> | null >>

    /**
     * Find the first ProductIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIngredientFindFirstArgs} args - Arguments to find a ProductIngredient
     * @example
     * // Get one ProductIngredient
     * const productIngredient = await prisma.productIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductIngredientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductIngredientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductIngredient'> extends True ? CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient>, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T>>> : CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient | null >, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T> | null >>

    /**
     * Find zero or more ProductIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductIngredients
     * const productIngredients = await prisma.productIngredient.findMany()
     * 
     * // Get first 10 ProductIngredients
     * const productIngredients = await prisma.productIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productIngredientWithIdOnly = await prisma.productIngredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductIngredientFindManyArgs>(
      args?: SelectSubset<T, ProductIngredientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductIngredient>>, PrismaPromise<Array<ProductIngredientGetPayload<T>>>>

    /**
     * Create a ProductIngredient.
     * @param {ProductIngredientCreateArgs} args - Arguments to create a ProductIngredient.
     * @example
     * // Create one ProductIngredient
     * const ProductIngredient = await prisma.productIngredient.create({
     *   data: {
     *     // ... data to create a ProductIngredient
     *   }
     * })
     * 
    **/
    create<T extends ProductIngredientCreateArgs>(
      args: SelectSubset<T, ProductIngredientCreateArgs>
    ): CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient>, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T>>>

    /**
     * Create many ProductIngredients.
     *     @param {ProductIngredientCreateManyArgs} args - Arguments to create many ProductIngredients.
     *     @example
     *     // Create many ProductIngredients
     *     const productIngredient = await prisma.productIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductIngredientCreateManyArgs>(
      args?: SelectSubset<T, ProductIngredientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductIngredient.
     * @param {ProductIngredientDeleteArgs} args - Arguments to delete one ProductIngredient.
     * @example
     * // Delete one ProductIngredient
     * const ProductIngredient = await prisma.productIngredient.delete({
     *   where: {
     *     // ... filter to delete one ProductIngredient
     *   }
     * })
     * 
    **/
    delete<T extends ProductIngredientDeleteArgs>(
      args: SelectSubset<T, ProductIngredientDeleteArgs>
    ): CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient>, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T>>>

    /**
     * Update one ProductIngredient.
     * @param {ProductIngredientUpdateArgs} args - Arguments to update one ProductIngredient.
     * @example
     * // Update one ProductIngredient
     * const productIngredient = await prisma.productIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductIngredientUpdateArgs>(
      args: SelectSubset<T, ProductIngredientUpdateArgs>
    ): CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient>, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T>>>

    /**
     * Delete zero or more ProductIngredients.
     * @param {ProductIngredientDeleteManyArgs} args - Arguments to filter ProductIngredients to delete.
     * @example
     * // Delete a few ProductIngredients
     * const { count } = await prisma.productIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductIngredientDeleteManyArgs>(
      args?: SelectSubset<T, ProductIngredientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductIngredients
     * const productIngredient = await prisma.productIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductIngredientUpdateManyArgs>(
      args: SelectSubset<T, ProductIngredientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductIngredient.
     * @param {ProductIngredientUpsertArgs} args - Arguments to update or create a ProductIngredient.
     * @example
     * // Update or create a ProductIngredient
     * const productIngredient = await prisma.productIngredient.upsert({
     *   create: {
     *     // ... data to create a ProductIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends ProductIngredientUpsertArgs>(
      args: SelectSubset<T, ProductIngredientUpsertArgs>
    ): CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient>, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T>>>

    /**
     * Count the number of ProductIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIngredientCountArgs} args - Arguments to filter ProductIngredients to count.
     * @example
     * // Count the number of ProductIngredients
     * const count = await prisma.productIngredient.count({
     *   where: {
     *     // ... the filter for the ProductIngredients we want to count
     *   }
     * })
    **/
    count<T extends ProductIngredientCountArgs>(
      args?: Subset<T, ProductIngredientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductIngredientAggregateArgs>(args: Subset<T, ProductIngredientAggregateArgs>): PrismaPromise<GetProductIngredientAggregateType<T>>

    /**
     * Group by ProductIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductIngredientGroupByArgs['orderBy'] }
        : { orderBy?: ProductIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductIngredientGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductIngredientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateProductIngredients<T extends IntermediateProductIngredientFindManyArgs = {}>(args?: Subset<T, IntermediateProductIngredientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateProductIngredient>>, PrismaPromise<Array<IntermediateProductIngredientGetPayload<T>>>>;

    intermediateCustomerIngredientDislikes<T extends IntermediateCustomerIngredientDislikeFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerIngredientDislikeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerIngredientDislike>>, PrismaPromise<Array<IntermediateCustomerIngredientDislikeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductIngredient findUnique
   */
  export type ProductIngredientFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredient
     * 
    **/
    select?: ProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductIngredientInclude | null
    /**
     * Throw an Error if a ProductIngredient can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductIngredient to fetch.
     * 
    **/
    where: ProductIngredientWhereUniqueInput
  }


  /**
   * ProductIngredient findFirst
   */
  export type ProductIngredientFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredient
     * 
    **/
    select?: ProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductIngredientInclude | null
    /**
     * Throw an Error if a ProductIngredient can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductIngredient to fetch.
     * 
    **/
    where?: ProductIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductIngredients.
     * 
    **/
    cursor?: ProductIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIngredients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductIngredients.
     * 
    **/
    distinct?: Enumerable<ProductIngredientScalarFieldEnum>
  }


  /**
   * ProductIngredient findMany
   */
  export type ProductIngredientFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredient
     * 
    **/
    select?: ProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductIngredientInclude | null
    /**
     * Filter, which ProductIngredients to fetch.
     * 
    **/
    where?: ProductIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIngredients to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductIngredientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductIngredients.
     * 
    **/
    cursor?: ProductIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIngredients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIngredients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductIngredientScalarFieldEnum>
  }


  /**
   * ProductIngredient create
   */
  export type ProductIngredientCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredient
     * 
    **/
    select?: ProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductIngredientInclude | null
    /**
     * The data needed to create a ProductIngredient.
     * 
    **/
    data: XOR<ProductIngredientCreateInput, ProductIngredientUncheckedCreateInput>
  }


  /**
   * ProductIngredient createMany
   */
  export type ProductIngredientCreateManyArgs = {
    data: Enumerable<ProductIngredientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductIngredient update
   */
  export type ProductIngredientUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredient
     * 
    **/
    select?: ProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductIngredientInclude | null
    /**
     * The data needed to update a ProductIngredient.
     * 
    **/
    data: XOR<ProductIngredientUpdateInput, ProductIngredientUncheckedUpdateInput>
    /**
     * Choose, which ProductIngredient to update.
     * 
    **/
    where: ProductIngredientWhereUniqueInput
  }


  /**
   * ProductIngredient updateMany
   */
  export type ProductIngredientUpdateManyArgs = {
    data: XOR<ProductIngredientUpdateManyMutationInput, ProductIngredientUncheckedUpdateManyInput>
    where?: ProductIngredientWhereInput
  }


  /**
   * ProductIngredient upsert
   */
  export type ProductIngredientUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredient
     * 
    **/
    select?: ProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductIngredientInclude | null
    /**
     * The filter to search for the ProductIngredient to update in case it exists.
     * 
    **/
    where: ProductIngredientWhereUniqueInput
    /**
     * In case the ProductIngredient found by the `where` argument doesn't exist, create a new ProductIngredient with this data.
     * 
    **/
    create: XOR<ProductIngredientCreateInput, ProductIngredientUncheckedCreateInput>
    /**
     * In case the ProductIngredient was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductIngredientUpdateInput, ProductIngredientUncheckedUpdateInput>
  }


  /**
   * ProductIngredient delete
   */
  export type ProductIngredientDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredient
     * 
    **/
    select?: ProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductIngredientInclude | null
    /**
     * Filter which ProductIngredient to delete.
     * 
    **/
    where: ProductIngredientWhereUniqueInput
  }


  /**
   * ProductIngredient deleteMany
   */
  export type ProductIngredientDeleteManyArgs = {
    where?: ProductIngredientWhereInput
  }


  /**
   * ProductIngredient without action
   */
  export type ProductIngredientArgs = {
    /**
     * Select specific fields to fetch from the ProductIngredient
     * 
    **/
    select?: ProductIngredientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductIngredientInclude | null
  }



  /**
   * Model IntermediateCustomerIngredientDislike
   */


  export type AggregateIntermediateCustomerIngredientDislike = {
    _count: IntermediateCustomerIngredientDislikeCountAggregateOutputType | null
    _avg: IntermediateCustomerIngredientDislikeAvgAggregateOutputType | null
    _sum: IntermediateCustomerIngredientDislikeSumAggregateOutputType | null
    _min: IntermediateCustomerIngredientDislikeMinAggregateOutputType | null
    _max: IntermediateCustomerIngredientDislikeMaxAggregateOutputType | null
  }

  export type IntermediateCustomerIngredientDislikeAvgAggregateOutputType = {
    productIngredientId: number | null
    customerId: number | null
  }

  export type IntermediateCustomerIngredientDislikeSumAggregateOutputType = {
    productIngredientId: number | null
    customerId: number | null
  }

  export type IntermediateCustomerIngredientDislikeMinAggregateOutputType = {
    productIngredientId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerIngredientDislikeMaxAggregateOutputType = {
    productIngredientId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerIngredientDislikeCountAggregateOutputType = {
    productIngredientId: number
    customerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateCustomerIngredientDislikeAvgAggregateInputType = {
    productIngredientId?: true
    customerId?: true
  }

  export type IntermediateCustomerIngredientDislikeSumAggregateInputType = {
    productIngredientId?: true
    customerId?: true
  }

  export type IntermediateCustomerIngredientDislikeMinAggregateInputType = {
    productIngredientId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerIngredientDislikeMaxAggregateInputType = {
    productIngredientId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerIngredientDislikeCountAggregateInputType = {
    productIngredientId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateCustomerIngredientDislikeAggregateArgs = {
    /**
     * Filter which IntermediateCustomerIngredientDislike to aggregate.
     * 
    **/
    where?: IntermediateCustomerIngredientDislikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerIngredientDislikes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerIngredientDislikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateCustomerIngredientDislikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerIngredientDislikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerIngredientDislikes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateCustomerIngredientDislikes
    **/
    _count?: true | IntermediateCustomerIngredientDislikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateCustomerIngredientDislikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateCustomerIngredientDislikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateCustomerIngredientDislikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateCustomerIngredientDislikeMaxAggregateInputType
  }

  export type GetIntermediateCustomerIngredientDislikeAggregateType<T extends IntermediateCustomerIngredientDislikeAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateCustomerIngredientDislike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateCustomerIngredientDislike[P]>
      : GetScalarType<T[P], AggregateIntermediateCustomerIngredientDislike[P]>
  }




  export type IntermediateCustomerIngredientDislikeGroupByArgs = {
    where?: IntermediateCustomerIngredientDislikeWhereInput
    orderBy?: Enumerable<IntermediateCustomerIngredientDislikeOrderByWithAggregationInput>
    by: Array<IntermediateCustomerIngredientDislikeScalarFieldEnum>
    having?: IntermediateCustomerIngredientDislikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateCustomerIngredientDislikeCountAggregateInputType | true
    _avg?: IntermediateCustomerIngredientDislikeAvgAggregateInputType
    _sum?: IntermediateCustomerIngredientDislikeSumAggregateInputType
    _min?: IntermediateCustomerIngredientDislikeMinAggregateInputType
    _max?: IntermediateCustomerIngredientDislikeMaxAggregateInputType
  }


  export type IntermediateCustomerIngredientDislikeGroupByOutputType = {
    productIngredientId: number
    customerId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateCustomerIngredientDislikeCountAggregateOutputType | null
    _avg: IntermediateCustomerIngredientDislikeAvgAggregateOutputType | null
    _sum: IntermediateCustomerIngredientDislikeSumAggregateOutputType | null
    _min: IntermediateCustomerIngredientDislikeMinAggregateOutputType | null
    _max: IntermediateCustomerIngredientDislikeMaxAggregateOutputType | null
  }

  type GetIntermediateCustomerIngredientDislikeGroupByPayload<T extends IntermediateCustomerIngredientDislikeGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateCustomerIngredientDislikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateCustomerIngredientDislikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateCustomerIngredientDislikeGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateCustomerIngredientDislikeGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateCustomerIngredientDislikeSelect = {
    productIngredient?: boolean | ProductIngredientArgs
    productIngredientId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateCustomerIngredientDislikeInclude = {
    productIngredient?: boolean | ProductIngredientArgs
    customer?: boolean | CustomersArgs
  }

  export type IntermediateCustomerIngredientDislikeGetPayload<
    S extends boolean | null | undefined | IntermediateCustomerIngredientDislikeArgs,
    U = keyof S
      > = S extends true
        ? IntermediateCustomerIngredientDislike
    : S extends undefined
    ? never
    : S extends IntermediateCustomerIngredientDislikeArgs | IntermediateCustomerIngredientDislikeFindManyArgs
    ?'include' extends U
    ? IntermediateCustomerIngredientDislike  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'productIngredient'
        ? ProductIngredientGetPayload<S['include'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateCustomerIngredientDislike ?IntermediateCustomerIngredientDislike [P]
  : 
          P extends 'productIngredient'
        ? ProductIngredientGetPayload<S['select'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : IntermediateCustomerIngredientDislike
  : IntermediateCustomerIngredientDislike


  type IntermediateCustomerIngredientDislikeCountArgs = Merge<
    Omit<IntermediateCustomerIngredientDislikeFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateCustomerIngredientDislikeCountAggregateInputType | true
    }
  >

  export interface IntermediateCustomerIngredientDislikeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateCustomerIngredientDislike that matches the filter.
     * @param {IntermediateCustomerIngredientDislikeFindUniqueArgs} args - Arguments to find a IntermediateCustomerIngredientDislike
     * @example
     * // Get one IntermediateCustomerIngredientDislike
     * const intermediateCustomerIngredientDislike = await prisma.intermediateCustomerIngredientDislike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateCustomerIngredientDislikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateCustomerIngredientDislikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateCustomerIngredientDislike'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislike>, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislikeGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislike | null >, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislikeGetPayload<T> | null >>

    /**
     * Find the first IntermediateCustomerIngredientDislike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerIngredientDislikeFindFirstArgs} args - Arguments to find a IntermediateCustomerIngredientDislike
     * @example
     * // Get one IntermediateCustomerIngredientDislike
     * const intermediateCustomerIngredientDislike = await prisma.intermediateCustomerIngredientDislike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateCustomerIngredientDislikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateCustomerIngredientDislikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateCustomerIngredientDislike'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislike>, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislikeGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislike | null >, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislikeGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateCustomerIngredientDislikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerIngredientDislikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateCustomerIngredientDislikes
     * const intermediateCustomerIngredientDislikes = await prisma.intermediateCustomerIngredientDislike.findMany()
     * 
     * // Get first 10 IntermediateCustomerIngredientDislikes
     * const intermediateCustomerIngredientDislikes = await prisma.intermediateCustomerIngredientDislike.findMany({ take: 10 })
     * 
     * // Only select the `productIngredientId`
     * const intermediateCustomerIngredientDislikeWithProductIngredientIdOnly = await prisma.intermediateCustomerIngredientDislike.findMany({ select: { productIngredientId: true } })
     * 
    **/
    findMany<T extends IntermediateCustomerIngredientDislikeFindManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerIngredientDislikeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerIngredientDislike>>, PrismaPromise<Array<IntermediateCustomerIngredientDislikeGetPayload<T>>>>

    /**
     * Create a IntermediateCustomerIngredientDislike.
     * @param {IntermediateCustomerIngredientDislikeCreateArgs} args - Arguments to create a IntermediateCustomerIngredientDislike.
     * @example
     * // Create one IntermediateCustomerIngredientDislike
     * const IntermediateCustomerIngredientDislike = await prisma.intermediateCustomerIngredientDislike.create({
     *   data: {
     *     // ... data to create a IntermediateCustomerIngredientDislike
     *   }
     * })
     * 
    **/
    create<T extends IntermediateCustomerIngredientDislikeCreateArgs>(
      args: SelectSubset<T, IntermediateCustomerIngredientDislikeCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislike>, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislikeGetPayload<T>>>

    /**
     * Create many IntermediateCustomerIngredientDislikes.
     *     @param {IntermediateCustomerIngredientDislikeCreateManyArgs} args - Arguments to create many IntermediateCustomerIngredientDislikes.
     *     @example
     *     // Create many IntermediateCustomerIngredientDislikes
     *     const intermediateCustomerIngredientDislike = await prisma.intermediateCustomerIngredientDislike.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateCustomerIngredientDislikeCreateManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerIngredientDislikeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateCustomerIngredientDislike.
     * @param {IntermediateCustomerIngredientDislikeDeleteArgs} args - Arguments to delete one IntermediateCustomerIngredientDislike.
     * @example
     * // Delete one IntermediateCustomerIngredientDislike
     * const IntermediateCustomerIngredientDislike = await prisma.intermediateCustomerIngredientDislike.delete({
     *   where: {
     *     // ... filter to delete one IntermediateCustomerIngredientDislike
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateCustomerIngredientDislikeDeleteArgs>(
      args: SelectSubset<T, IntermediateCustomerIngredientDislikeDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislike>, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislikeGetPayload<T>>>

    /**
     * Update one IntermediateCustomerIngredientDislike.
     * @param {IntermediateCustomerIngredientDislikeUpdateArgs} args - Arguments to update one IntermediateCustomerIngredientDislike.
     * @example
     * // Update one IntermediateCustomerIngredientDislike
     * const intermediateCustomerIngredientDislike = await prisma.intermediateCustomerIngredientDislike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateCustomerIngredientDislikeUpdateArgs>(
      args: SelectSubset<T, IntermediateCustomerIngredientDislikeUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislike>, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislikeGetPayload<T>>>

    /**
     * Delete zero or more IntermediateCustomerIngredientDislikes.
     * @param {IntermediateCustomerIngredientDislikeDeleteManyArgs} args - Arguments to filter IntermediateCustomerIngredientDislikes to delete.
     * @example
     * // Delete a few IntermediateCustomerIngredientDislikes
     * const { count } = await prisma.intermediateCustomerIngredientDislike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateCustomerIngredientDislikeDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerIngredientDislikeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateCustomerIngredientDislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerIngredientDislikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateCustomerIngredientDislikes
     * const intermediateCustomerIngredientDislike = await prisma.intermediateCustomerIngredientDislike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateCustomerIngredientDislikeUpdateManyArgs>(
      args: SelectSubset<T, IntermediateCustomerIngredientDislikeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateCustomerIngredientDislike.
     * @param {IntermediateCustomerIngredientDislikeUpsertArgs} args - Arguments to update or create a IntermediateCustomerIngredientDislike.
     * @example
     * // Update or create a IntermediateCustomerIngredientDislike
     * const intermediateCustomerIngredientDislike = await prisma.intermediateCustomerIngredientDislike.upsert({
     *   create: {
     *     // ... data to create a IntermediateCustomerIngredientDislike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateCustomerIngredientDislike we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateCustomerIngredientDislikeUpsertArgs>(
      args: SelectSubset<T, IntermediateCustomerIngredientDislikeUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislike>, Prisma__IntermediateCustomerIngredientDislikeClient<IntermediateCustomerIngredientDislikeGetPayload<T>>>

    /**
     * Count the number of IntermediateCustomerIngredientDislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerIngredientDislikeCountArgs} args - Arguments to filter IntermediateCustomerIngredientDislikes to count.
     * @example
     * // Count the number of IntermediateCustomerIngredientDislikes
     * const count = await prisma.intermediateCustomerIngredientDislike.count({
     *   where: {
     *     // ... the filter for the IntermediateCustomerIngredientDislikes we want to count
     *   }
     * })
    **/
    count<T extends IntermediateCustomerIngredientDislikeCountArgs>(
      args?: Subset<T, IntermediateCustomerIngredientDislikeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateCustomerIngredientDislikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateCustomerIngredientDislike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerIngredientDislikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateCustomerIngredientDislikeAggregateArgs>(args: Subset<T, IntermediateCustomerIngredientDislikeAggregateArgs>): PrismaPromise<GetIntermediateCustomerIngredientDislikeAggregateType<T>>

    /**
     * Group by IntermediateCustomerIngredientDislike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerIngredientDislikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateCustomerIngredientDislikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateCustomerIngredientDislikeGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateCustomerIngredientDislikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateCustomerIngredientDislikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateCustomerIngredientDislikeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateCustomerIngredientDislike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateCustomerIngredientDislikeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    productIngredient<T extends ProductIngredientArgs = {}>(args?: Subset<T, ProductIngredientArgs>): CheckSelect<T, Prisma__ProductIngredientClient<ProductIngredient | null >, Prisma__ProductIngredientClient<ProductIngredientGetPayload<T> | null >>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateCustomerIngredientDislike findUnique
   */
  export type IntermediateCustomerIngredientDislikeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerIngredientDislike
     * 
    **/
    select?: IntermediateCustomerIngredientDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerIngredientDislikeInclude | null
    /**
     * Throw an Error if a IntermediateCustomerIngredientDislike can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerIngredientDislike to fetch.
     * 
    **/
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
  }


  /**
   * IntermediateCustomerIngredientDislike findFirst
   */
  export type IntermediateCustomerIngredientDislikeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerIngredientDislike
     * 
    **/
    select?: IntermediateCustomerIngredientDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerIngredientDislikeInclude | null
    /**
     * Throw an Error if a IntermediateCustomerIngredientDislike can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerIngredientDislike to fetch.
     * 
    **/
    where?: IntermediateCustomerIngredientDislikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerIngredientDislikes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerIngredientDislikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateCustomerIngredientDislikes.
     * 
    **/
    cursor?: IntermediateCustomerIngredientDislikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerIngredientDislikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerIngredientDislikes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateCustomerIngredientDislikes.
     * 
    **/
    distinct?: Enumerable<IntermediateCustomerIngredientDislikeScalarFieldEnum>
  }


  /**
   * IntermediateCustomerIngredientDislike findMany
   */
  export type IntermediateCustomerIngredientDislikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerIngredientDislike
     * 
    **/
    select?: IntermediateCustomerIngredientDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerIngredientDislikeInclude | null
    /**
     * Filter, which IntermediateCustomerIngredientDislikes to fetch.
     * 
    **/
    where?: IntermediateCustomerIngredientDislikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerIngredientDislikes to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerIngredientDislikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateCustomerIngredientDislikes.
     * 
    **/
    cursor?: IntermediateCustomerIngredientDislikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerIngredientDislikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerIngredientDislikes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateCustomerIngredientDislikeScalarFieldEnum>
  }


  /**
   * IntermediateCustomerIngredientDislike create
   */
  export type IntermediateCustomerIngredientDislikeCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerIngredientDislike
     * 
    **/
    select?: IntermediateCustomerIngredientDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerIngredientDislikeInclude | null
    /**
     * The data needed to create a IntermediateCustomerIngredientDislike.
     * 
    **/
    data: XOR<IntermediateCustomerIngredientDislikeCreateInput, IntermediateCustomerIngredientDislikeUncheckedCreateInput>
  }


  /**
   * IntermediateCustomerIngredientDislike createMany
   */
  export type IntermediateCustomerIngredientDislikeCreateManyArgs = {
    data: Enumerable<IntermediateCustomerIngredientDislikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateCustomerIngredientDislike update
   */
  export type IntermediateCustomerIngredientDislikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerIngredientDislike
     * 
    **/
    select?: IntermediateCustomerIngredientDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerIngredientDislikeInclude | null
    /**
     * The data needed to update a IntermediateCustomerIngredientDislike.
     * 
    **/
    data: XOR<IntermediateCustomerIngredientDislikeUpdateInput, IntermediateCustomerIngredientDislikeUncheckedUpdateInput>
    /**
     * Choose, which IntermediateCustomerIngredientDislike to update.
     * 
    **/
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
  }


  /**
   * IntermediateCustomerIngredientDislike updateMany
   */
  export type IntermediateCustomerIngredientDislikeUpdateManyArgs = {
    data: XOR<IntermediateCustomerIngredientDislikeUpdateManyMutationInput, IntermediateCustomerIngredientDislikeUncheckedUpdateManyInput>
    where?: IntermediateCustomerIngredientDislikeWhereInput
  }


  /**
   * IntermediateCustomerIngredientDislike upsert
   */
  export type IntermediateCustomerIngredientDislikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerIngredientDislike
     * 
    **/
    select?: IntermediateCustomerIngredientDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerIngredientDislikeInclude | null
    /**
     * The filter to search for the IntermediateCustomerIngredientDislike to update in case it exists.
     * 
    **/
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
    /**
     * In case the IntermediateCustomerIngredientDislike found by the `where` argument doesn't exist, create a new IntermediateCustomerIngredientDislike with this data.
     * 
    **/
    create: XOR<IntermediateCustomerIngredientDislikeCreateInput, IntermediateCustomerIngredientDislikeUncheckedCreateInput>
    /**
     * In case the IntermediateCustomerIngredientDislike was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateCustomerIngredientDislikeUpdateInput, IntermediateCustomerIngredientDislikeUncheckedUpdateInput>
  }


  /**
   * IntermediateCustomerIngredientDislike delete
   */
  export type IntermediateCustomerIngredientDislikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerIngredientDislike
     * 
    **/
    select?: IntermediateCustomerIngredientDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerIngredientDislikeInclude | null
    /**
     * Filter which IntermediateCustomerIngredientDislike to delete.
     * 
    **/
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
  }


  /**
   * IntermediateCustomerIngredientDislike deleteMany
   */
  export type IntermediateCustomerIngredientDislikeDeleteManyArgs = {
    where?: IntermediateCustomerIngredientDislikeWhereInput
  }


  /**
   * IntermediateCustomerIngredientDislike without action
   */
  export type IntermediateCustomerIngredientDislikeArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerIngredientDislike
     * 
    **/
    select?: IntermediateCustomerIngredientDislikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerIngredientDislikeInclude | null
  }



  /**
   * Model IntermediateProductAllergen
   */


  export type AggregateIntermediateProductAllergen = {
    _count: IntermediateProductAllergenCountAggregateOutputType | null
    _avg: IntermediateProductAllergenAvgAggregateOutputType | null
    _sum: IntermediateProductAllergenSumAggregateOutputType | null
    _min: IntermediateProductAllergenMinAggregateOutputType | null
    _max: IntermediateProductAllergenMaxAggregateOutputType | null
  }

  export type IntermediateProductAllergenAvgAggregateOutputType = {
    productId: number | null
    productAllergenId: number | null
  }

  export type IntermediateProductAllergenSumAggregateOutputType = {
    productId: number | null
    productAllergenId: number | null
  }

  export type IntermediateProductAllergenMinAggregateOutputType = {
    productId: number | null
    productAllergenId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateProductAllergenMaxAggregateOutputType = {
    productId: number | null
    productAllergenId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateProductAllergenCountAggregateOutputType = {
    productId: number
    productAllergenId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateProductAllergenAvgAggregateInputType = {
    productId?: true
    productAllergenId?: true
  }

  export type IntermediateProductAllergenSumAggregateInputType = {
    productId?: true
    productAllergenId?: true
  }

  export type IntermediateProductAllergenMinAggregateInputType = {
    productId?: true
    productAllergenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateProductAllergenMaxAggregateInputType = {
    productId?: true
    productAllergenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateProductAllergenCountAggregateInputType = {
    productId?: true
    productAllergenId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateProductAllergenAggregateArgs = {
    /**
     * Filter which IntermediateProductAllergen to aggregate.
     * 
    **/
    where?: IntermediateProductAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateProductAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductAllergens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateProductAllergens
    **/
    _count?: true | IntermediateProductAllergenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateProductAllergenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateProductAllergenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateProductAllergenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateProductAllergenMaxAggregateInputType
  }

  export type GetIntermediateProductAllergenAggregateType<T extends IntermediateProductAllergenAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateProductAllergen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateProductAllergen[P]>
      : GetScalarType<T[P], AggregateIntermediateProductAllergen[P]>
  }




  export type IntermediateProductAllergenGroupByArgs = {
    where?: IntermediateProductAllergenWhereInput
    orderBy?: Enumerable<IntermediateProductAllergenOrderByWithAggregationInput>
    by: Array<IntermediateProductAllergenScalarFieldEnum>
    having?: IntermediateProductAllergenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateProductAllergenCountAggregateInputType | true
    _avg?: IntermediateProductAllergenAvgAggregateInputType
    _sum?: IntermediateProductAllergenSumAggregateInputType
    _min?: IntermediateProductAllergenMinAggregateInputType
    _max?: IntermediateProductAllergenMaxAggregateInputType
  }


  export type IntermediateProductAllergenGroupByOutputType = {
    productId: number
    productAllergenId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateProductAllergenCountAggregateOutputType | null
    _avg: IntermediateProductAllergenAvgAggregateOutputType | null
    _sum: IntermediateProductAllergenSumAggregateOutputType | null
    _min: IntermediateProductAllergenMinAggregateOutputType | null
    _max: IntermediateProductAllergenMaxAggregateOutputType | null
  }

  type GetIntermediateProductAllergenGroupByPayload<T extends IntermediateProductAllergenGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateProductAllergenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateProductAllergenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateProductAllergenGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateProductAllergenGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateProductAllergenSelect = {
    product?: boolean | ProductArgs
    productId?: boolean
    productAllergen?: boolean | ProductAllergenArgs
    productAllergenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateProductAllergenInclude = {
    product?: boolean | ProductArgs
    productAllergen?: boolean | ProductAllergenArgs
  }

  export type IntermediateProductAllergenGetPayload<
    S extends boolean | null | undefined | IntermediateProductAllergenArgs,
    U = keyof S
      > = S extends true
        ? IntermediateProductAllergen
    : S extends undefined
    ? never
    : S extends IntermediateProductAllergenArgs | IntermediateProductAllergenFindManyArgs
    ?'include' extends U
    ? IntermediateProductAllergen  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> :
        P extends 'productAllergen'
        ? ProductAllergenGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateProductAllergen ?IntermediateProductAllergen [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> :
        P extends 'productAllergen'
        ? ProductAllergenGetPayload<S['select'][P]> : never
  } 
    : IntermediateProductAllergen
  : IntermediateProductAllergen


  type IntermediateProductAllergenCountArgs = Merge<
    Omit<IntermediateProductAllergenFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateProductAllergenCountAggregateInputType | true
    }
  >

  export interface IntermediateProductAllergenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateProductAllergen that matches the filter.
     * @param {IntermediateProductAllergenFindUniqueArgs} args - Arguments to find a IntermediateProductAllergen
     * @example
     * // Get one IntermediateProductAllergen
     * const intermediateProductAllergen = await prisma.intermediateProductAllergen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateProductAllergenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateProductAllergenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateProductAllergen'> extends True ? CheckSelect<T, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergen>, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergenGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergen | null >, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergenGetPayload<T> | null >>

    /**
     * Find the first IntermediateProductAllergen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductAllergenFindFirstArgs} args - Arguments to find a IntermediateProductAllergen
     * @example
     * // Get one IntermediateProductAllergen
     * const intermediateProductAllergen = await prisma.intermediateProductAllergen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateProductAllergenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateProductAllergenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateProductAllergen'> extends True ? CheckSelect<T, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergen>, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergenGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergen | null >, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergenGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateProductAllergens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductAllergenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateProductAllergens
     * const intermediateProductAllergens = await prisma.intermediateProductAllergen.findMany()
     * 
     * // Get first 10 IntermediateProductAllergens
     * const intermediateProductAllergens = await prisma.intermediateProductAllergen.findMany({ take: 10 })
     * 
     * // Only select the `productId`
     * const intermediateProductAllergenWithProductIdOnly = await prisma.intermediateProductAllergen.findMany({ select: { productId: true } })
     * 
    **/
    findMany<T extends IntermediateProductAllergenFindManyArgs>(
      args?: SelectSubset<T, IntermediateProductAllergenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateProductAllergen>>, PrismaPromise<Array<IntermediateProductAllergenGetPayload<T>>>>

    /**
     * Create a IntermediateProductAllergen.
     * @param {IntermediateProductAllergenCreateArgs} args - Arguments to create a IntermediateProductAllergen.
     * @example
     * // Create one IntermediateProductAllergen
     * const IntermediateProductAllergen = await prisma.intermediateProductAllergen.create({
     *   data: {
     *     // ... data to create a IntermediateProductAllergen
     *   }
     * })
     * 
    **/
    create<T extends IntermediateProductAllergenCreateArgs>(
      args: SelectSubset<T, IntermediateProductAllergenCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergen>, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergenGetPayload<T>>>

    /**
     * Create many IntermediateProductAllergens.
     *     @param {IntermediateProductAllergenCreateManyArgs} args - Arguments to create many IntermediateProductAllergens.
     *     @example
     *     // Create many IntermediateProductAllergens
     *     const intermediateProductAllergen = await prisma.intermediateProductAllergen.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateProductAllergenCreateManyArgs>(
      args?: SelectSubset<T, IntermediateProductAllergenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateProductAllergen.
     * @param {IntermediateProductAllergenDeleteArgs} args - Arguments to delete one IntermediateProductAllergen.
     * @example
     * // Delete one IntermediateProductAllergen
     * const IntermediateProductAllergen = await prisma.intermediateProductAllergen.delete({
     *   where: {
     *     // ... filter to delete one IntermediateProductAllergen
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateProductAllergenDeleteArgs>(
      args: SelectSubset<T, IntermediateProductAllergenDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergen>, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergenGetPayload<T>>>

    /**
     * Update one IntermediateProductAllergen.
     * @param {IntermediateProductAllergenUpdateArgs} args - Arguments to update one IntermediateProductAllergen.
     * @example
     * // Update one IntermediateProductAllergen
     * const intermediateProductAllergen = await prisma.intermediateProductAllergen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateProductAllergenUpdateArgs>(
      args: SelectSubset<T, IntermediateProductAllergenUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergen>, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergenGetPayload<T>>>

    /**
     * Delete zero or more IntermediateProductAllergens.
     * @param {IntermediateProductAllergenDeleteManyArgs} args - Arguments to filter IntermediateProductAllergens to delete.
     * @example
     * // Delete a few IntermediateProductAllergens
     * const { count } = await prisma.intermediateProductAllergen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateProductAllergenDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateProductAllergenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateProductAllergens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductAllergenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateProductAllergens
     * const intermediateProductAllergen = await prisma.intermediateProductAllergen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateProductAllergenUpdateManyArgs>(
      args: SelectSubset<T, IntermediateProductAllergenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateProductAllergen.
     * @param {IntermediateProductAllergenUpsertArgs} args - Arguments to update or create a IntermediateProductAllergen.
     * @example
     * // Update or create a IntermediateProductAllergen
     * const intermediateProductAllergen = await prisma.intermediateProductAllergen.upsert({
     *   create: {
     *     // ... data to create a IntermediateProductAllergen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateProductAllergen we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateProductAllergenUpsertArgs>(
      args: SelectSubset<T, IntermediateProductAllergenUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergen>, Prisma__IntermediateProductAllergenClient<IntermediateProductAllergenGetPayload<T>>>

    /**
     * Count the number of IntermediateProductAllergens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductAllergenCountArgs} args - Arguments to filter IntermediateProductAllergens to count.
     * @example
     * // Count the number of IntermediateProductAllergens
     * const count = await prisma.intermediateProductAllergen.count({
     *   where: {
     *     // ... the filter for the IntermediateProductAllergens we want to count
     *   }
     * })
    **/
    count<T extends IntermediateProductAllergenCountArgs>(
      args?: Subset<T, IntermediateProductAllergenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateProductAllergenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateProductAllergen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductAllergenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateProductAllergenAggregateArgs>(args: Subset<T, IntermediateProductAllergenAggregateArgs>): PrismaPromise<GetIntermediateProductAllergenAggregateType<T>>

    /**
     * Group by IntermediateProductAllergen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateProductAllergenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateProductAllergenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateProductAllergenGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateProductAllergenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateProductAllergenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateProductAllergenGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateProductAllergen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateProductAllergenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    productAllergen<T extends ProductAllergenArgs = {}>(args?: Subset<T, ProductAllergenArgs>): CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen | null >, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateProductAllergen findUnique
   */
  export type IntermediateProductAllergenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductAllergen
     * 
    **/
    select?: IntermediateProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductAllergenInclude | null
    /**
     * Throw an Error if a IntermediateProductAllergen can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateProductAllergen to fetch.
     * 
    **/
    where: IntermediateProductAllergenWhereUniqueInput
  }


  /**
   * IntermediateProductAllergen findFirst
   */
  export type IntermediateProductAllergenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductAllergen
     * 
    **/
    select?: IntermediateProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductAllergenInclude | null
    /**
     * Throw an Error if a IntermediateProductAllergen can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateProductAllergen to fetch.
     * 
    **/
    where?: IntermediateProductAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateProductAllergens.
     * 
    **/
    cursor?: IntermediateProductAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductAllergens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateProductAllergens.
     * 
    **/
    distinct?: Enumerable<IntermediateProductAllergenScalarFieldEnum>
  }


  /**
   * IntermediateProductAllergen findMany
   */
  export type IntermediateProductAllergenFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductAllergen
     * 
    **/
    select?: IntermediateProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductAllergenInclude | null
    /**
     * Filter, which IntermediateProductAllergens to fetch.
     * 
    **/
    where?: IntermediateProductAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateProductAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateProductAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateProductAllergens.
     * 
    **/
    cursor?: IntermediateProductAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateProductAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateProductAllergens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateProductAllergenScalarFieldEnum>
  }


  /**
   * IntermediateProductAllergen create
   */
  export type IntermediateProductAllergenCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductAllergen
     * 
    **/
    select?: IntermediateProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductAllergenInclude | null
    /**
     * The data needed to create a IntermediateProductAllergen.
     * 
    **/
    data: XOR<IntermediateProductAllergenCreateInput, IntermediateProductAllergenUncheckedCreateInput>
  }


  /**
   * IntermediateProductAllergen createMany
   */
  export type IntermediateProductAllergenCreateManyArgs = {
    data: Enumerable<IntermediateProductAllergenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateProductAllergen update
   */
  export type IntermediateProductAllergenUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductAllergen
     * 
    **/
    select?: IntermediateProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductAllergenInclude | null
    /**
     * The data needed to update a IntermediateProductAllergen.
     * 
    **/
    data: XOR<IntermediateProductAllergenUpdateInput, IntermediateProductAllergenUncheckedUpdateInput>
    /**
     * Choose, which IntermediateProductAllergen to update.
     * 
    **/
    where: IntermediateProductAllergenWhereUniqueInput
  }


  /**
   * IntermediateProductAllergen updateMany
   */
  export type IntermediateProductAllergenUpdateManyArgs = {
    data: XOR<IntermediateProductAllergenUpdateManyMutationInput, IntermediateProductAllergenUncheckedUpdateManyInput>
    where?: IntermediateProductAllergenWhereInput
  }


  /**
   * IntermediateProductAllergen upsert
   */
  export type IntermediateProductAllergenUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductAllergen
     * 
    **/
    select?: IntermediateProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductAllergenInclude | null
    /**
     * The filter to search for the IntermediateProductAllergen to update in case it exists.
     * 
    **/
    where: IntermediateProductAllergenWhereUniqueInput
    /**
     * In case the IntermediateProductAllergen found by the `where` argument doesn't exist, create a new IntermediateProductAllergen with this data.
     * 
    **/
    create: XOR<IntermediateProductAllergenCreateInput, IntermediateProductAllergenUncheckedCreateInput>
    /**
     * In case the IntermediateProductAllergen was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateProductAllergenUpdateInput, IntermediateProductAllergenUncheckedUpdateInput>
  }


  /**
   * IntermediateProductAllergen delete
   */
  export type IntermediateProductAllergenDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductAllergen
     * 
    **/
    select?: IntermediateProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductAllergenInclude | null
    /**
     * Filter which IntermediateProductAllergen to delete.
     * 
    **/
    where: IntermediateProductAllergenWhereUniqueInput
  }


  /**
   * IntermediateProductAllergen deleteMany
   */
  export type IntermediateProductAllergenDeleteManyArgs = {
    where?: IntermediateProductAllergenWhereInput
  }


  /**
   * IntermediateProductAllergen without action
   */
  export type IntermediateProductAllergenArgs = {
    /**
     * Select specific fields to fetch from the IntermediateProductAllergen
     * 
    **/
    select?: IntermediateProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateProductAllergenInclude | null
  }



  /**
   * Model ProductAllergen
   */


  export type AggregateProductAllergen = {
    _count: ProductAllergenCountAggregateOutputType | null
    _avg: ProductAllergenAvgAggregateOutputType | null
    _sum: ProductAllergenSumAggregateOutputType | null
    _min: ProductAllergenMinAggregateOutputType | null
    _max: ProductAllergenMaxAggregateOutputType | null
  }

  export type ProductAllergenAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductAllergenSumAggregateOutputType = {
    id: number | null
  }

  export type ProductAllergenMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductAllergenMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductAllergenCountAggregateOutputType = {
    id: number
    label: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAllergenAvgAggregateInputType = {
    id?: true
  }

  export type ProductAllergenSumAggregateInputType = {
    id?: true
  }

  export type ProductAllergenMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductAllergenMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductAllergenCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAllergenAggregateArgs = {
    /**
     * Filter which ProductAllergen to aggregate.
     * 
    **/
    where?: ProductAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAllergens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAllergens
    **/
    _count?: true | ProductAllergenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAllergenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductAllergenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductAllergenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductAllergenMaxAggregateInputType
  }

  export type GetProductAllergenAggregateType<T extends ProductAllergenAggregateArgs> = {
        [P in keyof T & keyof AggregateProductAllergen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAllergen[P]>
      : GetScalarType<T[P], AggregateProductAllergen[P]>
  }




  export type ProductAllergenGroupByArgs = {
    where?: ProductAllergenWhereInput
    orderBy?: Enumerable<ProductAllergenOrderByWithAggregationInput>
    by: Array<ProductAllergenScalarFieldEnum>
    having?: ProductAllergenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductAllergenCountAggregateInputType | true
    _avg?: ProductAllergenAvgAggregateInputType
    _sum?: ProductAllergenSumAggregateInputType
    _min?: ProductAllergenMinAggregateInputType
    _max?: ProductAllergenMaxAggregateInputType
  }


  export type ProductAllergenGroupByOutputType = {
    id: number
    label: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ProductAllergenCountAggregateOutputType | null
    _avg: ProductAllergenAvgAggregateOutputType | null
    _sum: ProductAllergenSumAggregateOutputType | null
    _min: ProductAllergenMinAggregateOutputType | null
    _max: ProductAllergenMaxAggregateOutputType | null
  }

  type GetProductAllergenGroupByPayload<T extends ProductAllergenGroupByArgs> = Promise<
    Array<
      PickArray<ProductAllergenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductAllergenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductAllergenGroupByOutputType[P]>
            : GetScalarType<T[P], ProductAllergenGroupByOutputType[P]>
        }
      >
    >


  export type ProductAllergenSelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    intermediateProductAllergens?: boolean | IntermediateProductAllergenFindManyArgs
    intermediateCustomerAllergens?: boolean | IntermediateCustomerAllergenFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductAllergenCountOutputTypeArgs
  }

  export type ProductAllergenInclude = {
    intermediateProductAllergens?: boolean | IntermediateProductAllergenFindManyArgs
    intermediateCustomerAllergens?: boolean | IntermediateCustomerAllergenFindManyArgs
    _count?: boolean | ProductAllergenCountOutputTypeArgs
  }

  export type ProductAllergenGetPayload<
    S extends boolean | null | undefined | ProductAllergenArgs,
    U = keyof S
      > = S extends true
        ? ProductAllergen
    : S extends undefined
    ? never
    : S extends ProductAllergenArgs | ProductAllergenFindManyArgs
    ?'include' extends U
    ? ProductAllergen  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateProductAllergens'
        ? Array < IntermediateProductAllergenGetPayload<S['include'][P]>>  :
        P extends 'intermediateCustomerAllergens'
        ? Array < IntermediateCustomerAllergenGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductAllergenCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductAllergen ?ProductAllergen [P]
  : 
          P extends 'intermediateProductAllergens'
        ? Array < IntermediateProductAllergenGetPayload<S['select'][P]>>  :
        P extends 'intermediateCustomerAllergens'
        ? Array < IntermediateCustomerAllergenGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductAllergenCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductAllergen
  : ProductAllergen


  type ProductAllergenCountArgs = Merge<
    Omit<ProductAllergenFindManyArgs, 'select' | 'include'> & {
      select?: ProductAllergenCountAggregateInputType | true
    }
  >

  export interface ProductAllergenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductAllergen that matches the filter.
     * @param {ProductAllergenFindUniqueArgs} args - Arguments to find a ProductAllergen
     * @example
     * // Get one ProductAllergen
     * const productAllergen = await prisma.productAllergen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductAllergenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductAllergenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductAllergen'> extends True ? CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen>, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T>>> : CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen | null >, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T> | null >>

    /**
     * Find the first ProductAllergen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllergenFindFirstArgs} args - Arguments to find a ProductAllergen
     * @example
     * // Get one ProductAllergen
     * const productAllergen = await prisma.productAllergen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductAllergenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductAllergenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductAllergen'> extends True ? CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen>, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T>>> : CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen | null >, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T> | null >>

    /**
     * Find zero or more ProductAllergens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllergenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAllergens
     * const productAllergens = await prisma.productAllergen.findMany()
     * 
     * // Get first 10 ProductAllergens
     * const productAllergens = await prisma.productAllergen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAllergenWithIdOnly = await prisma.productAllergen.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductAllergenFindManyArgs>(
      args?: SelectSubset<T, ProductAllergenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductAllergen>>, PrismaPromise<Array<ProductAllergenGetPayload<T>>>>

    /**
     * Create a ProductAllergen.
     * @param {ProductAllergenCreateArgs} args - Arguments to create a ProductAllergen.
     * @example
     * // Create one ProductAllergen
     * const ProductAllergen = await prisma.productAllergen.create({
     *   data: {
     *     // ... data to create a ProductAllergen
     *   }
     * })
     * 
    **/
    create<T extends ProductAllergenCreateArgs>(
      args: SelectSubset<T, ProductAllergenCreateArgs>
    ): CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen>, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T>>>

    /**
     * Create many ProductAllergens.
     *     @param {ProductAllergenCreateManyArgs} args - Arguments to create many ProductAllergens.
     *     @example
     *     // Create many ProductAllergens
     *     const productAllergen = await prisma.productAllergen.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductAllergenCreateManyArgs>(
      args?: SelectSubset<T, ProductAllergenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductAllergen.
     * @param {ProductAllergenDeleteArgs} args - Arguments to delete one ProductAllergen.
     * @example
     * // Delete one ProductAllergen
     * const ProductAllergen = await prisma.productAllergen.delete({
     *   where: {
     *     // ... filter to delete one ProductAllergen
     *   }
     * })
     * 
    **/
    delete<T extends ProductAllergenDeleteArgs>(
      args: SelectSubset<T, ProductAllergenDeleteArgs>
    ): CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen>, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T>>>

    /**
     * Update one ProductAllergen.
     * @param {ProductAllergenUpdateArgs} args - Arguments to update one ProductAllergen.
     * @example
     * // Update one ProductAllergen
     * const productAllergen = await prisma.productAllergen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductAllergenUpdateArgs>(
      args: SelectSubset<T, ProductAllergenUpdateArgs>
    ): CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen>, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T>>>

    /**
     * Delete zero or more ProductAllergens.
     * @param {ProductAllergenDeleteManyArgs} args - Arguments to filter ProductAllergens to delete.
     * @example
     * // Delete a few ProductAllergens
     * const { count } = await prisma.productAllergen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductAllergenDeleteManyArgs>(
      args?: SelectSubset<T, ProductAllergenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAllergens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllergenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAllergens
     * const productAllergen = await prisma.productAllergen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductAllergenUpdateManyArgs>(
      args: SelectSubset<T, ProductAllergenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAllergen.
     * @param {ProductAllergenUpsertArgs} args - Arguments to update or create a ProductAllergen.
     * @example
     * // Update or create a ProductAllergen
     * const productAllergen = await prisma.productAllergen.upsert({
     *   create: {
     *     // ... data to create a ProductAllergen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAllergen we want to update
     *   }
     * })
    **/
    upsert<T extends ProductAllergenUpsertArgs>(
      args: SelectSubset<T, ProductAllergenUpsertArgs>
    ): CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen>, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T>>>

    /**
     * Count the number of ProductAllergens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllergenCountArgs} args - Arguments to filter ProductAllergens to count.
     * @example
     * // Count the number of ProductAllergens
     * const count = await prisma.productAllergen.count({
     *   where: {
     *     // ... the filter for the ProductAllergens we want to count
     *   }
     * })
    **/
    count<T extends ProductAllergenCountArgs>(
      args?: Subset<T, ProductAllergenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAllergenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAllergen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllergenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAllergenAggregateArgs>(args: Subset<T, ProductAllergenAggregateArgs>): PrismaPromise<GetProductAllergenAggregateType<T>>

    /**
     * Group by ProductAllergen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllergenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductAllergenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductAllergenGroupByArgs['orderBy'] }
        : { orderBy?: ProductAllergenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductAllergenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductAllergenGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAllergen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductAllergenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateProductAllergens<T extends IntermediateProductAllergenFindManyArgs = {}>(args?: Subset<T, IntermediateProductAllergenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateProductAllergen>>, PrismaPromise<Array<IntermediateProductAllergenGetPayload<T>>>>;

    intermediateCustomerAllergens<T extends IntermediateCustomerAllergenFindManyArgs = {}>(args?: Subset<T, IntermediateCustomerAllergenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerAllergen>>, PrismaPromise<Array<IntermediateCustomerAllergenGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductAllergen findUnique
   */
  export type ProductAllergenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergen
     * 
    **/
    select?: ProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAllergenInclude | null
    /**
     * Throw an Error if a ProductAllergen can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAllergen to fetch.
     * 
    **/
    where: ProductAllergenWhereUniqueInput
  }


  /**
   * ProductAllergen findFirst
   */
  export type ProductAllergenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergen
     * 
    **/
    select?: ProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAllergenInclude | null
    /**
     * Throw an Error if a ProductAllergen can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductAllergen to fetch.
     * 
    **/
    where?: ProductAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAllergens.
     * 
    **/
    cursor?: ProductAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAllergens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAllergens.
     * 
    **/
    distinct?: Enumerable<ProductAllergenScalarFieldEnum>
  }


  /**
   * ProductAllergen findMany
   */
  export type ProductAllergenFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergen
     * 
    **/
    select?: ProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAllergenInclude | null
    /**
     * Filter, which ProductAllergens to fetch.
     * 
    **/
    where?: ProductAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAllergens.
     * 
    **/
    cursor?: ProductAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAllergens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductAllergenScalarFieldEnum>
  }


  /**
   * ProductAllergen create
   */
  export type ProductAllergenCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergen
     * 
    **/
    select?: ProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAllergenInclude | null
    /**
     * The data needed to create a ProductAllergen.
     * 
    **/
    data: XOR<ProductAllergenCreateInput, ProductAllergenUncheckedCreateInput>
  }


  /**
   * ProductAllergen createMany
   */
  export type ProductAllergenCreateManyArgs = {
    data: Enumerable<ProductAllergenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductAllergen update
   */
  export type ProductAllergenUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergen
     * 
    **/
    select?: ProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAllergenInclude | null
    /**
     * The data needed to update a ProductAllergen.
     * 
    **/
    data: XOR<ProductAllergenUpdateInput, ProductAllergenUncheckedUpdateInput>
    /**
     * Choose, which ProductAllergen to update.
     * 
    **/
    where: ProductAllergenWhereUniqueInput
  }


  /**
   * ProductAllergen updateMany
   */
  export type ProductAllergenUpdateManyArgs = {
    data: XOR<ProductAllergenUpdateManyMutationInput, ProductAllergenUncheckedUpdateManyInput>
    where?: ProductAllergenWhereInput
  }


  /**
   * ProductAllergen upsert
   */
  export type ProductAllergenUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergen
     * 
    **/
    select?: ProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAllergenInclude | null
    /**
     * The filter to search for the ProductAllergen to update in case it exists.
     * 
    **/
    where: ProductAllergenWhereUniqueInput
    /**
     * In case the ProductAllergen found by the `where` argument doesn't exist, create a new ProductAllergen with this data.
     * 
    **/
    create: XOR<ProductAllergenCreateInput, ProductAllergenUncheckedCreateInput>
    /**
     * In case the ProductAllergen was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductAllergenUpdateInput, ProductAllergenUncheckedUpdateInput>
  }


  /**
   * ProductAllergen delete
   */
  export type ProductAllergenDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergen
     * 
    **/
    select?: ProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAllergenInclude | null
    /**
     * Filter which ProductAllergen to delete.
     * 
    **/
    where: ProductAllergenWhereUniqueInput
  }


  /**
   * ProductAllergen deleteMany
   */
  export type ProductAllergenDeleteManyArgs = {
    where?: ProductAllergenWhereInput
  }


  /**
   * ProductAllergen without action
   */
  export type ProductAllergenArgs = {
    /**
     * Select specific fields to fetch from the ProductAllergen
     * 
    **/
    select?: ProductAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductAllergenInclude | null
  }



  /**
   * Model IntermediateCustomerAllergen
   */


  export type AggregateIntermediateCustomerAllergen = {
    _count: IntermediateCustomerAllergenCountAggregateOutputType | null
    _avg: IntermediateCustomerAllergenAvgAggregateOutputType | null
    _sum: IntermediateCustomerAllergenSumAggregateOutputType | null
    _min: IntermediateCustomerAllergenMinAggregateOutputType | null
    _max: IntermediateCustomerAllergenMaxAggregateOutputType | null
  }

  export type IntermediateCustomerAllergenAvgAggregateOutputType = {
    customerId: number | null
    productAllergenId: number | null
  }

  export type IntermediateCustomerAllergenSumAggregateOutputType = {
    customerId: number | null
    productAllergenId: number | null
  }

  export type IntermediateCustomerAllergenMinAggregateOutputType = {
    customerId: number | null
    productAllergenId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerAllergenMaxAggregateOutputType = {
    customerId: number | null
    productAllergenId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateCustomerAllergenCountAggregateOutputType = {
    customerId: number
    productAllergenId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateCustomerAllergenAvgAggregateInputType = {
    customerId?: true
    productAllergenId?: true
  }

  export type IntermediateCustomerAllergenSumAggregateInputType = {
    customerId?: true
    productAllergenId?: true
  }

  export type IntermediateCustomerAllergenMinAggregateInputType = {
    customerId?: true
    productAllergenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerAllergenMaxAggregateInputType = {
    customerId?: true
    productAllergenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateCustomerAllergenCountAggregateInputType = {
    customerId?: true
    productAllergenId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateCustomerAllergenAggregateArgs = {
    /**
     * Filter which IntermediateCustomerAllergen to aggregate.
     * 
    **/
    where?: IntermediateCustomerAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateCustomerAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerAllergens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateCustomerAllergens
    **/
    _count?: true | IntermediateCustomerAllergenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateCustomerAllergenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateCustomerAllergenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateCustomerAllergenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateCustomerAllergenMaxAggregateInputType
  }

  export type GetIntermediateCustomerAllergenAggregateType<T extends IntermediateCustomerAllergenAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateCustomerAllergen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateCustomerAllergen[P]>
      : GetScalarType<T[P], AggregateIntermediateCustomerAllergen[P]>
  }




  export type IntermediateCustomerAllergenGroupByArgs = {
    where?: IntermediateCustomerAllergenWhereInput
    orderBy?: Enumerable<IntermediateCustomerAllergenOrderByWithAggregationInput>
    by: Array<IntermediateCustomerAllergenScalarFieldEnum>
    having?: IntermediateCustomerAllergenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateCustomerAllergenCountAggregateInputType | true
    _avg?: IntermediateCustomerAllergenAvgAggregateInputType
    _sum?: IntermediateCustomerAllergenSumAggregateInputType
    _min?: IntermediateCustomerAllergenMinAggregateInputType
    _max?: IntermediateCustomerAllergenMaxAggregateInputType
  }


  export type IntermediateCustomerAllergenGroupByOutputType = {
    customerId: number
    productAllergenId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateCustomerAllergenCountAggregateOutputType | null
    _avg: IntermediateCustomerAllergenAvgAggregateOutputType | null
    _sum: IntermediateCustomerAllergenSumAggregateOutputType | null
    _min: IntermediateCustomerAllergenMinAggregateOutputType | null
    _max: IntermediateCustomerAllergenMaxAggregateOutputType | null
  }

  type GetIntermediateCustomerAllergenGroupByPayload<T extends IntermediateCustomerAllergenGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateCustomerAllergenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateCustomerAllergenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateCustomerAllergenGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateCustomerAllergenGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateCustomerAllergenSelect = {
    customer?: boolean | CustomersArgs
    customerId?: boolean
    productAllergen?: boolean | ProductAllergenArgs
    productAllergenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateCustomerAllergenInclude = {
    customer?: boolean | CustomersArgs
    productAllergen?: boolean | ProductAllergenArgs
  }

  export type IntermediateCustomerAllergenGetPayload<
    S extends boolean | null | undefined | IntermediateCustomerAllergenArgs,
    U = keyof S
      > = S extends true
        ? IntermediateCustomerAllergen
    : S extends undefined
    ? never
    : S extends IntermediateCustomerAllergenArgs | IntermediateCustomerAllergenFindManyArgs
    ?'include' extends U
    ? IntermediateCustomerAllergen  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> :
        P extends 'productAllergen'
        ? ProductAllergenGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateCustomerAllergen ?IntermediateCustomerAllergen [P]
  : 
          P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> :
        P extends 'productAllergen'
        ? ProductAllergenGetPayload<S['select'][P]> : never
  } 
    : IntermediateCustomerAllergen
  : IntermediateCustomerAllergen


  type IntermediateCustomerAllergenCountArgs = Merge<
    Omit<IntermediateCustomerAllergenFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateCustomerAllergenCountAggregateInputType | true
    }
  >

  export interface IntermediateCustomerAllergenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateCustomerAllergen that matches the filter.
     * @param {IntermediateCustomerAllergenFindUniqueArgs} args - Arguments to find a IntermediateCustomerAllergen
     * @example
     * // Get one IntermediateCustomerAllergen
     * const intermediateCustomerAllergen = await prisma.intermediateCustomerAllergen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateCustomerAllergenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateCustomerAllergenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateCustomerAllergen'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergen>, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergenGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergen | null >, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergenGetPayload<T> | null >>

    /**
     * Find the first IntermediateCustomerAllergen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerAllergenFindFirstArgs} args - Arguments to find a IntermediateCustomerAllergen
     * @example
     * // Get one IntermediateCustomerAllergen
     * const intermediateCustomerAllergen = await prisma.intermediateCustomerAllergen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateCustomerAllergenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateCustomerAllergenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateCustomerAllergen'> extends True ? CheckSelect<T, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergen>, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergenGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergen | null >, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergenGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateCustomerAllergens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerAllergenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateCustomerAllergens
     * const intermediateCustomerAllergens = await prisma.intermediateCustomerAllergen.findMany()
     * 
     * // Get first 10 IntermediateCustomerAllergens
     * const intermediateCustomerAllergens = await prisma.intermediateCustomerAllergen.findMany({ take: 10 })
     * 
     * // Only select the `customerId`
     * const intermediateCustomerAllergenWithCustomerIdOnly = await prisma.intermediateCustomerAllergen.findMany({ select: { customerId: true } })
     * 
    **/
    findMany<T extends IntermediateCustomerAllergenFindManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerAllergenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateCustomerAllergen>>, PrismaPromise<Array<IntermediateCustomerAllergenGetPayload<T>>>>

    /**
     * Create a IntermediateCustomerAllergen.
     * @param {IntermediateCustomerAllergenCreateArgs} args - Arguments to create a IntermediateCustomerAllergen.
     * @example
     * // Create one IntermediateCustomerAllergen
     * const IntermediateCustomerAllergen = await prisma.intermediateCustomerAllergen.create({
     *   data: {
     *     // ... data to create a IntermediateCustomerAllergen
     *   }
     * })
     * 
    **/
    create<T extends IntermediateCustomerAllergenCreateArgs>(
      args: SelectSubset<T, IntermediateCustomerAllergenCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergen>, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergenGetPayload<T>>>

    /**
     * Create many IntermediateCustomerAllergens.
     *     @param {IntermediateCustomerAllergenCreateManyArgs} args - Arguments to create many IntermediateCustomerAllergens.
     *     @example
     *     // Create many IntermediateCustomerAllergens
     *     const intermediateCustomerAllergen = await prisma.intermediateCustomerAllergen.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateCustomerAllergenCreateManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerAllergenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateCustomerAllergen.
     * @param {IntermediateCustomerAllergenDeleteArgs} args - Arguments to delete one IntermediateCustomerAllergen.
     * @example
     * // Delete one IntermediateCustomerAllergen
     * const IntermediateCustomerAllergen = await prisma.intermediateCustomerAllergen.delete({
     *   where: {
     *     // ... filter to delete one IntermediateCustomerAllergen
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateCustomerAllergenDeleteArgs>(
      args: SelectSubset<T, IntermediateCustomerAllergenDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergen>, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergenGetPayload<T>>>

    /**
     * Update one IntermediateCustomerAllergen.
     * @param {IntermediateCustomerAllergenUpdateArgs} args - Arguments to update one IntermediateCustomerAllergen.
     * @example
     * // Update one IntermediateCustomerAllergen
     * const intermediateCustomerAllergen = await prisma.intermediateCustomerAllergen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateCustomerAllergenUpdateArgs>(
      args: SelectSubset<T, IntermediateCustomerAllergenUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergen>, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergenGetPayload<T>>>

    /**
     * Delete zero or more IntermediateCustomerAllergens.
     * @param {IntermediateCustomerAllergenDeleteManyArgs} args - Arguments to filter IntermediateCustomerAllergens to delete.
     * @example
     * // Delete a few IntermediateCustomerAllergens
     * const { count } = await prisma.intermediateCustomerAllergen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateCustomerAllergenDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateCustomerAllergenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateCustomerAllergens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerAllergenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateCustomerAllergens
     * const intermediateCustomerAllergen = await prisma.intermediateCustomerAllergen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateCustomerAllergenUpdateManyArgs>(
      args: SelectSubset<T, IntermediateCustomerAllergenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateCustomerAllergen.
     * @param {IntermediateCustomerAllergenUpsertArgs} args - Arguments to update or create a IntermediateCustomerAllergen.
     * @example
     * // Update or create a IntermediateCustomerAllergen
     * const intermediateCustomerAllergen = await prisma.intermediateCustomerAllergen.upsert({
     *   create: {
     *     // ... data to create a IntermediateCustomerAllergen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateCustomerAllergen we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateCustomerAllergenUpsertArgs>(
      args: SelectSubset<T, IntermediateCustomerAllergenUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergen>, Prisma__IntermediateCustomerAllergenClient<IntermediateCustomerAllergenGetPayload<T>>>

    /**
     * Count the number of IntermediateCustomerAllergens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerAllergenCountArgs} args - Arguments to filter IntermediateCustomerAllergens to count.
     * @example
     * // Count the number of IntermediateCustomerAllergens
     * const count = await prisma.intermediateCustomerAllergen.count({
     *   where: {
     *     // ... the filter for the IntermediateCustomerAllergens we want to count
     *   }
     * })
    **/
    count<T extends IntermediateCustomerAllergenCountArgs>(
      args?: Subset<T, IntermediateCustomerAllergenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateCustomerAllergenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateCustomerAllergen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerAllergenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateCustomerAllergenAggregateArgs>(args: Subset<T, IntermediateCustomerAllergenAggregateArgs>): PrismaPromise<GetIntermediateCustomerAllergenAggregateType<T>>

    /**
     * Group by IntermediateCustomerAllergen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateCustomerAllergenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateCustomerAllergenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateCustomerAllergenGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateCustomerAllergenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateCustomerAllergenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateCustomerAllergenGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateCustomerAllergen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateCustomerAllergenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    productAllergen<T extends ProductAllergenArgs = {}>(args?: Subset<T, ProductAllergenArgs>): CheckSelect<T, Prisma__ProductAllergenClient<ProductAllergen | null >, Prisma__ProductAllergenClient<ProductAllergenGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateCustomerAllergen findUnique
   */
  export type IntermediateCustomerAllergenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerAllergen
     * 
    **/
    select?: IntermediateCustomerAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerAllergenInclude | null
    /**
     * Throw an Error if a IntermediateCustomerAllergen can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerAllergen to fetch.
     * 
    **/
    where: IntermediateCustomerAllergenWhereUniqueInput
  }


  /**
   * IntermediateCustomerAllergen findFirst
   */
  export type IntermediateCustomerAllergenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerAllergen
     * 
    **/
    select?: IntermediateCustomerAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerAllergenInclude | null
    /**
     * Throw an Error if a IntermediateCustomerAllergen can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateCustomerAllergen to fetch.
     * 
    **/
    where?: IntermediateCustomerAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateCustomerAllergens.
     * 
    **/
    cursor?: IntermediateCustomerAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerAllergens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateCustomerAllergens.
     * 
    **/
    distinct?: Enumerable<IntermediateCustomerAllergenScalarFieldEnum>
  }


  /**
   * IntermediateCustomerAllergen findMany
   */
  export type IntermediateCustomerAllergenFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerAllergen
     * 
    **/
    select?: IntermediateCustomerAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerAllergenInclude | null
    /**
     * Filter, which IntermediateCustomerAllergens to fetch.
     * 
    **/
    where?: IntermediateCustomerAllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateCustomerAllergens to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateCustomerAllergenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateCustomerAllergens.
     * 
    **/
    cursor?: IntermediateCustomerAllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateCustomerAllergens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateCustomerAllergens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateCustomerAllergenScalarFieldEnum>
  }


  /**
   * IntermediateCustomerAllergen create
   */
  export type IntermediateCustomerAllergenCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerAllergen
     * 
    **/
    select?: IntermediateCustomerAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerAllergenInclude | null
    /**
     * The data needed to create a IntermediateCustomerAllergen.
     * 
    **/
    data: XOR<IntermediateCustomerAllergenCreateInput, IntermediateCustomerAllergenUncheckedCreateInput>
  }


  /**
   * IntermediateCustomerAllergen createMany
   */
  export type IntermediateCustomerAllergenCreateManyArgs = {
    data: Enumerable<IntermediateCustomerAllergenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateCustomerAllergen update
   */
  export type IntermediateCustomerAllergenUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerAllergen
     * 
    **/
    select?: IntermediateCustomerAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerAllergenInclude | null
    /**
     * The data needed to update a IntermediateCustomerAllergen.
     * 
    **/
    data: XOR<IntermediateCustomerAllergenUpdateInput, IntermediateCustomerAllergenUncheckedUpdateInput>
    /**
     * Choose, which IntermediateCustomerAllergen to update.
     * 
    **/
    where: IntermediateCustomerAllergenWhereUniqueInput
  }


  /**
   * IntermediateCustomerAllergen updateMany
   */
  export type IntermediateCustomerAllergenUpdateManyArgs = {
    data: XOR<IntermediateCustomerAllergenUpdateManyMutationInput, IntermediateCustomerAllergenUncheckedUpdateManyInput>
    where?: IntermediateCustomerAllergenWhereInput
  }


  /**
   * IntermediateCustomerAllergen upsert
   */
  export type IntermediateCustomerAllergenUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerAllergen
     * 
    **/
    select?: IntermediateCustomerAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerAllergenInclude | null
    /**
     * The filter to search for the IntermediateCustomerAllergen to update in case it exists.
     * 
    **/
    where: IntermediateCustomerAllergenWhereUniqueInput
    /**
     * In case the IntermediateCustomerAllergen found by the `where` argument doesn't exist, create a new IntermediateCustomerAllergen with this data.
     * 
    **/
    create: XOR<IntermediateCustomerAllergenCreateInput, IntermediateCustomerAllergenUncheckedCreateInput>
    /**
     * In case the IntermediateCustomerAllergen was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateCustomerAllergenUpdateInput, IntermediateCustomerAllergenUncheckedUpdateInput>
  }


  /**
   * IntermediateCustomerAllergen delete
   */
  export type IntermediateCustomerAllergenDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerAllergen
     * 
    **/
    select?: IntermediateCustomerAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerAllergenInclude | null
    /**
     * Filter which IntermediateCustomerAllergen to delete.
     * 
    **/
    where: IntermediateCustomerAllergenWhereUniqueInput
  }


  /**
   * IntermediateCustomerAllergen deleteMany
   */
  export type IntermediateCustomerAllergenDeleteManyArgs = {
    where?: IntermediateCustomerAllergenWhereInput
  }


  /**
   * IntermediateCustomerAllergen without action
   */
  export type IntermediateCustomerAllergenArgs = {
    /**
     * Select specific fields to fetch from the IntermediateCustomerAllergen
     * 
    **/
    select?: IntermediateCustomerAllergenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateCustomerAllergenInclude | null
  }



  /**
   * Model ProductNutritionFact
   */


  export type AggregateProductNutritionFact = {
    _count: ProductNutritionFactCountAggregateOutputType | null
    _avg: ProductNutritionFactAvgAggregateOutputType | null
    _sum: ProductNutritionFactSumAggregateOutputType | null
    _min: ProductNutritionFactMinAggregateOutputType | null
    _max: ProductNutritionFactMaxAggregateOutputType | null
  }

  export type ProductNutritionFactAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    servingSize: number | null
    calories: number | null
    totalFatG: number | null
    saturatedFatG: number | null
    transFatG: number | null
    cholesteroleMg: number | null
    sodiumMg: number | null
    totalCarbohydrateG: number | null
    dietaryFiberG: number | null
    totalSugarG: number | null
    addedSugarG: number | null
    proteinG: number | null
    sweet: number | null
    sour: number | null
    salty: number | null
    bitter: number | null
    spicy: number | null
  }

  export type ProductNutritionFactSumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    servingSize: number | null
    calories: number | null
    totalFatG: number | null
    saturatedFatG: number | null
    transFatG: number | null
    cholesteroleMg: number | null
    sodiumMg: number | null
    totalCarbohydrateG: number | null
    dietaryFiberG: number | null
    totalSugarG: number | null
    addedSugarG: number | null
    proteinG: number | null
    sweet: number | null
    sour: number | null
    salty: number | null
    bitter: number | null
    spicy: number | null
  }

  export type ProductNutritionFactMinAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    servingSize: number | null
    calories: number | null
    totalFatG: number | null
    saturatedFatG: number | null
    transFatG: number | null
    cholesteroleMg: number | null
    sodiumMg: number | null
    totalCarbohydrateG: number | null
    dietaryFiberG: number | null
    totalSugarG: number | null
    addedSugarG: number | null
    proteinG: number | null
    sweet: number | null
    sour: number | null
    salty: number | null
    bitter: number | null
    spicy: number | null
    texture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductNutritionFactMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    servingSize: number | null
    calories: number | null
    totalFatG: number | null
    saturatedFatG: number | null
    transFatG: number | null
    cholesteroleMg: number | null
    sodiumMg: number | null
    totalCarbohydrateG: number | null
    dietaryFiberG: number | null
    totalSugarG: number | null
    addedSugarG: number | null
    proteinG: number | null
    sweet: number | null
    sour: number | null
    salty: number | null
    bitter: number | null
    spicy: number | null
    texture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductNutritionFactCountAggregateOutputType = {
    id: number
    productId: number
    quantity: number
    servingSize: number
    calories: number
    totalFatG: number
    saturatedFatG: number
    transFatG: number
    cholesteroleMg: number
    sodiumMg: number
    totalCarbohydrateG: number
    dietaryFiberG: number
    totalSugarG: number
    addedSugarG: number
    proteinG: number
    sweet: number
    sour: number
    salty: number
    bitter: number
    spicy: number
    texture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductNutritionFactAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    servingSize?: true
    calories?: true
    totalFatG?: true
    saturatedFatG?: true
    transFatG?: true
    cholesteroleMg?: true
    sodiumMg?: true
    totalCarbohydrateG?: true
    dietaryFiberG?: true
    totalSugarG?: true
    addedSugarG?: true
    proteinG?: true
    sweet?: true
    sour?: true
    salty?: true
    bitter?: true
    spicy?: true
  }

  export type ProductNutritionFactSumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    servingSize?: true
    calories?: true
    totalFatG?: true
    saturatedFatG?: true
    transFatG?: true
    cholesteroleMg?: true
    sodiumMg?: true
    totalCarbohydrateG?: true
    dietaryFiberG?: true
    totalSugarG?: true
    addedSugarG?: true
    proteinG?: true
    sweet?: true
    sour?: true
    salty?: true
    bitter?: true
    spicy?: true
  }

  export type ProductNutritionFactMinAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    servingSize?: true
    calories?: true
    totalFatG?: true
    saturatedFatG?: true
    transFatG?: true
    cholesteroleMg?: true
    sodiumMg?: true
    totalCarbohydrateG?: true
    dietaryFiberG?: true
    totalSugarG?: true
    addedSugarG?: true
    proteinG?: true
    sweet?: true
    sour?: true
    salty?: true
    bitter?: true
    spicy?: true
    texture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductNutritionFactMaxAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    servingSize?: true
    calories?: true
    totalFatG?: true
    saturatedFatG?: true
    transFatG?: true
    cholesteroleMg?: true
    sodiumMg?: true
    totalCarbohydrateG?: true
    dietaryFiberG?: true
    totalSugarG?: true
    addedSugarG?: true
    proteinG?: true
    sweet?: true
    sour?: true
    salty?: true
    bitter?: true
    spicy?: true
    texture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductNutritionFactCountAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    servingSize?: true
    calories?: true
    totalFatG?: true
    saturatedFatG?: true
    transFatG?: true
    cholesteroleMg?: true
    sodiumMg?: true
    totalCarbohydrateG?: true
    dietaryFiberG?: true
    totalSugarG?: true
    addedSugarG?: true
    proteinG?: true
    sweet?: true
    sour?: true
    salty?: true
    bitter?: true
    spicy?: true
    texture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductNutritionFactAggregateArgs = {
    /**
     * Filter which ProductNutritionFact to aggregate.
     * 
    **/
    where?: ProductNutritionFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductNutritionFacts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductNutritionFactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductNutritionFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductNutritionFacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductNutritionFacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductNutritionFacts
    **/
    _count?: true | ProductNutritionFactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductNutritionFactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductNutritionFactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductNutritionFactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductNutritionFactMaxAggregateInputType
  }

  export type GetProductNutritionFactAggregateType<T extends ProductNutritionFactAggregateArgs> = {
        [P in keyof T & keyof AggregateProductNutritionFact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductNutritionFact[P]>
      : GetScalarType<T[P], AggregateProductNutritionFact[P]>
  }




  export type ProductNutritionFactGroupByArgs = {
    where?: ProductNutritionFactWhereInput
    orderBy?: Enumerable<ProductNutritionFactOrderByWithAggregationInput>
    by: Array<ProductNutritionFactScalarFieldEnum>
    having?: ProductNutritionFactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductNutritionFactCountAggregateInputType | true
    _avg?: ProductNutritionFactAvgAggregateInputType
    _sum?: ProductNutritionFactSumAggregateInputType
    _min?: ProductNutritionFactMinAggregateInputType
    _max?: ProductNutritionFactMaxAggregateInputType
  }


  export type ProductNutritionFactGroupByOutputType = {
    id: number
    productId: number
    quantity: number | null
    servingSize: number | null
    calories: number | null
    totalFatG: number | null
    saturatedFatG: number | null
    transFatG: number | null
    cholesteroleMg: number | null
    sodiumMg: number | null
    totalCarbohydrateG: number | null
    dietaryFiberG: number | null
    totalSugarG: number | null
    addedSugarG: number | null
    proteinG: number | null
    sweet: number | null
    sour: number | null
    salty: number | null
    bitter: number | null
    spicy: number | null
    texture: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductNutritionFactCountAggregateOutputType | null
    _avg: ProductNutritionFactAvgAggregateOutputType | null
    _sum: ProductNutritionFactSumAggregateOutputType | null
    _min: ProductNutritionFactMinAggregateOutputType | null
    _max: ProductNutritionFactMaxAggregateOutputType | null
  }

  type GetProductNutritionFactGroupByPayload<T extends ProductNutritionFactGroupByArgs> = Promise<
    Array<
      PickArray<ProductNutritionFactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductNutritionFactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductNutritionFactGroupByOutputType[P]>
            : GetScalarType<T[P], ProductNutritionFactGroupByOutputType[P]>
        }
      >
    >


  export type ProductNutritionFactSelect = {
    id?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    quantity?: boolean
    servingSize?: boolean
    calories?: boolean
    totalFatG?: boolean
    saturatedFatG?: boolean
    transFatG?: boolean
    cholesteroleMg?: boolean
    sodiumMg?: boolean
    totalCarbohydrateG?: boolean
    dietaryFiberG?: boolean
    totalSugarG?: boolean
    addedSugarG?: boolean
    proteinG?: boolean
    sweet?: boolean
    sour?: boolean
    salty?: boolean
    bitter?: boolean
    spicy?: boolean
    texture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductNutritionFactInclude = {
    product?: boolean | ProductArgs
  }

  export type ProductNutritionFactGetPayload<
    S extends boolean | null | undefined | ProductNutritionFactArgs,
    U = keyof S
      > = S extends true
        ? ProductNutritionFact
    : S extends undefined
    ? never
    : S extends ProductNutritionFactArgs | ProductNutritionFactFindManyArgs
    ?'include' extends U
    ? ProductNutritionFact  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductNutritionFact ?ProductNutritionFact [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> : never
  } 
    : ProductNutritionFact
  : ProductNutritionFact


  type ProductNutritionFactCountArgs = Merge<
    Omit<ProductNutritionFactFindManyArgs, 'select' | 'include'> & {
      select?: ProductNutritionFactCountAggregateInputType | true
    }
  >

  export interface ProductNutritionFactDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductNutritionFact that matches the filter.
     * @param {ProductNutritionFactFindUniqueArgs} args - Arguments to find a ProductNutritionFact
     * @example
     * // Get one ProductNutritionFact
     * const productNutritionFact = await prisma.productNutritionFact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductNutritionFactFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductNutritionFactFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductNutritionFact'> extends True ? CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact>, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T>>> : CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact | null >, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T> | null >>

    /**
     * Find the first ProductNutritionFact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductNutritionFactFindFirstArgs} args - Arguments to find a ProductNutritionFact
     * @example
     * // Get one ProductNutritionFact
     * const productNutritionFact = await prisma.productNutritionFact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductNutritionFactFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductNutritionFactFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductNutritionFact'> extends True ? CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact>, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T>>> : CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact | null >, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T> | null >>

    /**
     * Find zero or more ProductNutritionFacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductNutritionFactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductNutritionFacts
     * const productNutritionFacts = await prisma.productNutritionFact.findMany()
     * 
     * // Get first 10 ProductNutritionFacts
     * const productNutritionFacts = await prisma.productNutritionFact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productNutritionFactWithIdOnly = await prisma.productNutritionFact.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductNutritionFactFindManyArgs>(
      args?: SelectSubset<T, ProductNutritionFactFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductNutritionFact>>, PrismaPromise<Array<ProductNutritionFactGetPayload<T>>>>

    /**
     * Create a ProductNutritionFact.
     * @param {ProductNutritionFactCreateArgs} args - Arguments to create a ProductNutritionFact.
     * @example
     * // Create one ProductNutritionFact
     * const ProductNutritionFact = await prisma.productNutritionFact.create({
     *   data: {
     *     // ... data to create a ProductNutritionFact
     *   }
     * })
     * 
    **/
    create<T extends ProductNutritionFactCreateArgs>(
      args: SelectSubset<T, ProductNutritionFactCreateArgs>
    ): CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact>, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T>>>

    /**
     * Create many ProductNutritionFacts.
     *     @param {ProductNutritionFactCreateManyArgs} args - Arguments to create many ProductNutritionFacts.
     *     @example
     *     // Create many ProductNutritionFacts
     *     const productNutritionFact = await prisma.productNutritionFact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductNutritionFactCreateManyArgs>(
      args?: SelectSubset<T, ProductNutritionFactCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductNutritionFact.
     * @param {ProductNutritionFactDeleteArgs} args - Arguments to delete one ProductNutritionFact.
     * @example
     * // Delete one ProductNutritionFact
     * const ProductNutritionFact = await prisma.productNutritionFact.delete({
     *   where: {
     *     // ... filter to delete one ProductNutritionFact
     *   }
     * })
     * 
    **/
    delete<T extends ProductNutritionFactDeleteArgs>(
      args: SelectSubset<T, ProductNutritionFactDeleteArgs>
    ): CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact>, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T>>>

    /**
     * Update one ProductNutritionFact.
     * @param {ProductNutritionFactUpdateArgs} args - Arguments to update one ProductNutritionFact.
     * @example
     * // Update one ProductNutritionFact
     * const productNutritionFact = await prisma.productNutritionFact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductNutritionFactUpdateArgs>(
      args: SelectSubset<T, ProductNutritionFactUpdateArgs>
    ): CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact>, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T>>>

    /**
     * Delete zero or more ProductNutritionFacts.
     * @param {ProductNutritionFactDeleteManyArgs} args - Arguments to filter ProductNutritionFacts to delete.
     * @example
     * // Delete a few ProductNutritionFacts
     * const { count } = await prisma.productNutritionFact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductNutritionFactDeleteManyArgs>(
      args?: SelectSubset<T, ProductNutritionFactDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductNutritionFacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductNutritionFactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductNutritionFacts
     * const productNutritionFact = await prisma.productNutritionFact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductNutritionFactUpdateManyArgs>(
      args: SelectSubset<T, ProductNutritionFactUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductNutritionFact.
     * @param {ProductNutritionFactUpsertArgs} args - Arguments to update or create a ProductNutritionFact.
     * @example
     * // Update or create a ProductNutritionFact
     * const productNutritionFact = await prisma.productNutritionFact.upsert({
     *   create: {
     *     // ... data to create a ProductNutritionFact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductNutritionFact we want to update
     *   }
     * })
    **/
    upsert<T extends ProductNutritionFactUpsertArgs>(
      args: SelectSubset<T, ProductNutritionFactUpsertArgs>
    ): CheckSelect<T, Prisma__ProductNutritionFactClient<ProductNutritionFact>, Prisma__ProductNutritionFactClient<ProductNutritionFactGetPayload<T>>>

    /**
     * Count the number of ProductNutritionFacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductNutritionFactCountArgs} args - Arguments to filter ProductNutritionFacts to count.
     * @example
     * // Count the number of ProductNutritionFacts
     * const count = await prisma.productNutritionFact.count({
     *   where: {
     *     // ... the filter for the ProductNutritionFacts we want to count
     *   }
     * })
    **/
    count<T extends ProductNutritionFactCountArgs>(
      args?: Subset<T, ProductNutritionFactCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductNutritionFactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductNutritionFact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductNutritionFactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductNutritionFactAggregateArgs>(args: Subset<T, ProductNutritionFactAggregateArgs>): PrismaPromise<GetProductNutritionFactAggregateType<T>>

    /**
     * Group by ProductNutritionFact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductNutritionFactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductNutritionFactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductNutritionFactGroupByArgs['orderBy'] }
        : { orderBy?: ProductNutritionFactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductNutritionFactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductNutritionFactGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductNutritionFact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductNutritionFactClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductNutritionFact findUnique
   */
  export type ProductNutritionFactFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductNutritionFact
     * 
    **/
    select?: ProductNutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductNutritionFactInclude | null
    /**
     * Throw an Error if a ProductNutritionFact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductNutritionFact to fetch.
     * 
    **/
    where: ProductNutritionFactWhereUniqueInput
  }


  /**
   * ProductNutritionFact findFirst
   */
  export type ProductNutritionFactFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductNutritionFact
     * 
    **/
    select?: ProductNutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductNutritionFactInclude | null
    /**
     * Throw an Error if a ProductNutritionFact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductNutritionFact to fetch.
     * 
    **/
    where?: ProductNutritionFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductNutritionFacts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductNutritionFactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductNutritionFacts.
     * 
    **/
    cursor?: ProductNutritionFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductNutritionFacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductNutritionFacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductNutritionFacts.
     * 
    **/
    distinct?: Enumerable<ProductNutritionFactScalarFieldEnum>
  }


  /**
   * ProductNutritionFact findMany
   */
  export type ProductNutritionFactFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductNutritionFact
     * 
    **/
    select?: ProductNutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductNutritionFactInclude | null
    /**
     * Filter, which ProductNutritionFacts to fetch.
     * 
    **/
    where?: ProductNutritionFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductNutritionFacts to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductNutritionFactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductNutritionFacts.
     * 
    **/
    cursor?: ProductNutritionFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductNutritionFacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductNutritionFacts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductNutritionFactScalarFieldEnum>
  }


  /**
   * ProductNutritionFact create
   */
  export type ProductNutritionFactCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductNutritionFact
     * 
    **/
    select?: ProductNutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductNutritionFactInclude | null
    /**
     * The data needed to create a ProductNutritionFact.
     * 
    **/
    data: XOR<ProductNutritionFactCreateInput, ProductNutritionFactUncheckedCreateInput>
  }


  /**
   * ProductNutritionFact createMany
   */
  export type ProductNutritionFactCreateManyArgs = {
    data: Enumerable<ProductNutritionFactCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductNutritionFact update
   */
  export type ProductNutritionFactUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductNutritionFact
     * 
    **/
    select?: ProductNutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductNutritionFactInclude | null
    /**
     * The data needed to update a ProductNutritionFact.
     * 
    **/
    data: XOR<ProductNutritionFactUpdateInput, ProductNutritionFactUncheckedUpdateInput>
    /**
     * Choose, which ProductNutritionFact to update.
     * 
    **/
    where: ProductNutritionFactWhereUniqueInput
  }


  /**
   * ProductNutritionFact updateMany
   */
  export type ProductNutritionFactUpdateManyArgs = {
    data: XOR<ProductNutritionFactUpdateManyMutationInput, ProductNutritionFactUncheckedUpdateManyInput>
    where?: ProductNutritionFactWhereInput
  }


  /**
   * ProductNutritionFact upsert
   */
  export type ProductNutritionFactUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductNutritionFact
     * 
    **/
    select?: ProductNutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductNutritionFactInclude | null
    /**
     * The filter to search for the ProductNutritionFact to update in case it exists.
     * 
    **/
    where: ProductNutritionFactWhereUniqueInput
    /**
     * In case the ProductNutritionFact found by the `where` argument doesn't exist, create a new ProductNutritionFact with this data.
     * 
    **/
    create: XOR<ProductNutritionFactCreateInput, ProductNutritionFactUncheckedCreateInput>
    /**
     * In case the ProductNutritionFact was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductNutritionFactUpdateInput, ProductNutritionFactUncheckedUpdateInput>
  }


  /**
   * ProductNutritionFact delete
   */
  export type ProductNutritionFactDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductNutritionFact
     * 
    **/
    select?: ProductNutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductNutritionFactInclude | null
    /**
     * Filter which ProductNutritionFact to delete.
     * 
    **/
    where: ProductNutritionFactWhereUniqueInput
  }


  /**
   * ProductNutritionFact deleteMany
   */
  export type ProductNutritionFactDeleteManyArgs = {
    where?: ProductNutritionFactWhereInput
  }


  /**
   * ProductNutritionFact without action
   */
  export type ProductNutritionFactArgs = {
    /**
     * Select specific fields to fetch from the ProductNutritionFact
     * 
    **/
    select?: ProductNutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductNutritionFactInclude | null
  }



  /**
   * Model ProductProvider
   */


  export type AggregateProductProvider = {
    _count: ProductProviderCountAggregateOutputType | null
    _avg: ProductProviderAvgAggregateOutputType | null
    _sum: ProductProviderSumAggregateOutputType | null
    _min: ProductProviderMinAggregateOutputType | null
    _max: ProductProviderMaxAggregateOutputType | null
  }

  export type ProductProviderAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductProviderSumAggregateOutputType = {
    id: number | null
  }

  export type ProductProviderMinAggregateOutputType = {
    id: number | null
    provider: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductProviderMaxAggregateOutputType = {
    id: number | null
    provider: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductProviderCountAggregateOutputType = {
    id: number
    provider: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductProviderAvgAggregateInputType = {
    id?: true
  }

  export type ProductProviderSumAggregateInputType = {
    id?: true
  }

  export type ProductProviderMinAggregateInputType = {
    id?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductProviderMaxAggregateInputType = {
    id?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductProviderCountAggregateInputType = {
    id?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductProviderAggregateArgs = {
    /**
     * Filter which ProductProvider to aggregate.
     * 
    **/
    where?: ProductProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProviders to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProviders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProviders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductProviders
    **/
    _count?: true | ProductProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductProviderMaxAggregateInputType
  }

  export type GetProductProviderAggregateType<T extends ProductProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProductProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductProvider[P]>
      : GetScalarType<T[P], AggregateProductProvider[P]>
  }




  export type ProductProviderGroupByArgs = {
    where?: ProductProviderWhereInput
    orderBy?: Enumerable<ProductProviderOrderByWithAggregationInput>
    by: Array<ProductProviderScalarFieldEnum>
    having?: ProductProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductProviderCountAggregateInputType | true
    _avg?: ProductProviderAvgAggregateInputType
    _sum?: ProductProviderSumAggregateInputType
    _min?: ProductProviderMinAggregateInputType
    _max?: ProductProviderMaxAggregateInputType
  }


  export type ProductProviderGroupByOutputType = {
    id: number
    provider: string
    createdAt: Date
    updatedAt: Date
    _count: ProductProviderCountAggregateOutputType | null
    _avg: ProductProviderAvgAggregateOutputType | null
    _sum: ProductProviderSumAggregateOutputType | null
    _min: ProductProviderMinAggregateOutputType | null
    _max: ProductProviderMaxAggregateOutputType | null
  }

  type GetProductProviderGroupByPayload<T extends ProductProviderGroupByArgs> = Promise<
    Array<
      PickArray<ProductProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProductProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProductProviderSelect = {
    id?: boolean
    provider?: boolean
    products?: boolean | ProductFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | ProductProviderCountOutputTypeArgs
  }

  export type ProductProviderInclude = {
    products?: boolean | ProductFindManyArgs
    _count?: boolean | ProductProviderCountOutputTypeArgs
  }

  export type ProductProviderGetPayload<
    S extends boolean | null | undefined | ProductProviderArgs,
    U = keyof S
      > = S extends true
        ? ProductProvider
    : S extends undefined
    ? never
    : S extends ProductProviderArgs | ProductProviderFindManyArgs
    ?'include' extends U
    ? ProductProvider  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'products'
        ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ProductProviderCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ProductProvider ?ProductProvider [P]
  : 
          P extends 'products'
        ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ProductProviderCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : ProductProvider
  : ProductProvider


  type ProductProviderCountArgs = Merge<
    Omit<ProductProviderFindManyArgs, 'select' | 'include'> & {
      select?: ProductProviderCountAggregateInputType | true
    }
  >

  export interface ProductProviderDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ProductProvider that matches the filter.
     * @param {ProductProviderFindUniqueArgs} args - Arguments to find a ProductProvider
     * @example
     * // Get one ProductProvider
     * const productProvider = await prisma.productProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductProviderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductProviderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductProvider'> extends True ? CheckSelect<T, Prisma__ProductProviderClient<ProductProvider>, Prisma__ProductProviderClient<ProductProviderGetPayload<T>>> : CheckSelect<T, Prisma__ProductProviderClient<ProductProvider | null >, Prisma__ProductProviderClient<ProductProviderGetPayload<T> | null >>

    /**
     * Find the first ProductProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProviderFindFirstArgs} args - Arguments to find a ProductProvider
     * @example
     * // Get one ProductProvider
     * const productProvider = await prisma.productProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductProviderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductProviderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductProvider'> extends True ? CheckSelect<T, Prisma__ProductProviderClient<ProductProvider>, Prisma__ProductProviderClient<ProductProviderGetPayload<T>>> : CheckSelect<T, Prisma__ProductProviderClient<ProductProvider | null >, Prisma__ProductProviderClient<ProductProviderGetPayload<T> | null >>

    /**
     * Find zero or more ProductProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProviderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductProviders
     * const productProviders = await prisma.productProvider.findMany()
     * 
     * // Get first 10 ProductProviders
     * const productProviders = await prisma.productProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productProviderWithIdOnly = await prisma.productProvider.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductProviderFindManyArgs>(
      args?: SelectSubset<T, ProductProviderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ProductProvider>>, PrismaPromise<Array<ProductProviderGetPayload<T>>>>

    /**
     * Create a ProductProvider.
     * @param {ProductProviderCreateArgs} args - Arguments to create a ProductProvider.
     * @example
     * // Create one ProductProvider
     * const ProductProvider = await prisma.productProvider.create({
     *   data: {
     *     // ... data to create a ProductProvider
     *   }
     * })
     * 
    **/
    create<T extends ProductProviderCreateArgs>(
      args: SelectSubset<T, ProductProviderCreateArgs>
    ): CheckSelect<T, Prisma__ProductProviderClient<ProductProvider>, Prisma__ProductProviderClient<ProductProviderGetPayload<T>>>

    /**
     * Create many ProductProviders.
     *     @param {ProductProviderCreateManyArgs} args - Arguments to create many ProductProviders.
     *     @example
     *     // Create many ProductProviders
     *     const productProvider = await prisma.productProvider.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductProviderCreateManyArgs>(
      args?: SelectSubset<T, ProductProviderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ProductProvider.
     * @param {ProductProviderDeleteArgs} args - Arguments to delete one ProductProvider.
     * @example
     * // Delete one ProductProvider
     * const ProductProvider = await prisma.productProvider.delete({
     *   where: {
     *     // ... filter to delete one ProductProvider
     *   }
     * })
     * 
    **/
    delete<T extends ProductProviderDeleteArgs>(
      args: SelectSubset<T, ProductProviderDeleteArgs>
    ): CheckSelect<T, Prisma__ProductProviderClient<ProductProvider>, Prisma__ProductProviderClient<ProductProviderGetPayload<T>>>

    /**
     * Update one ProductProvider.
     * @param {ProductProviderUpdateArgs} args - Arguments to update one ProductProvider.
     * @example
     * // Update one ProductProvider
     * const productProvider = await prisma.productProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductProviderUpdateArgs>(
      args: SelectSubset<T, ProductProviderUpdateArgs>
    ): CheckSelect<T, Prisma__ProductProviderClient<ProductProvider>, Prisma__ProductProviderClient<ProductProviderGetPayload<T>>>

    /**
     * Delete zero or more ProductProviders.
     * @param {ProductProviderDeleteManyArgs} args - Arguments to filter ProductProviders to delete.
     * @example
     * // Delete a few ProductProviders
     * const { count } = await prisma.productProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductProviderDeleteManyArgs>(
      args?: SelectSubset<T, ProductProviderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductProviders
     * const productProvider = await prisma.productProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductProviderUpdateManyArgs>(
      args: SelectSubset<T, ProductProviderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductProvider.
     * @param {ProductProviderUpsertArgs} args - Arguments to update or create a ProductProvider.
     * @example
     * // Update or create a ProductProvider
     * const productProvider = await prisma.productProvider.upsert({
     *   create: {
     *     // ... data to create a ProductProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductProvider we want to update
     *   }
     * })
    **/
    upsert<T extends ProductProviderUpsertArgs>(
      args: SelectSubset<T, ProductProviderUpsertArgs>
    ): CheckSelect<T, Prisma__ProductProviderClient<ProductProvider>, Prisma__ProductProviderClient<ProductProviderGetPayload<T>>>

    /**
     * Count the number of ProductProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProviderCountArgs} args - Arguments to filter ProductProviders to count.
     * @example
     * // Count the number of ProductProviders
     * const count = await prisma.productProvider.count({
     *   where: {
     *     // ... the filter for the ProductProviders we want to count
     *   }
     * })
    **/
    count<T extends ProductProviderCountArgs>(
      args?: Subset<T, ProductProviderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductProviderAggregateArgs>(args: Subset<T, ProductProviderAggregateArgs>): PrismaPromise<GetProductProviderAggregateType<T>>

    /**
     * Group by ProductProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProductProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductProviderGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductProviderClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ProductProvider findUnique
   */
  export type ProductProviderFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ProductProvider
     * 
    **/
    select?: ProductProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductProviderInclude | null
    /**
     * Throw an Error if a ProductProvider can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductProvider to fetch.
     * 
    **/
    where: ProductProviderWhereUniqueInput
  }


  /**
   * ProductProvider findFirst
   */
  export type ProductProviderFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ProductProvider
     * 
    **/
    select?: ProductProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductProviderInclude | null
    /**
     * Throw an Error if a ProductProvider can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ProductProvider to fetch.
     * 
    **/
    where?: ProductProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProviders to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductProviders.
     * 
    **/
    cursor?: ProductProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProviders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProviders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductProviders.
     * 
    **/
    distinct?: Enumerable<ProductProviderScalarFieldEnum>
  }


  /**
   * ProductProvider findMany
   */
  export type ProductProviderFindManyArgs = {
    /**
     * Select specific fields to fetch from the ProductProvider
     * 
    **/
    select?: ProductProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductProviderInclude | null
    /**
     * Filter, which ProductProviders to fetch.
     * 
    **/
    where?: ProductProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductProviders to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductProviders.
     * 
    **/
    cursor?: ProductProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductProviders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductProviders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductProviderScalarFieldEnum>
  }


  /**
   * ProductProvider create
   */
  export type ProductProviderCreateArgs = {
    /**
     * Select specific fields to fetch from the ProductProvider
     * 
    **/
    select?: ProductProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductProviderInclude | null
    /**
     * The data needed to create a ProductProvider.
     * 
    **/
    data: XOR<ProductProviderCreateInput, ProductProviderUncheckedCreateInput>
  }


  /**
   * ProductProvider createMany
   */
  export type ProductProviderCreateManyArgs = {
    data: Enumerable<ProductProviderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductProvider update
   */
  export type ProductProviderUpdateArgs = {
    /**
     * Select specific fields to fetch from the ProductProvider
     * 
    **/
    select?: ProductProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductProviderInclude | null
    /**
     * The data needed to update a ProductProvider.
     * 
    **/
    data: XOR<ProductProviderUpdateInput, ProductProviderUncheckedUpdateInput>
    /**
     * Choose, which ProductProvider to update.
     * 
    **/
    where: ProductProviderWhereUniqueInput
  }


  /**
   * ProductProvider updateMany
   */
  export type ProductProviderUpdateManyArgs = {
    data: XOR<ProductProviderUpdateManyMutationInput, ProductProviderUncheckedUpdateManyInput>
    where?: ProductProviderWhereInput
  }


  /**
   * ProductProvider upsert
   */
  export type ProductProviderUpsertArgs = {
    /**
     * Select specific fields to fetch from the ProductProvider
     * 
    **/
    select?: ProductProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductProviderInclude | null
    /**
     * The filter to search for the ProductProvider to update in case it exists.
     * 
    **/
    where: ProductProviderWhereUniqueInput
    /**
     * In case the ProductProvider found by the `where` argument doesn't exist, create a new ProductProvider with this data.
     * 
    **/
    create: XOR<ProductProviderCreateInput, ProductProviderUncheckedCreateInput>
    /**
     * In case the ProductProvider was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductProviderUpdateInput, ProductProviderUncheckedUpdateInput>
  }


  /**
   * ProductProvider delete
   */
  export type ProductProviderDeleteArgs = {
    /**
     * Select specific fields to fetch from the ProductProvider
     * 
    **/
    select?: ProductProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductProviderInclude | null
    /**
     * Filter which ProductProvider to delete.
     * 
    **/
    where: ProductProviderWhereUniqueInput
  }


  /**
   * ProductProvider deleteMany
   */
  export type ProductProviderDeleteManyArgs = {
    where?: ProductProviderWhereInput
  }


  /**
   * ProductProvider without action
   */
  export type ProductProviderArgs = {
    /**
     * Select specific fields to fetch from the ProductProvider
     * 
    **/
    select?: ProductProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductProviderInclude | null
  }



  /**
   * Model Survey
   */


  export type AggregateSurvey = {
    _count: SurveyCountAggregateOutputType | null
    _avg: SurveyAvgAggregateOutputType | null
    _sum: SurveySumAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  export type SurveyAvgAggregateOutputType = {
    id: number | null
  }

  export type SurveySumAggregateOutputType = {
    id: number | null
  }

  export type SurveyMinAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyCountAggregateOutputType = {
    id: number
    name: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyAvgAggregateInputType = {
    id?: true
  }

  export type SurveySumAggregateInputType = {
    id?: true
  }

  export type SurveyMinAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyMaxAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyCountAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyAggregateArgs = {
    /**
     * Filter which Survey to aggregate.
     * 
    **/
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Surveys
    **/
    _count?: true | SurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyMaxAggregateInputType
  }

  export type GetSurveyAggregateType<T extends SurveyAggregateArgs> = {
        [P in keyof T & keyof AggregateSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurvey[P]>
      : GetScalarType<T[P], AggregateSurvey[P]>
  }




  export type SurveyGroupByArgs = {
    where?: SurveyWhereInput
    orderBy?: Enumerable<SurveyOrderByWithAggregationInput>
    by: Array<SurveyScalarFieldEnum>
    having?: SurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyCountAggregateInputType | true
    _avg?: SurveyAvgAggregateInputType
    _sum?: SurveySumAggregateInputType
    _min?: SurveyMinAggregateInputType
    _max?: SurveyMaxAggregateInputType
  }


  export type SurveyGroupByOutputType = {
    id: number
    name: string
    label: string
    createdAt: Date
    updatedAt: Date
    _count: SurveyCountAggregateOutputType | null
    _avg: SurveyAvgAggregateOutputType | null
    _sum: SurveySumAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  type GetSurveyGroupByPayload<T extends SurveyGroupByArgs> = Promise<
    Array<
      PickArray<SurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyGroupByOutputType[P]>
        }
      >
    >


  export type SurveySelect = {
    id?: boolean
    name?: boolean
    label?: boolean
    intermediateSurveyQuestions?: boolean | IntermediateSurveyQuestionFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | SurveyCountOutputTypeArgs
  }

  export type SurveyInclude = {
    intermediateSurveyQuestions?: boolean | IntermediateSurveyQuestionFindManyArgs
    _count?: boolean | SurveyCountOutputTypeArgs
  }

  export type SurveyGetPayload<
    S extends boolean | null | undefined | SurveyArgs,
    U = keyof S
      > = S extends true
        ? Survey
    : S extends undefined
    ? never
    : S extends SurveyArgs | SurveyFindManyArgs
    ?'include' extends U
    ? Survey  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateSurveyQuestions'
        ? Array < IntermediateSurveyQuestionGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? SurveyCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Survey ?Survey [P]
  : 
          P extends 'intermediateSurveyQuestions'
        ? Array < IntermediateSurveyQuestionGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? SurveyCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Survey
  : Survey


  type SurveyCountArgs = Merge<
    Omit<SurveyFindManyArgs, 'select' | 'include'> & {
      select?: SurveyCountAggregateInputType | true
    }
  >

  export interface SurveyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Survey that matches the filter.
     * @param {SurveyFindUniqueArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SurveyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SurveyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Survey'> extends True ? CheckSelect<T, Prisma__SurveyClient<Survey>, Prisma__SurveyClient<SurveyGetPayload<T>>> : CheckSelect<T, Prisma__SurveyClient<Survey | null >, Prisma__SurveyClient<SurveyGetPayload<T> | null >>

    /**
     * Find the first Survey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindFirstArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SurveyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SurveyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Survey'> extends True ? CheckSelect<T, Prisma__SurveyClient<Survey>, Prisma__SurveyClient<SurveyGetPayload<T>>> : CheckSelect<T, Prisma__SurveyClient<Survey | null >, Prisma__SurveyClient<SurveyGetPayload<T> | null >>

    /**
     * Find zero or more Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surveys
     * const surveys = await prisma.survey.findMany()
     * 
     * // Get first 10 Surveys
     * const surveys = await prisma.survey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyWithIdOnly = await prisma.survey.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SurveyFindManyArgs>(
      args?: SelectSubset<T, SurveyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Survey>>, PrismaPromise<Array<SurveyGetPayload<T>>>>

    /**
     * Create a Survey.
     * @param {SurveyCreateArgs} args - Arguments to create a Survey.
     * @example
     * // Create one Survey
     * const Survey = await prisma.survey.create({
     *   data: {
     *     // ... data to create a Survey
     *   }
     * })
     * 
    **/
    create<T extends SurveyCreateArgs>(
      args: SelectSubset<T, SurveyCreateArgs>
    ): CheckSelect<T, Prisma__SurveyClient<Survey>, Prisma__SurveyClient<SurveyGetPayload<T>>>

    /**
     * Create many Surveys.
     *     @param {SurveyCreateManyArgs} args - Arguments to create many Surveys.
     *     @example
     *     // Create many Surveys
     *     const survey = await prisma.survey.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SurveyCreateManyArgs>(
      args?: SelectSubset<T, SurveyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Survey.
     * @param {SurveyDeleteArgs} args - Arguments to delete one Survey.
     * @example
     * // Delete one Survey
     * const Survey = await prisma.survey.delete({
     *   where: {
     *     // ... filter to delete one Survey
     *   }
     * })
     * 
    **/
    delete<T extends SurveyDeleteArgs>(
      args: SelectSubset<T, SurveyDeleteArgs>
    ): CheckSelect<T, Prisma__SurveyClient<Survey>, Prisma__SurveyClient<SurveyGetPayload<T>>>

    /**
     * Update one Survey.
     * @param {SurveyUpdateArgs} args - Arguments to update one Survey.
     * @example
     * // Update one Survey
     * const survey = await prisma.survey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SurveyUpdateArgs>(
      args: SelectSubset<T, SurveyUpdateArgs>
    ): CheckSelect<T, Prisma__SurveyClient<Survey>, Prisma__SurveyClient<SurveyGetPayload<T>>>

    /**
     * Delete zero or more Surveys.
     * @param {SurveyDeleteManyArgs} args - Arguments to filter Surveys to delete.
     * @example
     * // Delete a few Surveys
     * const { count } = await prisma.survey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SurveyDeleteManyArgs>(
      args?: SelectSubset<T, SurveyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surveys
     * const survey = await prisma.survey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SurveyUpdateManyArgs>(
      args: SelectSubset<T, SurveyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Survey.
     * @param {SurveyUpsertArgs} args - Arguments to update or create a Survey.
     * @example
     * // Update or create a Survey
     * const survey = await prisma.survey.upsert({
     *   create: {
     *     // ... data to create a Survey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Survey we want to update
     *   }
     * })
    **/
    upsert<T extends SurveyUpsertArgs>(
      args: SelectSubset<T, SurveyUpsertArgs>
    ): CheckSelect<T, Prisma__SurveyClient<Survey>, Prisma__SurveyClient<SurveyGetPayload<T>>>

    /**
     * Count the number of Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyCountArgs} args - Arguments to filter Surveys to count.
     * @example
     * // Count the number of Surveys
     * const count = await prisma.survey.count({
     *   where: {
     *     // ... the filter for the Surveys we want to count
     *   }
     * })
    **/
    count<T extends SurveyCountArgs>(
      args?: Subset<T, SurveyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyAggregateArgs>(args: Subset<T, SurveyAggregateArgs>): PrismaPromise<GetSurveyAggregateType<T>>

    /**
     * Group by Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyGroupByArgs['orderBy'] }
        : { orderBy?: SurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Survey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SurveyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateSurveyQuestions<T extends IntermediateSurveyQuestionFindManyArgs = {}>(args?: Subset<T, IntermediateSurveyQuestionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateSurveyQuestion>>, PrismaPromise<Array<IntermediateSurveyQuestionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Survey findUnique
   */
  export type SurveyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Survey
     * 
    **/
    select?: SurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyInclude | null
    /**
     * Throw an Error if a Survey can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Survey to fetch.
     * 
    **/
    where: SurveyWhereUniqueInput
  }


  /**
   * Survey findFirst
   */
  export type SurveyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Survey
     * 
    **/
    select?: SurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyInclude | null
    /**
     * Throw an Error if a Survey can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Survey to fetch.
     * 
    **/
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveys.
     * 
    **/
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveys.
     * 
    **/
    distinct?: Enumerable<SurveyScalarFieldEnum>
  }


  /**
   * Survey findMany
   */
  export type SurveyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Survey
     * 
    **/
    select?: SurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyInclude | null
    /**
     * Filter, which Surveys to fetch.
     * 
    **/
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Surveys.
     * 
    **/
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SurveyScalarFieldEnum>
  }


  /**
   * Survey create
   */
  export type SurveyCreateArgs = {
    /**
     * Select specific fields to fetch from the Survey
     * 
    **/
    select?: SurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyInclude | null
    /**
     * The data needed to create a Survey.
     * 
    **/
    data: XOR<SurveyCreateInput, SurveyUncheckedCreateInput>
  }


  /**
   * Survey createMany
   */
  export type SurveyCreateManyArgs = {
    data: Enumerable<SurveyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Survey update
   */
  export type SurveyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Survey
     * 
    **/
    select?: SurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyInclude | null
    /**
     * The data needed to update a Survey.
     * 
    **/
    data: XOR<SurveyUpdateInput, SurveyUncheckedUpdateInput>
    /**
     * Choose, which Survey to update.
     * 
    **/
    where: SurveyWhereUniqueInput
  }


  /**
   * Survey updateMany
   */
  export type SurveyUpdateManyArgs = {
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyInput>
    where?: SurveyWhereInput
  }


  /**
   * Survey upsert
   */
  export type SurveyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Survey
     * 
    **/
    select?: SurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyInclude | null
    /**
     * The filter to search for the Survey to update in case it exists.
     * 
    **/
    where: SurveyWhereUniqueInput
    /**
     * In case the Survey found by the `where` argument doesn't exist, create a new Survey with this data.
     * 
    **/
    create: XOR<SurveyCreateInput, SurveyUncheckedCreateInput>
    /**
     * In case the Survey was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SurveyUpdateInput, SurveyUncheckedUpdateInput>
  }


  /**
   * Survey delete
   */
  export type SurveyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Survey
     * 
    **/
    select?: SurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyInclude | null
    /**
     * Filter which Survey to delete.
     * 
    **/
    where: SurveyWhereUniqueInput
  }


  /**
   * Survey deleteMany
   */
  export type SurveyDeleteManyArgs = {
    where?: SurveyWhereInput
  }


  /**
   * Survey without action
   */
  export type SurveyArgs = {
    /**
     * Select specific fields to fetch from the Survey
     * 
    **/
    select?: SurveySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyInclude | null
  }



  /**
   * Model IntermediateSurveyQuestion
   */


  export type AggregateIntermediateSurveyQuestion = {
    _count: IntermediateSurveyQuestionCountAggregateOutputType | null
    _avg: IntermediateSurveyQuestionAvgAggregateOutputType | null
    _sum: IntermediateSurveyQuestionSumAggregateOutputType | null
    _min: IntermediateSurveyQuestionMinAggregateOutputType | null
    _max: IntermediateSurveyQuestionMaxAggregateOutputType | null
  }

  export type IntermediateSurveyQuestionAvgAggregateOutputType = {
    surveyId: number | null
    displayOrder: number | null
    surveyQuestionId: number | null
  }

  export type IntermediateSurveyQuestionSumAggregateOutputType = {
    surveyId: number | null
    displayOrder: number | null
    surveyQuestionId: number | null
  }

  export type IntermediateSurveyQuestionMinAggregateOutputType = {
    surveyId: number | null
    displayOrder: number | null
    surveyQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateSurveyQuestionMaxAggregateOutputType = {
    surveyId: number | null
    displayOrder: number | null
    surveyQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateSurveyQuestionCountAggregateOutputType = {
    surveyId: number
    displayOrder: number
    surveyQuestionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateSurveyQuestionAvgAggregateInputType = {
    surveyId?: true
    displayOrder?: true
    surveyQuestionId?: true
  }

  export type IntermediateSurveyQuestionSumAggregateInputType = {
    surveyId?: true
    displayOrder?: true
    surveyQuestionId?: true
  }

  export type IntermediateSurveyQuestionMinAggregateInputType = {
    surveyId?: true
    displayOrder?: true
    surveyQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateSurveyQuestionMaxAggregateInputType = {
    surveyId?: true
    displayOrder?: true
    surveyQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateSurveyQuestionCountAggregateInputType = {
    surveyId?: true
    displayOrder?: true
    surveyQuestionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateSurveyQuestionAggregateArgs = {
    /**
     * Filter which IntermediateSurveyQuestion to aggregate.
     * 
    **/
    where?: IntermediateSurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateSurveyQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateSurveyQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateSurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateSurveyQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateSurveyQuestions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateSurveyQuestions
    **/
    _count?: true | IntermediateSurveyQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateSurveyQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateSurveyQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateSurveyQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateSurveyQuestionMaxAggregateInputType
  }

  export type GetIntermediateSurveyQuestionAggregateType<T extends IntermediateSurveyQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateSurveyQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateSurveyQuestion[P]>
      : GetScalarType<T[P], AggregateIntermediateSurveyQuestion[P]>
  }




  export type IntermediateSurveyQuestionGroupByArgs = {
    where?: IntermediateSurveyQuestionWhereInput
    orderBy?: Enumerable<IntermediateSurveyQuestionOrderByWithAggregationInput>
    by: Array<IntermediateSurveyQuestionScalarFieldEnum>
    having?: IntermediateSurveyQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateSurveyQuestionCountAggregateInputType | true
    _avg?: IntermediateSurveyQuestionAvgAggregateInputType
    _sum?: IntermediateSurveyQuestionSumAggregateInputType
    _min?: IntermediateSurveyQuestionMinAggregateInputType
    _max?: IntermediateSurveyQuestionMaxAggregateInputType
  }


  export type IntermediateSurveyQuestionGroupByOutputType = {
    surveyId: number
    displayOrder: number | null
    surveyQuestionId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateSurveyQuestionCountAggregateOutputType | null
    _avg: IntermediateSurveyQuestionAvgAggregateOutputType | null
    _sum: IntermediateSurveyQuestionSumAggregateOutputType | null
    _min: IntermediateSurveyQuestionMinAggregateOutputType | null
    _max: IntermediateSurveyQuestionMaxAggregateOutputType | null
  }

  type GetIntermediateSurveyQuestionGroupByPayload<T extends IntermediateSurveyQuestionGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateSurveyQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateSurveyQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateSurveyQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateSurveyQuestionGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateSurveyQuestionSelect = {
    survey?: boolean | SurveyArgs
    surveyId?: boolean
    displayOrder?: boolean
    surveyQuestion?: boolean | SurveyQuestionArgs
    surveyQuestionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateSurveyQuestionInclude = {
    survey?: boolean | SurveyArgs
    surveyQuestion?: boolean | SurveyQuestionArgs
  }

  export type IntermediateSurveyQuestionGetPayload<
    S extends boolean | null | undefined | IntermediateSurveyQuestionArgs,
    U = keyof S
      > = S extends true
        ? IntermediateSurveyQuestion
    : S extends undefined
    ? never
    : S extends IntermediateSurveyQuestionArgs | IntermediateSurveyQuestionFindManyArgs
    ?'include' extends U
    ? IntermediateSurveyQuestion  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'survey'
        ? SurveyGetPayload<S['include'][P]> :
        P extends 'surveyQuestion'
        ? SurveyQuestionGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateSurveyQuestion ?IntermediateSurveyQuestion [P]
  : 
          P extends 'survey'
        ? SurveyGetPayload<S['select'][P]> :
        P extends 'surveyQuestion'
        ? SurveyQuestionGetPayload<S['select'][P]> : never
  } 
    : IntermediateSurveyQuestion
  : IntermediateSurveyQuestion


  type IntermediateSurveyQuestionCountArgs = Merge<
    Omit<IntermediateSurveyQuestionFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateSurveyQuestionCountAggregateInputType | true
    }
  >

  export interface IntermediateSurveyQuestionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateSurveyQuestion that matches the filter.
     * @param {IntermediateSurveyQuestionFindUniqueArgs} args - Arguments to find a IntermediateSurveyQuestion
     * @example
     * // Get one IntermediateSurveyQuestion
     * const intermediateSurveyQuestion = await prisma.intermediateSurveyQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateSurveyQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateSurveyQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateSurveyQuestion'> extends True ? CheckSelect<T, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestion>, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestionGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestion | null >, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestionGetPayload<T> | null >>

    /**
     * Find the first IntermediateSurveyQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionFindFirstArgs} args - Arguments to find a IntermediateSurveyQuestion
     * @example
     * // Get one IntermediateSurveyQuestion
     * const intermediateSurveyQuestion = await prisma.intermediateSurveyQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateSurveyQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateSurveyQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateSurveyQuestion'> extends True ? CheckSelect<T, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestion>, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestionGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestion | null >, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestionGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateSurveyQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateSurveyQuestions
     * const intermediateSurveyQuestions = await prisma.intermediateSurveyQuestion.findMany()
     * 
     * // Get first 10 IntermediateSurveyQuestions
     * const intermediateSurveyQuestions = await prisma.intermediateSurveyQuestion.findMany({ take: 10 })
     * 
     * // Only select the `surveyId`
     * const intermediateSurveyQuestionWithSurveyIdOnly = await prisma.intermediateSurveyQuestion.findMany({ select: { surveyId: true } })
     * 
    **/
    findMany<T extends IntermediateSurveyQuestionFindManyArgs>(
      args?: SelectSubset<T, IntermediateSurveyQuestionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateSurveyQuestion>>, PrismaPromise<Array<IntermediateSurveyQuestionGetPayload<T>>>>

    /**
     * Create a IntermediateSurveyQuestion.
     * @param {IntermediateSurveyQuestionCreateArgs} args - Arguments to create a IntermediateSurveyQuestion.
     * @example
     * // Create one IntermediateSurveyQuestion
     * const IntermediateSurveyQuestion = await prisma.intermediateSurveyQuestion.create({
     *   data: {
     *     // ... data to create a IntermediateSurveyQuestion
     *   }
     * })
     * 
    **/
    create<T extends IntermediateSurveyQuestionCreateArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestion>, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestionGetPayload<T>>>

    /**
     * Create many IntermediateSurveyQuestions.
     *     @param {IntermediateSurveyQuestionCreateManyArgs} args - Arguments to create many IntermediateSurveyQuestions.
     *     @example
     *     // Create many IntermediateSurveyQuestions
     *     const intermediateSurveyQuestion = await prisma.intermediateSurveyQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateSurveyQuestionCreateManyArgs>(
      args?: SelectSubset<T, IntermediateSurveyQuestionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateSurveyQuestion.
     * @param {IntermediateSurveyQuestionDeleteArgs} args - Arguments to delete one IntermediateSurveyQuestion.
     * @example
     * // Delete one IntermediateSurveyQuestion
     * const IntermediateSurveyQuestion = await prisma.intermediateSurveyQuestion.delete({
     *   where: {
     *     // ... filter to delete one IntermediateSurveyQuestion
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateSurveyQuestionDeleteArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestion>, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestionGetPayload<T>>>

    /**
     * Update one IntermediateSurveyQuestion.
     * @param {IntermediateSurveyQuestionUpdateArgs} args - Arguments to update one IntermediateSurveyQuestion.
     * @example
     * // Update one IntermediateSurveyQuestion
     * const intermediateSurveyQuestion = await prisma.intermediateSurveyQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateSurveyQuestionUpdateArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestion>, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestionGetPayload<T>>>

    /**
     * Delete zero or more IntermediateSurveyQuestions.
     * @param {IntermediateSurveyQuestionDeleteManyArgs} args - Arguments to filter IntermediateSurveyQuestions to delete.
     * @example
     * // Delete a few IntermediateSurveyQuestions
     * const { count } = await prisma.intermediateSurveyQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateSurveyQuestionDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateSurveyQuestionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateSurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateSurveyQuestions
     * const intermediateSurveyQuestion = await prisma.intermediateSurveyQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateSurveyQuestionUpdateManyArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateSurveyQuestion.
     * @param {IntermediateSurveyQuestionUpsertArgs} args - Arguments to update or create a IntermediateSurveyQuestion.
     * @example
     * // Update or create a IntermediateSurveyQuestion
     * const intermediateSurveyQuestion = await prisma.intermediateSurveyQuestion.upsert({
     *   create: {
     *     // ... data to create a IntermediateSurveyQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateSurveyQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateSurveyQuestionUpsertArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestion>, Prisma__IntermediateSurveyQuestionClient<IntermediateSurveyQuestionGetPayload<T>>>

    /**
     * Count the number of IntermediateSurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionCountArgs} args - Arguments to filter IntermediateSurveyQuestions to count.
     * @example
     * // Count the number of IntermediateSurveyQuestions
     * const count = await prisma.intermediateSurveyQuestion.count({
     *   where: {
     *     // ... the filter for the IntermediateSurveyQuestions we want to count
     *   }
     * })
    **/
    count<T extends IntermediateSurveyQuestionCountArgs>(
      args?: Subset<T, IntermediateSurveyQuestionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateSurveyQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateSurveyQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateSurveyQuestionAggregateArgs>(args: Subset<T, IntermediateSurveyQuestionAggregateArgs>): PrismaPromise<GetIntermediateSurveyQuestionAggregateType<T>>

    /**
     * Group by IntermediateSurveyQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateSurveyQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateSurveyQuestionGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateSurveyQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateSurveyQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateSurveyQuestionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateSurveyQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateSurveyQuestionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    survey<T extends SurveyArgs = {}>(args?: Subset<T, SurveyArgs>): CheckSelect<T, Prisma__SurveyClient<Survey | null >, Prisma__SurveyClient<SurveyGetPayload<T> | null >>;

    surveyQuestion<T extends SurveyQuestionArgs = {}>(args?: Subset<T, SurveyQuestionArgs>): CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion | null >, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateSurveyQuestion findUnique
   */
  export type IntermediateSurveyQuestionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestion
     * 
    **/
    select?: IntermediateSurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionInclude | null
    /**
     * Throw an Error if a IntermediateSurveyQuestion can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateSurveyQuestion to fetch.
     * 
    **/
    where: IntermediateSurveyQuestionWhereUniqueInput
  }


  /**
   * IntermediateSurveyQuestion findFirst
   */
  export type IntermediateSurveyQuestionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestion
     * 
    **/
    select?: IntermediateSurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionInclude | null
    /**
     * Throw an Error if a IntermediateSurveyQuestion can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateSurveyQuestion to fetch.
     * 
    **/
    where?: IntermediateSurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateSurveyQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateSurveyQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateSurveyQuestions.
     * 
    **/
    cursor?: IntermediateSurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateSurveyQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateSurveyQuestions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateSurveyQuestions.
     * 
    **/
    distinct?: Enumerable<IntermediateSurveyQuestionScalarFieldEnum>
  }


  /**
   * IntermediateSurveyQuestion findMany
   */
  export type IntermediateSurveyQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestion
     * 
    **/
    select?: IntermediateSurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionInclude | null
    /**
     * Filter, which IntermediateSurveyQuestions to fetch.
     * 
    **/
    where?: IntermediateSurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateSurveyQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateSurveyQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateSurveyQuestions.
     * 
    **/
    cursor?: IntermediateSurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateSurveyQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateSurveyQuestions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateSurveyQuestionScalarFieldEnum>
  }


  /**
   * IntermediateSurveyQuestion create
   */
  export type IntermediateSurveyQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestion
     * 
    **/
    select?: IntermediateSurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionInclude | null
    /**
     * The data needed to create a IntermediateSurveyQuestion.
     * 
    **/
    data: XOR<IntermediateSurveyQuestionCreateInput, IntermediateSurveyQuestionUncheckedCreateInput>
  }


  /**
   * IntermediateSurveyQuestion createMany
   */
  export type IntermediateSurveyQuestionCreateManyArgs = {
    data: Enumerable<IntermediateSurveyQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateSurveyQuestion update
   */
  export type IntermediateSurveyQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestion
     * 
    **/
    select?: IntermediateSurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionInclude | null
    /**
     * The data needed to update a IntermediateSurveyQuestion.
     * 
    **/
    data: XOR<IntermediateSurveyQuestionUpdateInput, IntermediateSurveyQuestionUncheckedUpdateInput>
    /**
     * Choose, which IntermediateSurveyQuestion to update.
     * 
    **/
    where: IntermediateSurveyQuestionWhereUniqueInput
  }


  /**
   * IntermediateSurveyQuestion updateMany
   */
  export type IntermediateSurveyQuestionUpdateManyArgs = {
    data: XOR<IntermediateSurveyQuestionUpdateManyMutationInput, IntermediateSurveyQuestionUncheckedUpdateManyInput>
    where?: IntermediateSurveyQuestionWhereInput
  }


  /**
   * IntermediateSurveyQuestion upsert
   */
  export type IntermediateSurveyQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestion
     * 
    **/
    select?: IntermediateSurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionInclude | null
    /**
     * The filter to search for the IntermediateSurveyQuestion to update in case it exists.
     * 
    **/
    where: IntermediateSurveyQuestionWhereUniqueInput
    /**
     * In case the IntermediateSurveyQuestion found by the `where` argument doesn't exist, create a new IntermediateSurveyQuestion with this data.
     * 
    **/
    create: XOR<IntermediateSurveyQuestionCreateInput, IntermediateSurveyQuestionUncheckedCreateInput>
    /**
     * In case the IntermediateSurveyQuestion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateSurveyQuestionUpdateInput, IntermediateSurveyQuestionUncheckedUpdateInput>
  }


  /**
   * IntermediateSurveyQuestion delete
   */
  export type IntermediateSurveyQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestion
     * 
    **/
    select?: IntermediateSurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionInclude | null
    /**
     * Filter which IntermediateSurveyQuestion to delete.
     * 
    **/
    where: IntermediateSurveyQuestionWhereUniqueInput
  }


  /**
   * IntermediateSurveyQuestion deleteMany
   */
  export type IntermediateSurveyQuestionDeleteManyArgs = {
    where?: IntermediateSurveyQuestionWhereInput
  }


  /**
   * IntermediateSurveyQuestion without action
   */
  export type IntermediateSurveyQuestionArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestion
     * 
    **/
    select?: IntermediateSurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionInclude | null
  }



  /**
   * Model SurveyQuestion
   */


  export type AggregateSurveyQuestion = {
    _count: SurveyQuestionCountAggregateOutputType | null
    _avg: SurveyQuestionAvgAggregateOutputType | null
    _sum: SurveyQuestionSumAggregateOutputType | null
    _min: SurveyQuestionMinAggregateOutputType | null
    _max: SurveyQuestionMaxAggregateOutputType | null
  }

  export type SurveyQuestionAvgAggregateOutputType = {
    id: number | null
    questionCategoryId: number | null
    surveyQuestionAnswerTypeId: number | null
  }

  export type SurveyQuestionSumAggregateOutputType = {
    id: number | null
    questionCategoryId: number | null
    surveyQuestionAnswerTypeId: number | null
  }

  export type SurveyQuestionMinAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    questionCategoryId: number | null
    mustBeAnswered: boolean | null
    instruction: string | null
    placeholder: string | null
    surveyQuestionAnswerTypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    questionCategoryId: number | null
    mustBeAnswered: boolean | null
    instruction: string | null
    placeholder: string | null
    surveyQuestionAnswerTypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionCountAggregateOutputType = {
    id: number
    name: number
    label: number
    questionCategoryId: number
    mustBeAnswered: number
    instruction: number
    placeholder: number
    surveyQuestionAnswerTypeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyQuestionAvgAggregateInputType = {
    id?: true
    questionCategoryId?: true
    surveyQuestionAnswerTypeId?: true
  }

  export type SurveyQuestionSumAggregateInputType = {
    id?: true
    questionCategoryId?: true
    surveyQuestionAnswerTypeId?: true
  }

  export type SurveyQuestionMinAggregateInputType = {
    id?: true
    name?: true
    label?: true
    questionCategoryId?: true
    mustBeAnswered?: true
    instruction?: true
    placeholder?: true
    surveyQuestionAnswerTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionMaxAggregateInputType = {
    id?: true
    name?: true
    label?: true
    questionCategoryId?: true
    mustBeAnswered?: true
    instruction?: true
    placeholder?: true
    surveyQuestionAnswerTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionCountAggregateInputType = {
    id?: true
    name?: true
    label?: true
    questionCategoryId?: true
    mustBeAnswered?: true
    instruction?: true
    placeholder?: true
    surveyQuestionAnswerTypeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyQuestionAggregateArgs = {
    /**
     * Filter which SurveyQuestion to aggregate.
     * 
    **/
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyQuestions
    **/
    _count?: true | SurveyQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyQuestionMaxAggregateInputType
  }

  export type GetSurveyQuestionAggregateType<T extends SurveyQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyQuestion[P]>
      : GetScalarType<T[P], AggregateSurveyQuestion[P]>
  }




  export type SurveyQuestionGroupByArgs = {
    where?: SurveyQuestionWhereInput
    orderBy?: Enumerable<SurveyQuestionOrderByWithAggregationInput>
    by: Array<SurveyQuestionScalarFieldEnum>
    having?: SurveyQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyQuestionCountAggregateInputType | true
    _avg?: SurveyQuestionAvgAggregateInputType
    _sum?: SurveyQuestionSumAggregateInputType
    _min?: SurveyQuestionMinAggregateInputType
    _max?: SurveyQuestionMaxAggregateInputType
  }


  export type SurveyQuestionGroupByOutputType = {
    id: number
    name: string
    label: string
    questionCategoryId: number
    mustBeAnswered: boolean
    instruction: string | null
    placeholder: string | null
    surveyQuestionAnswerTypeId: number
    createdAt: Date
    updatedAt: Date
    _count: SurveyQuestionCountAggregateOutputType | null
    _avg: SurveyQuestionAvgAggregateOutputType | null
    _sum: SurveyQuestionSumAggregateOutputType | null
    _min: SurveyQuestionMinAggregateOutputType | null
    _max: SurveyQuestionMaxAggregateOutputType | null
  }

  type GetSurveyQuestionGroupByPayload<T extends SurveyQuestionGroupByArgs> = Promise<
    Array<
      PickArray<SurveyQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyQuestionGroupByOutputType[P]>
        }
      >
    >


  export type SurveyQuestionSelect = {
    id?: boolean
    name?: boolean
    label?: boolean
    questionCategory?: boolean | QuestionCategoryArgs
    questionCategoryId?: boolean
    mustBeAnswered?: boolean
    instruction?: boolean
    placeholder?: boolean
    surveyQuestionAnswerType?: boolean | SurveyQuestionAnswerTypeArgs
    surveyQuestionAnswerTypeId?: boolean
    intermediateSurveyQuestions?: boolean | IntermediateSurveyQuestionFindManyArgs
    surveyQuestionOptions?: boolean | SurveyQuestionOptionFindManyArgs
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | SurveyQuestionCountOutputTypeArgs
  }

  export type SurveyQuestionInclude = {
    questionCategory?: boolean | QuestionCategoryArgs
    surveyQuestionAnswerType?: boolean | SurveyQuestionAnswerTypeArgs
    intermediateSurveyQuestions?: boolean | IntermediateSurveyQuestionFindManyArgs
    surveyQuestionOptions?: boolean | SurveyQuestionOptionFindManyArgs
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerFindManyArgs
    _count?: boolean | SurveyQuestionCountOutputTypeArgs
  }

  export type SurveyQuestionGetPayload<
    S extends boolean | null | undefined | SurveyQuestionArgs,
    U = keyof S
      > = S extends true
        ? SurveyQuestion
    : S extends undefined
    ? never
    : S extends SurveyQuestionArgs | SurveyQuestionFindManyArgs
    ?'include' extends U
    ? SurveyQuestion  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'questionCategory'
        ? QuestionCategoryGetPayload<S['include'][P]> :
        P extends 'surveyQuestionAnswerType'
        ? SurveyQuestionAnswerTypeGetPayload<S['include'][P]> :
        P extends 'intermediateSurveyQuestions'
        ? Array < IntermediateSurveyQuestionGetPayload<S['include'][P]>>  :
        P extends 'surveyQuestionOptions'
        ? Array < SurveyQuestionOptionGetPayload<S['include'][P]>>  :
        P extends 'surveyQuestionAnswer'
        ? Array < SurveyQuestionAnswerGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? SurveyQuestionCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyQuestion ?SurveyQuestion [P]
  : 
          P extends 'questionCategory'
        ? QuestionCategoryGetPayload<S['select'][P]> :
        P extends 'surveyQuestionAnswerType'
        ? SurveyQuestionAnswerTypeGetPayload<S['select'][P]> :
        P extends 'intermediateSurveyQuestions'
        ? Array < IntermediateSurveyQuestionGetPayload<S['select'][P]>>  :
        P extends 'surveyQuestionOptions'
        ? Array < SurveyQuestionOptionGetPayload<S['select'][P]>>  :
        P extends 'surveyQuestionAnswer'
        ? Array < SurveyQuestionAnswerGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? SurveyQuestionCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : SurveyQuestion
  : SurveyQuestion


  type SurveyQuestionCountArgs = Merge<
    Omit<SurveyQuestionFindManyArgs, 'select' | 'include'> & {
      select?: SurveyQuestionCountAggregateInputType | true
    }
  >

  export interface SurveyQuestionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SurveyQuestion that matches the filter.
     * @param {SurveyQuestionFindUniqueArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SurveyQuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SurveyQuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SurveyQuestion'> extends True ? CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion>, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T>>> : CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion | null >, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T> | null >>

    /**
     * Find the first SurveyQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionFindFirstArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SurveyQuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SurveyQuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SurveyQuestion'> extends True ? CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion>, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T>>> : CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion | null >, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T> | null >>

    /**
     * Find zero or more SurveyQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestion.findMany()
     * 
     * // Get first 10 SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyQuestionWithIdOnly = await prisma.surveyQuestion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SurveyQuestionFindManyArgs>(
      args?: SelectSubset<T, SurveyQuestionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SurveyQuestion>>, PrismaPromise<Array<SurveyQuestionGetPayload<T>>>>

    /**
     * Create a SurveyQuestion.
     * @param {SurveyQuestionCreateArgs} args - Arguments to create a SurveyQuestion.
     * @example
     * // Create one SurveyQuestion
     * const SurveyQuestion = await prisma.surveyQuestion.create({
     *   data: {
     *     // ... data to create a SurveyQuestion
     *   }
     * })
     * 
    **/
    create<T extends SurveyQuestionCreateArgs>(
      args: SelectSubset<T, SurveyQuestionCreateArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion>, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T>>>

    /**
     * Create many SurveyQuestions.
     *     @param {SurveyQuestionCreateManyArgs} args - Arguments to create many SurveyQuestions.
     *     @example
     *     // Create many SurveyQuestions
     *     const surveyQuestion = await prisma.surveyQuestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SurveyQuestionCreateManyArgs>(
      args?: SelectSubset<T, SurveyQuestionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyQuestion.
     * @param {SurveyQuestionDeleteArgs} args - Arguments to delete one SurveyQuestion.
     * @example
     * // Delete one SurveyQuestion
     * const SurveyQuestion = await prisma.surveyQuestion.delete({
     *   where: {
     *     // ... filter to delete one SurveyQuestion
     *   }
     * })
     * 
    **/
    delete<T extends SurveyQuestionDeleteArgs>(
      args: SelectSubset<T, SurveyQuestionDeleteArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion>, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T>>>

    /**
     * Update one SurveyQuestion.
     * @param {SurveyQuestionUpdateArgs} args - Arguments to update one SurveyQuestion.
     * @example
     * // Update one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SurveyQuestionUpdateArgs>(
      args: SelectSubset<T, SurveyQuestionUpdateArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion>, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T>>>

    /**
     * Delete zero or more SurveyQuestions.
     * @param {SurveyQuestionDeleteManyArgs} args - Arguments to filter SurveyQuestions to delete.
     * @example
     * // Delete a few SurveyQuestions
     * const { count } = await prisma.surveyQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SurveyQuestionDeleteManyArgs>(
      args?: SelectSubset<T, SurveyQuestionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyQuestions
     * const surveyQuestion = await prisma.surveyQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SurveyQuestionUpdateManyArgs>(
      args: SelectSubset<T, SurveyQuestionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyQuestion.
     * @param {SurveyQuestionUpsertArgs} args - Arguments to update or create a SurveyQuestion.
     * @example
     * // Update or create a SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.upsert({
     *   create: {
     *     // ... data to create a SurveyQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyQuestion we want to update
     *   }
     * })
    **/
    upsert<T extends SurveyQuestionUpsertArgs>(
      args: SelectSubset<T, SurveyQuestionUpsertArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion>, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T>>>

    /**
     * Count the number of SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionCountArgs} args - Arguments to filter SurveyQuestions to count.
     * @example
     * // Count the number of SurveyQuestions
     * const count = await prisma.surveyQuestion.count({
     *   where: {
     *     // ... the filter for the SurveyQuestions we want to count
     *   }
     * })
    **/
    count<T extends SurveyQuestionCountArgs>(
      args?: Subset<T, SurveyQuestionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyQuestionAggregateArgs>(args: Subset<T, SurveyQuestionAggregateArgs>): PrismaPromise<GetSurveyQuestionAggregateType<T>>

    /**
     * Group by SurveyQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyQuestionGroupByArgs['orderBy'] }
        : { orderBy?: SurveyQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyQuestionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SurveyQuestionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    questionCategory<T extends QuestionCategoryArgs = {}>(args?: Subset<T, QuestionCategoryArgs>): CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory | null >, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T> | null >>;

    surveyQuestionAnswerType<T extends SurveyQuestionAnswerTypeArgs = {}>(args?: Subset<T, SurveyQuestionAnswerTypeArgs>): CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType | null >, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T> | null >>;

    intermediateSurveyQuestions<T extends IntermediateSurveyQuestionFindManyArgs = {}>(args?: Subset<T, IntermediateSurveyQuestionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateSurveyQuestion>>, PrismaPromise<Array<IntermediateSurveyQuestionGetPayload<T>>>>;

    surveyQuestionOptions<T extends SurveyQuestionOptionFindManyArgs = {}>(args?: Subset<T, SurveyQuestionOptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SurveyQuestionOption>>, PrismaPromise<Array<SurveyQuestionOptionGetPayload<T>>>>;

    surveyQuestionAnswer<T extends SurveyQuestionAnswerFindManyArgs = {}>(args?: Subset<T, SurveyQuestionAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SurveyQuestionAnswer>>, PrismaPromise<Array<SurveyQuestionAnswerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SurveyQuestion findUnique
   */
  export type SurveyQuestionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     * 
    **/
    select?: SurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionInclude | null
    /**
     * Throw an Error if a SurveyQuestion can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SurveyQuestion to fetch.
     * 
    **/
    where: SurveyQuestionWhereUniqueInput
  }


  /**
   * SurveyQuestion findFirst
   */
  export type SurveyQuestionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     * 
    **/
    select?: SurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionInclude | null
    /**
     * Throw an Error if a SurveyQuestion can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SurveyQuestion to fetch.
     * 
    **/
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestions.
     * 
    **/
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestions.
     * 
    **/
    distinct?: Enumerable<SurveyQuestionScalarFieldEnum>
  }


  /**
   * SurveyQuestion findMany
   */
  export type SurveyQuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     * 
    **/
    select?: SurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionInclude | null
    /**
     * Filter, which SurveyQuestions to fetch.
     * 
    **/
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyQuestions.
     * 
    **/
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SurveyQuestionScalarFieldEnum>
  }


  /**
   * SurveyQuestion create
   */
  export type SurveyQuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     * 
    **/
    select?: SurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionInclude | null
    /**
     * The data needed to create a SurveyQuestion.
     * 
    **/
    data: XOR<SurveyQuestionCreateInput, SurveyQuestionUncheckedCreateInput>
  }


  /**
   * SurveyQuestion createMany
   */
  export type SurveyQuestionCreateManyArgs = {
    data: Enumerable<SurveyQuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SurveyQuestion update
   */
  export type SurveyQuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     * 
    **/
    select?: SurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionInclude | null
    /**
     * The data needed to update a SurveyQuestion.
     * 
    **/
    data: XOR<SurveyQuestionUpdateInput, SurveyQuestionUncheckedUpdateInput>
    /**
     * Choose, which SurveyQuestion to update.
     * 
    **/
    where: SurveyQuestionWhereUniqueInput
  }


  /**
   * SurveyQuestion updateMany
   */
  export type SurveyQuestionUpdateManyArgs = {
    data: XOR<SurveyQuestionUpdateManyMutationInput, SurveyQuestionUncheckedUpdateManyInput>
    where?: SurveyQuestionWhereInput
  }


  /**
   * SurveyQuestion upsert
   */
  export type SurveyQuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     * 
    **/
    select?: SurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionInclude | null
    /**
     * The filter to search for the SurveyQuestion to update in case it exists.
     * 
    **/
    where: SurveyQuestionWhereUniqueInput
    /**
     * In case the SurveyQuestion found by the `where` argument doesn't exist, create a new SurveyQuestion with this data.
     * 
    **/
    create: XOR<SurveyQuestionCreateInput, SurveyQuestionUncheckedCreateInput>
    /**
     * In case the SurveyQuestion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SurveyQuestionUpdateInput, SurveyQuestionUncheckedUpdateInput>
  }


  /**
   * SurveyQuestion delete
   */
  export type SurveyQuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     * 
    **/
    select?: SurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionInclude | null
    /**
     * Filter which SurveyQuestion to delete.
     * 
    **/
    where: SurveyQuestionWhereUniqueInput
  }


  /**
   * SurveyQuestion deleteMany
   */
  export type SurveyQuestionDeleteManyArgs = {
    where?: SurveyQuestionWhereInput
  }


  /**
   * SurveyQuestion without action
   */
  export type SurveyQuestionArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     * 
    **/
    select?: SurveyQuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionInclude | null
  }



  /**
   * Model QuestionCategory
   */


  export type AggregateQuestionCategory = {
    _count: QuestionCategoryCountAggregateOutputType | null
    _avg: QuestionCategoryAvgAggregateOutputType | null
    _sum: QuestionCategorySumAggregateOutputType | null
    _min: QuestionCategoryMinAggregateOutputType | null
    _max: QuestionCategoryMaxAggregateOutputType | null
  }

  export type QuestionCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type QuestionCategorySumAggregateOutputType = {
    id: number | null
  }

  export type QuestionCategoryMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionCategoryMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionCategoryCountAggregateOutputType = {
    id: number
    label: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionCategoryAvgAggregateInputType = {
    id?: true
  }

  export type QuestionCategorySumAggregateInputType = {
    id?: true
  }

  export type QuestionCategoryMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionCategoryMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionCategoryCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionCategoryAggregateArgs = {
    /**
     * Filter which QuestionCategory to aggregate.
     * 
    **/
    where?: QuestionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionCategories
    **/
    _count?: true | QuestionCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionCategoryMaxAggregateInputType
  }

  export type GetQuestionCategoryAggregateType<T extends QuestionCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionCategory[P]>
      : GetScalarType<T[P], AggregateQuestionCategory[P]>
  }




  export type QuestionCategoryGroupByArgs = {
    where?: QuestionCategoryWhereInput
    orderBy?: Enumerable<QuestionCategoryOrderByWithAggregationInput>
    by: Array<QuestionCategoryScalarFieldEnum>
    having?: QuestionCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCategoryCountAggregateInputType | true
    _avg?: QuestionCategoryAvgAggregateInputType
    _sum?: QuestionCategorySumAggregateInputType
    _min?: QuestionCategoryMinAggregateInputType
    _max?: QuestionCategoryMaxAggregateInputType
  }


  export type QuestionCategoryGroupByOutputType = {
    id: number
    label: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionCategoryCountAggregateOutputType | null
    _avg: QuestionCategoryAvgAggregateOutputType | null
    _sum: QuestionCategorySumAggregateOutputType | null
    _min: QuestionCategoryMinAggregateOutputType | null
    _max: QuestionCategoryMaxAggregateOutputType | null
  }

  type GetQuestionCategoryGroupByPayload<T extends QuestionCategoryGroupByArgs> = Promise<
    Array<
      PickArray<QuestionCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionCategoryGroupByOutputType[P]>
        }
      >
    >


  export type QuestionCategorySelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    surveyQuestions?: boolean | SurveyQuestionFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | QuestionCategoryCountOutputTypeArgs
  }

  export type QuestionCategoryInclude = {
    surveyQuestions?: boolean | SurveyQuestionFindManyArgs
    _count?: boolean | QuestionCategoryCountOutputTypeArgs
  }

  export type QuestionCategoryGetPayload<
    S extends boolean | null | undefined | QuestionCategoryArgs,
    U = keyof S
      > = S extends true
        ? QuestionCategory
    : S extends undefined
    ? never
    : S extends QuestionCategoryArgs | QuestionCategoryFindManyArgs
    ?'include' extends U
    ? QuestionCategory  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'surveyQuestions'
        ? Array < SurveyQuestionGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? QuestionCategoryCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof QuestionCategory ?QuestionCategory [P]
  : 
          P extends 'surveyQuestions'
        ? Array < SurveyQuestionGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? QuestionCategoryCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : QuestionCategory
  : QuestionCategory


  type QuestionCategoryCountArgs = Merge<
    Omit<QuestionCategoryFindManyArgs, 'select' | 'include'> & {
      select?: QuestionCategoryCountAggregateInputType | true
    }
  >

  export interface QuestionCategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one QuestionCategory that matches the filter.
     * @param {QuestionCategoryFindUniqueArgs} args - Arguments to find a QuestionCategory
     * @example
     * // Get one QuestionCategory
     * const questionCategory = await prisma.questionCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionCategory'> extends True ? CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory>, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T>>> : CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory | null >, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T> | null >>

    /**
     * Find the first QuestionCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryFindFirstArgs} args - Arguments to find a QuestionCategory
     * @example
     * // Get one QuestionCategory
     * const questionCategory = await prisma.questionCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionCategory'> extends True ? CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory>, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T>>> : CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory | null >, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T> | null >>

    /**
     * Find zero or more QuestionCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionCategories
     * const questionCategories = await prisma.questionCategory.findMany()
     * 
     * // Get first 10 QuestionCategories
     * const questionCategories = await prisma.questionCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionCategoryWithIdOnly = await prisma.questionCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionCategoryFindManyArgs>(
      args?: SelectSubset<T, QuestionCategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QuestionCategory>>, PrismaPromise<Array<QuestionCategoryGetPayload<T>>>>

    /**
     * Create a QuestionCategory.
     * @param {QuestionCategoryCreateArgs} args - Arguments to create a QuestionCategory.
     * @example
     * // Create one QuestionCategory
     * const QuestionCategory = await prisma.questionCategory.create({
     *   data: {
     *     // ... data to create a QuestionCategory
     *   }
     * })
     * 
    **/
    create<T extends QuestionCategoryCreateArgs>(
      args: SelectSubset<T, QuestionCategoryCreateArgs>
    ): CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory>, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T>>>

    /**
     * Create many QuestionCategories.
     *     @param {QuestionCategoryCreateManyArgs} args - Arguments to create many QuestionCategories.
     *     @example
     *     // Create many QuestionCategories
     *     const questionCategory = await prisma.questionCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionCategoryCreateManyArgs>(
      args?: SelectSubset<T, QuestionCategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionCategory.
     * @param {QuestionCategoryDeleteArgs} args - Arguments to delete one QuestionCategory.
     * @example
     * // Delete one QuestionCategory
     * const QuestionCategory = await prisma.questionCategory.delete({
     *   where: {
     *     // ... filter to delete one QuestionCategory
     *   }
     * })
     * 
    **/
    delete<T extends QuestionCategoryDeleteArgs>(
      args: SelectSubset<T, QuestionCategoryDeleteArgs>
    ): CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory>, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T>>>

    /**
     * Update one QuestionCategory.
     * @param {QuestionCategoryUpdateArgs} args - Arguments to update one QuestionCategory.
     * @example
     * // Update one QuestionCategory
     * const questionCategory = await prisma.questionCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionCategoryUpdateArgs>(
      args: SelectSubset<T, QuestionCategoryUpdateArgs>
    ): CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory>, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T>>>

    /**
     * Delete zero or more QuestionCategories.
     * @param {QuestionCategoryDeleteManyArgs} args - Arguments to filter QuestionCategories to delete.
     * @example
     * // Delete a few QuestionCategories
     * const { count } = await prisma.questionCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionCategoryDeleteManyArgs>(
      args?: SelectSubset<T, QuestionCategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionCategories
     * const questionCategory = await prisma.questionCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionCategoryUpdateManyArgs>(
      args: SelectSubset<T, QuestionCategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionCategory.
     * @param {QuestionCategoryUpsertArgs} args - Arguments to update or create a QuestionCategory.
     * @example
     * // Update or create a QuestionCategory
     * const questionCategory = await prisma.questionCategory.upsert({
     *   create: {
     *     // ... data to create a QuestionCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionCategory we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionCategoryUpsertArgs>(
      args: SelectSubset<T, QuestionCategoryUpsertArgs>
    ): CheckSelect<T, Prisma__QuestionCategoryClient<QuestionCategory>, Prisma__QuestionCategoryClient<QuestionCategoryGetPayload<T>>>

    /**
     * Count the number of QuestionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryCountArgs} args - Arguments to filter QuestionCategories to count.
     * @example
     * // Count the number of QuestionCategories
     * const count = await prisma.questionCategory.count({
     *   where: {
     *     // ... the filter for the QuestionCategories we want to count
     *   }
     * })
    **/
    count<T extends QuestionCategoryCountArgs>(
      args?: Subset<T, QuestionCategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionCategoryAggregateArgs>(args: Subset<T, QuestionCategoryAggregateArgs>): PrismaPromise<GetQuestionCategoryAggregateType<T>>

    /**
     * Group by QuestionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionCategoryGroupByArgs['orderBy'] }
        : { orderBy?: QuestionCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionCategoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionCategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    surveyQuestions<T extends SurveyQuestionFindManyArgs = {}>(args?: Subset<T, SurveyQuestionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SurveyQuestion>>, PrismaPromise<Array<SurveyQuestionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * QuestionCategory findUnique
   */
  export type QuestionCategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     * 
    **/
    select?: QuestionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionCategoryInclude | null
    /**
     * Throw an Error if a QuestionCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which QuestionCategory to fetch.
     * 
    **/
    where: QuestionCategoryWhereUniqueInput
  }


  /**
   * QuestionCategory findFirst
   */
  export type QuestionCategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     * 
    **/
    select?: QuestionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionCategoryInclude | null
    /**
     * Throw an Error if a QuestionCategory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which QuestionCategory to fetch.
     * 
    **/
    where?: QuestionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionCategories.
     * 
    **/
    cursor?: QuestionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionCategories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionCategories.
     * 
    **/
    distinct?: Enumerable<QuestionCategoryScalarFieldEnum>
  }


  /**
   * QuestionCategory findMany
   */
  export type QuestionCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     * 
    **/
    select?: QuestionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionCategoryInclude | null
    /**
     * Filter, which QuestionCategories to fetch.
     * 
    **/
    where?: QuestionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionCategories to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionCategories.
     * 
    **/
    cursor?: QuestionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionCategories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionCategories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionCategoryScalarFieldEnum>
  }


  /**
   * QuestionCategory create
   */
  export type QuestionCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     * 
    **/
    select?: QuestionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionCategoryInclude | null
    /**
     * The data needed to create a QuestionCategory.
     * 
    **/
    data: XOR<QuestionCategoryCreateInput, QuestionCategoryUncheckedCreateInput>
  }


  /**
   * QuestionCategory createMany
   */
  export type QuestionCategoryCreateManyArgs = {
    data: Enumerable<QuestionCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionCategory update
   */
  export type QuestionCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     * 
    **/
    select?: QuestionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionCategoryInclude | null
    /**
     * The data needed to update a QuestionCategory.
     * 
    **/
    data: XOR<QuestionCategoryUpdateInput, QuestionCategoryUncheckedUpdateInput>
    /**
     * Choose, which QuestionCategory to update.
     * 
    **/
    where: QuestionCategoryWhereUniqueInput
  }


  /**
   * QuestionCategory updateMany
   */
  export type QuestionCategoryUpdateManyArgs = {
    data: XOR<QuestionCategoryUpdateManyMutationInput, QuestionCategoryUncheckedUpdateManyInput>
    where?: QuestionCategoryWhereInput
  }


  /**
   * QuestionCategory upsert
   */
  export type QuestionCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     * 
    **/
    select?: QuestionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionCategoryInclude | null
    /**
     * The filter to search for the QuestionCategory to update in case it exists.
     * 
    **/
    where: QuestionCategoryWhereUniqueInput
    /**
     * In case the QuestionCategory found by the `where` argument doesn't exist, create a new QuestionCategory with this data.
     * 
    **/
    create: XOR<QuestionCategoryCreateInput, QuestionCategoryUncheckedCreateInput>
    /**
     * In case the QuestionCategory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionCategoryUpdateInput, QuestionCategoryUncheckedUpdateInput>
  }


  /**
   * QuestionCategory delete
   */
  export type QuestionCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     * 
    **/
    select?: QuestionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionCategoryInclude | null
    /**
     * Filter which QuestionCategory to delete.
     * 
    **/
    where: QuestionCategoryWhereUniqueInput
  }


  /**
   * QuestionCategory deleteMany
   */
  export type QuestionCategoryDeleteManyArgs = {
    where?: QuestionCategoryWhereInput
  }


  /**
   * QuestionCategory without action
   */
  export type QuestionCategoryArgs = {
    /**
     * Select specific fields to fetch from the QuestionCategory
     * 
    **/
    select?: QuestionCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionCategoryInclude | null
  }



  /**
   * Model SurveyQuestionAnswerType
   */


  export type AggregateSurveyQuestionAnswerType = {
    _count: SurveyQuestionAnswerTypeCountAggregateOutputType | null
    _avg: SurveyQuestionAnswerTypeAvgAggregateOutputType | null
    _sum: SurveyQuestionAnswerTypeSumAggregateOutputType | null
    _min: SurveyQuestionAnswerTypeMinAggregateOutputType | null
    _max: SurveyQuestionAnswerTypeMaxAggregateOutputType | null
  }

  export type SurveyQuestionAnswerTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type SurveyQuestionAnswerTypeSumAggregateOutputType = {
    id: number | null
  }

  export type SurveyQuestionAnswerTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionAnswerTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionAnswerTypeCountAggregateOutputType = {
    id: number
    name: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyQuestionAnswerTypeAvgAggregateInputType = {
    id?: true
  }

  export type SurveyQuestionAnswerTypeSumAggregateInputType = {
    id?: true
  }

  export type SurveyQuestionAnswerTypeMinAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionAnswerTypeMaxAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionAnswerTypeCountAggregateInputType = {
    id?: true
    name?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyQuestionAnswerTypeAggregateArgs = {
    /**
     * Filter which SurveyQuestionAnswerType to aggregate.
     * 
    **/
    where?: SurveyQuestionAnswerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionAnswerTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionAnswerTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SurveyQuestionAnswerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionAnswerTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionAnswerTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyQuestionAnswerTypes
    **/
    _count?: true | SurveyQuestionAnswerTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyQuestionAnswerTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyQuestionAnswerTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyQuestionAnswerTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyQuestionAnswerTypeMaxAggregateInputType
  }

  export type GetSurveyQuestionAnswerTypeAggregateType<T extends SurveyQuestionAnswerTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyQuestionAnswerType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyQuestionAnswerType[P]>
      : GetScalarType<T[P], AggregateSurveyQuestionAnswerType[P]>
  }




  export type SurveyQuestionAnswerTypeGroupByArgs = {
    where?: SurveyQuestionAnswerTypeWhereInput
    orderBy?: Enumerable<SurveyQuestionAnswerTypeOrderByWithAggregationInput>
    by: Array<SurveyQuestionAnswerTypeScalarFieldEnum>
    having?: SurveyQuestionAnswerTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyQuestionAnswerTypeCountAggregateInputType | true
    _avg?: SurveyQuestionAnswerTypeAvgAggregateInputType
    _sum?: SurveyQuestionAnswerTypeSumAggregateInputType
    _min?: SurveyQuestionAnswerTypeMinAggregateInputType
    _max?: SurveyQuestionAnswerTypeMaxAggregateInputType
  }


  export type SurveyQuestionAnswerTypeGroupByOutputType = {
    id: number
    name: string
    label: string
    createdAt: Date
    updatedAt: Date
    _count: SurveyQuestionAnswerTypeCountAggregateOutputType | null
    _avg: SurveyQuestionAnswerTypeAvgAggregateOutputType | null
    _sum: SurveyQuestionAnswerTypeSumAggregateOutputType | null
    _min: SurveyQuestionAnswerTypeMinAggregateOutputType | null
    _max: SurveyQuestionAnswerTypeMaxAggregateOutputType | null
  }

  type GetSurveyQuestionAnswerTypeGroupByPayload<T extends SurveyQuestionAnswerTypeGroupByArgs> = Promise<
    Array<
      PickArray<SurveyQuestionAnswerTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyQuestionAnswerTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyQuestionAnswerTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyQuestionAnswerTypeGroupByOutputType[P]>
        }
      >
    >


  export type SurveyQuestionAnswerTypeSelect = {
    id?: boolean
    name?: boolean
    label?: boolean
    surveyQuestions?: boolean | SurveyQuestionFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | SurveyQuestionAnswerTypeCountOutputTypeArgs
  }

  export type SurveyQuestionAnswerTypeInclude = {
    surveyQuestions?: boolean | SurveyQuestionFindManyArgs
    _count?: boolean | SurveyQuestionAnswerTypeCountOutputTypeArgs
  }

  export type SurveyQuestionAnswerTypeGetPayload<
    S extends boolean | null | undefined | SurveyQuestionAnswerTypeArgs,
    U = keyof S
      > = S extends true
        ? SurveyQuestionAnswerType
    : S extends undefined
    ? never
    : S extends SurveyQuestionAnswerTypeArgs | SurveyQuestionAnswerTypeFindManyArgs
    ?'include' extends U
    ? SurveyQuestionAnswerType  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'surveyQuestions'
        ? Array < SurveyQuestionGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? SurveyQuestionAnswerTypeCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyQuestionAnswerType ?SurveyQuestionAnswerType [P]
  : 
          P extends 'surveyQuestions'
        ? Array < SurveyQuestionGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? SurveyQuestionAnswerTypeCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : SurveyQuestionAnswerType
  : SurveyQuestionAnswerType


  type SurveyQuestionAnswerTypeCountArgs = Merge<
    Omit<SurveyQuestionAnswerTypeFindManyArgs, 'select' | 'include'> & {
      select?: SurveyQuestionAnswerTypeCountAggregateInputType | true
    }
  >

  export interface SurveyQuestionAnswerTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SurveyQuestionAnswerType that matches the filter.
     * @param {SurveyQuestionAnswerTypeFindUniqueArgs} args - Arguments to find a SurveyQuestionAnswerType
     * @example
     * // Get one SurveyQuestionAnswerType
     * const surveyQuestionAnswerType = await prisma.surveyQuestionAnswerType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SurveyQuestionAnswerTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SurveyQuestionAnswerTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SurveyQuestionAnswerType'> extends True ? CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType>, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T>>> : CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType | null >, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T> | null >>

    /**
     * Find the first SurveyQuestionAnswerType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerTypeFindFirstArgs} args - Arguments to find a SurveyQuestionAnswerType
     * @example
     * // Get one SurveyQuestionAnswerType
     * const surveyQuestionAnswerType = await prisma.surveyQuestionAnswerType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SurveyQuestionAnswerTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SurveyQuestionAnswerTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SurveyQuestionAnswerType'> extends True ? CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType>, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T>>> : CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType | null >, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T> | null >>

    /**
     * Find zero or more SurveyQuestionAnswerTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyQuestionAnswerTypes
     * const surveyQuestionAnswerTypes = await prisma.surveyQuestionAnswerType.findMany()
     * 
     * // Get first 10 SurveyQuestionAnswerTypes
     * const surveyQuestionAnswerTypes = await prisma.surveyQuestionAnswerType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyQuestionAnswerTypeWithIdOnly = await prisma.surveyQuestionAnswerType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SurveyQuestionAnswerTypeFindManyArgs>(
      args?: SelectSubset<T, SurveyQuestionAnswerTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SurveyQuestionAnswerType>>, PrismaPromise<Array<SurveyQuestionAnswerTypeGetPayload<T>>>>

    /**
     * Create a SurveyQuestionAnswerType.
     * @param {SurveyQuestionAnswerTypeCreateArgs} args - Arguments to create a SurveyQuestionAnswerType.
     * @example
     * // Create one SurveyQuestionAnswerType
     * const SurveyQuestionAnswerType = await prisma.surveyQuestionAnswerType.create({
     *   data: {
     *     // ... data to create a SurveyQuestionAnswerType
     *   }
     * })
     * 
    **/
    create<T extends SurveyQuestionAnswerTypeCreateArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerTypeCreateArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType>, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T>>>

    /**
     * Create many SurveyQuestionAnswerTypes.
     *     @param {SurveyQuestionAnswerTypeCreateManyArgs} args - Arguments to create many SurveyQuestionAnswerTypes.
     *     @example
     *     // Create many SurveyQuestionAnswerTypes
     *     const surveyQuestionAnswerType = await prisma.surveyQuestionAnswerType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SurveyQuestionAnswerTypeCreateManyArgs>(
      args?: SelectSubset<T, SurveyQuestionAnswerTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyQuestionAnswerType.
     * @param {SurveyQuestionAnswerTypeDeleteArgs} args - Arguments to delete one SurveyQuestionAnswerType.
     * @example
     * // Delete one SurveyQuestionAnswerType
     * const SurveyQuestionAnswerType = await prisma.surveyQuestionAnswerType.delete({
     *   where: {
     *     // ... filter to delete one SurveyQuestionAnswerType
     *   }
     * })
     * 
    **/
    delete<T extends SurveyQuestionAnswerTypeDeleteArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerTypeDeleteArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType>, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T>>>

    /**
     * Update one SurveyQuestionAnswerType.
     * @param {SurveyQuestionAnswerTypeUpdateArgs} args - Arguments to update one SurveyQuestionAnswerType.
     * @example
     * // Update one SurveyQuestionAnswerType
     * const surveyQuestionAnswerType = await prisma.surveyQuestionAnswerType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SurveyQuestionAnswerTypeUpdateArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerTypeUpdateArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType>, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T>>>

    /**
     * Delete zero or more SurveyQuestionAnswerTypes.
     * @param {SurveyQuestionAnswerTypeDeleteManyArgs} args - Arguments to filter SurveyQuestionAnswerTypes to delete.
     * @example
     * // Delete a few SurveyQuestionAnswerTypes
     * const { count } = await prisma.surveyQuestionAnswerType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SurveyQuestionAnswerTypeDeleteManyArgs>(
      args?: SelectSubset<T, SurveyQuestionAnswerTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestionAnswerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyQuestionAnswerTypes
     * const surveyQuestionAnswerType = await prisma.surveyQuestionAnswerType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SurveyQuestionAnswerTypeUpdateManyArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyQuestionAnswerType.
     * @param {SurveyQuestionAnswerTypeUpsertArgs} args - Arguments to update or create a SurveyQuestionAnswerType.
     * @example
     * // Update or create a SurveyQuestionAnswerType
     * const surveyQuestionAnswerType = await prisma.surveyQuestionAnswerType.upsert({
     *   create: {
     *     // ... data to create a SurveyQuestionAnswerType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyQuestionAnswerType we want to update
     *   }
     * })
    **/
    upsert<T extends SurveyQuestionAnswerTypeUpsertArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerTypeUpsertArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerType>, Prisma__SurveyQuestionAnswerTypeClient<SurveyQuestionAnswerTypeGetPayload<T>>>

    /**
     * Count the number of SurveyQuestionAnswerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerTypeCountArgs} args - Arguments to filter SurveyQuestionAnswerTypes to count.
     * @example
     * // Count the number of SurveyQuestionAnswerTypes
     * const count = await prisma.surveyQuestionAnswerType.count({
     *   where: {
     *     // ... the filter for the SurveyQuestionAnswerTypes we want to count
     *   }
     * })
    **/
    count<T extends SurveyQuestionAnswerTypeCountArgs>(
      args?: Subset<T, SurveyQuestionAnswerTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyQuestionAnswerTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyQuestionAnswerType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyQuestionAnswerTypeAggregateArgs>(args: Subset<T, SurveyQuestionAnswerTypeAggregateArgs>): PrismaPromise<GetSurveyQuestionAnswerTypeAggregateType<T>>

    /**
     * Group by SurveyQuestionAnswerType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyQuestionAnswerTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyQuestionAnswerTypeGroupByArgs['orderBy'] }
        : { orderBy?: SurveyQuestionAnswerTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyQuestionAnswerTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyQuestionAnswerTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyQuestionAnswerType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SurveyQuestionAnswerTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    surveyQuestions<T extends SurveyQuestionFindManyArgs = {}>(args?: Subset<T, SurveyQuestionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SurveyQuestion>>, PrismaPromise<Array<SurveyQuestionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SurveyQuestionAnswerType findUnique
   */
  export type SurveyQuestionAnswerTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerType
     * 
    **/
    select?: SurveyQuestionAnswerTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerTypeInclude | null
    /**
     * Throw an Error if a SurveyQuestionAnswerType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SurveyQuestionAnswerType to fetch.
     * 
    **/
    where: SurveyQuestionAnswerTypeWhereUniqueInput
  }


  /**
   * SurveyQuestionAnswerType findFirst
   */
  export type SurveyQuestionAnswerTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerType
     * 
    **/
    select?: SurveyQuestionAnswerTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerTypeInclude | null
    /**
     * Throw an Error if a SurveyQuestionAnswerType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SurveyQuestionAnswerType to fetch.
     * 
    **/
    where?: SurveyQuestionAnswerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionAnswerTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionAnswerTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestionAnswerTypes.
     * 
    **/
    cursor?: SurveyQuestionAnswerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionAnswerTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionAnswerTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestionAnswerTypes.
     * 
    **/
    distinct?: Enumerable<SurveyQuestionAnswerTypeScalarFieldEnum>
  }


  /**
   * SurveyQuestionAnswerType findMany
   */
  export type SurveyQuestionAnswerTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerType
     * 
    **/
    select?: SurveyQuestionAnswerTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerTypeInclude | null
    /**
     * Filter, which SurveyQuestionAnswerTypes to fetch.
     * 
    **/
    where?: SurveyQuestionAnswerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionAnswerTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionAnswerTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyQuestionAnswerTypes.
     * 
    **/
    cursor?: SurveyQuestionAnswerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionAnswerTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionAnswerTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SurveyQuestionAnswerTypeScalarFieldEnum>
  }


  /**
   * SurveyQuestionAnswerType create
   */
  export type SurveyQuestionAnswerTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerType
     * 
    **/
    select?: SurveyQuestionAnswerTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerTypeInclude | null
    /**
     * The data needed to create a SurveyQuestionAnswerType.
     * 
    **/
    data: XOR<SurveyQuestionAnswerTypeCreateInput, SurveyQuestionAnswerTypeUncheckedCreateInput>
  }


  /**
   * SurveyQuestionAnswerType createMany
   */
  export type SurveyQuestionAnswerTypeCreateManyArgs = {
    data: Enumerable<SurveyQuestionAnswerTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SurveyQuestionAnswerType update
   */
  export type SurveyQuestionAnswerTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerType
     * 
    **/
    select?: SurveyQuestionAnswerTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerTypeInclude | null
    /**
     * The data needed to update a SurveyQuestionAnswerType.
     * 
    **/
    data: XOR<SurveyQuestionAnswerTypeUpdateInput, SurveyQuestionAnswerTypeUncheckedUpdateInput>
    /**
     * Choose, which SurveyQuestionAnswerType to update.
     * 
    **/
    where: SurveyQuestionAnswerTypeWhereUniqueInput
  }


  /**
   * SurveyQuestionAnswerType updateMany
   */
  export type SurveyQuestionAnswerTypeUpdateManyArgs = {
    data: XOR<SurveyQuestionAnswerTypeUpdateManyMutationInput, SurveyQuestionAnswerTypeUncheckedUpdateManyInput>
    where?: SurveyQuestionAnswerTypeWhereInput
  }


  /**
   * SurveyQuestionAnswerType upsert
   */
  export type SurveyQuestionAnswerTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerType
     * 
    **/
    select?: SurveyQuestionAnswerTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerTypeInclude | null
    /**
     * The filter to search for the SurveyQuestionAnswerType to update in case it exists.
     * 
    **/
    where: SurveyQuestionAnswerTypeWhereUniqueInput
    /**
     * In case the SurveyQuestionAnswerType found by the `where` argument doesn't exist, create a new SurveyQuestionAnswerType with this data.
     * 
    **/
    create: XOR<SurveyQuestionAnswerTypeCreateInput, SurveyQuestionAnswerTypeUncheckedCreateInput>
    /**
     * In case the SurveyQuestionAnswerType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SurveyQuestionAnswerTypeUpdateInput, SurveyQuestionAnswerTypeUncheckedUpdateInput>
  }


  /**
   * SurveyQuestionAnswerType delete
   */
  export type SurveyQuestionAnswerTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerType
     * 
    **/
    select?: SurveyQuestionAnswerTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerTypeInclude | null
    /**
     * Filter which SurveyQuestionAnswerType to delete.
     * 
    **/
    where: SurveyQuestionAnswerTypeWhereUniqueInput
  }


  /**
   * SurveyQuestionAnswerType deleteMany
   */
  export type SurveyQuestionAnswerTypeDeleteManyArgs = {
    where?: SurveyQuestionAnswerTypeWhereInput
  }


  /**
   * SurveyQuestionAnswerType without action
   */
  export type SurveyQuestionAnswerTypeArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswerType
     * 
    **/
    select?: SurveyQuestionAnswerTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerTypeInclude | null
  }



  /**
   * Model SurveyQuestionOption
   */


  export type AggregateSurveyQuestionOption = {
    _count: SurveyQuestionOptionCountAggregateOutputType | null
    _avg: SurveyQuestionOptionAvgAggregateOutputType | null
    _sum: SurveyQuestionOptionSumAggregateOutputType | null
    _min: SurveyQuestionOptionMinAggregateOutputType | null
    _max: SurveyQuestionOptionMaxAggregateOutputType | null
  }

  export type SurveyQuestionOptionAvgAggregateOutputType = {
    id: number | null
    surveyQuestionId: number | null
  }

  export type SurveyQuestionOptionSumAggregateOutputType = {
    id: number | null
    surveyQuestionId: number | null
  }

  export type SurveyQuestionOptionMinAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    surveyQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionOptionMaxAggregateOutputType = {
    id: number | null
    label: string | null
    name: string | null
    surveyQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionOptionCountAggregateOutputType = {
    id: number
    label: number
    name: number
    surveyQuestionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyQuestionOptionAvgAggregateInputType = {
    id?: true
    surveyQuestionId?: true
  }

  export type SurveyQuestionOptionSumAggregateInputType = {
    id?: true
    surveyQuestionId?: true
  }

  export type SurveyQuestionOptionMinAggregateInputType = {
    id?: true
    label?: true
    name?: true
    surveyQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionOptionMaxAggregateInputType = {
    id?: true
    label?: true
    name?: true
    surveyQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionOptionCountAggregateInputType = {
    id?: true
    label?: true
    name?: true
    surveyQuestionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyQuestionOptionAggregateArgs = {
    /**
     * Filter which SurveyQuestionOption to aggregate.
     * 
    **/
    where?: SurveyQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionOptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SurveyQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionOptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyQuestionOptions
    **/
    _count?: true | SurveyQuestionOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyQuestionOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyQuestionOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyQuestionOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyQuestionOptionMaxAggregateInputType
  }

  export type GetSurveyQuestionOptionAggregateType<T extends SurveyQuestionOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyQuestionOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyQuestionOption[P]>
      : GetScalarType<T[P], AggregateSurveyQuestionOption[P]>
  }




  export type SurveyQuestionOptionGroupByArgs = {
    where?: SurveyQuestionOptionWhereInput
    orderBy?: Enumerable<SurveyQuestionOptionOrderByWithAggregationInput>
    by: Array<SurveyQuestionOptionScalarFieldEnum>
    having?: SurveyQuestionOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyQuestionOptionCountAggregateInputType | true
    _avg?: SurveyQuestionOptionAvgAggregateInputType
    _sum?: SurveyQuestionOptionSumAggregateInputType
    _min?: SurveyQuestionOptionMinAggregateInputType
    _max?: SurveyQuestionOptionMaxAggregateInputType
  }


  export type SurveyQuestionOptionGroupByOutputType = {
    id: number
    label: string
    name: string
    surveyQuestionId: number
    createdAt: Date
    updatedAt: Date
    _count: SurveyQuestionOptionCountAggregateOutputType | null
    _avg: SurveyQuestionOptionAvgAggregateOutputType | null
    _sum: SurveyQuestionOptionSumAggregateOutputType | null
    _min: SurveyQuestionOptionMinAggregateOutputType | null
    _max: SurveyQuestionOptionMaxAggregateOutputType | null
  }

  type GetSurveyQuestionOptionGroupByPayload<T extends SurveyQuestionOptionGroupByArgs> = Promise<
    Array<
      PickArray<SurveyQuestionOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyQuestionOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyQuestionOptionGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyQuestionOptionGroupByOutputType[P]>
        }
      >
    >


  export type SurveyQuestionOptionSelect = {
    id?: boolean
    label?: boolean
    name?: boolean
    surveyQuestion?: boolean | SurveyQuestionArgs
    surveyQuestionId?: boolean
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerFindManyArgs
    intermediateSurveyQuestionAnswerProduct?: boolean | IntermediateSurveyQuestionAnswerProductFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | SurveyQuestionOptionCountOutputTypeArgs
  }

  export type SurveyQuestionOptionInclude = {
    surveyQuestion?: boolean | SurveyQuestionArgs
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerFindManyArgs
    intermediateSurveyQuestionAnswerProduct?: boolean | IntermediateSurveyQuestionAnswerProductFindManyArgs
    _count?: boolean | SurveyQuestionOptionCountOutputTypeArgs
  }

  export type SurveyQuestionOptionGetPayload<
    S extends boolean | null | undefined | SurveyQuestionOptionArgs,
    U = keyof S
      > = S extends true
        ? SurveyQuestionOption
    : S extends undefined
    ? never
    : S extends SurveyQuestionOptionArgs | SurveyQuestionOptionFindManyArgs
    ?'include' extends U
    ? SurveyQuestionOption  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'surveyQuestion'
        ? SurveyQuestionGetPayload<S['include'][P]> :
        P extends 'surveyQuestionAnswer'
        ? Array < SurveyQuestionAnswerGetPayload<S['include'][P]>>  :
        P extends 'intermediateSurveyQuestionAnswerProduct'
        ? Array < IntermediateSurveyQuestionAnswerProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? SurveyQuestionOptionCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyQuestionOption ?SurveyQuestionOption [P]
  : 
          P extends 'surveyQuestion'
        ? SurveyQuestionGetPayload<S['select'][P]> :
        P extends 'surveyQuestionAnswer'
        ? Array < SurveyQuestionAnswerGetPayload<S['select'][P]>>  :
        P extends 'intermediateSurveyQuestionAnswerProduct'
        ? Array < IntermediateSurveyQuestionAnswerProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? SurveyQuestionOptionCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : SurveyQuestionOption
  : SurveyQuestionOption


  type SurveyQuestionOptionCountArgs = Merge<
    Omit<SurveyQuestionOptionFindManyArgs, 'select' | 'include'> & {
      select?: SurveyQuestionOptionCountAggregateInputType | true
    }
  >

  export interface SurveyQuestionOptionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SurveyQuestionOption that matches the filter.
     * @param {SurveyQuestionOptionFindUniqueArgs} args - Arguments to find a SurveyQuestionOption
     * @example
     * // Get one SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SurveyQuestionOptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SurveyQuestionOptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SurveyQuestionOption'> extends True ? CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption>, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T>>> : CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption | null >, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T> | null >>

    /**
     * Find the first SurveyQuestionOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionFindFirstArgs} args - Arguments to find a SurveyQuestionOption
     * @example
     * // Get one SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SurveyQuestionOptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SurveyQuestionOptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SurveyQuestionOption'> extends True ? CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption>, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T>>> : CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption | null >, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T> | null >>

    /**
     * Find zero or more SurveyQuestionOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyQuestionOptions
     * const surveyQuestionOptions = await prisma.surveyQuestionOption.findMany()
     * 
     * // Get first 10 SurveyQuestionOptions
     * const surveyQuestionOptions = await prisma.surveyQuestionOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyQuestionOptionWithIdOnly = await prisma.surveyQuestionOption.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SurveyQuestionOptionFindManyArgs>(
      args?: SelectSubset<T, SurveyQuestionOptionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SurveyQuestionOption>>, PrismaPromise<Array<SurveyQuestionOptionGetPayload<T>>>>

    /**
     * Create a SurveyQuestionOption.
     * @param {SurveyQuestionOptionCreateArgs} args - Arguments to create a SurveyQuestionOption.
     * @example
     * // Create one SurveyQuestionOption
     * const SurveyQuestionOption = await prisma.surveyQuestionOption.create({
     *   data: {
     *     // ... data to create a SurveyQuestionOption
     *   }
     * })
     * 
    **/
    create<T extends SurveyQuestionOptionCreateArgs>(
      args: SelectSubset<T, SurveyQuestionOptionCreateArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption>, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T>>>

    /**
     * Create many SurveyQuestionOptions.
     *     @param {SurveyQuestionOptionCreateManyArgs} args - Arguments to create many SurveyQuestionOptions.
     *     @example
     *     // Create many SurveyQuestionOptions
     *     const surveyQuestionOption = await prisma.surveyQuestionOption.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SurveyQuestionOptionCreateManyArgs>(
      args?: SelectSubset<T, SurveyQuestionOptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyQuestionOption.
     * @param {SurveyQuestionOptionDeleteArgs} args - Arguments to delete one SurveyQuestionOption.
     * @example
     * // Delete one SurveyQuestionOption
     * const SurveyQuestionOption = await prisma.surveyQuestionOption.delete({
     *   where: {
     *     // ... filter to delete one SurveyQuestionOption
     *   }
     * })
     * 
    **/
    delete<T extends SurveyQuestionOptionDeleteArgs>(
      args: SelectSubset<T, SurveyQuestionOptionDeleteArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption>, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T>>>

    /**
     * Update one SurveyQuestionOption.
     * @param {SurveyQuestionOptionUpdateArgs} args - Arguments to update one SurveyQuestionOption.
     * @example
     * // Update one SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SurveyQuestionOptionUpdateArgs>(
      args: SelectSubset<T, SurveyQuestionOptionUpdateArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption>, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T>>>

    /**
     * Delete zero or more SurveyQuestionOptions.
     * @param {SurveyQuestionOptionDeleteManyArgs} args - Arguments to filter SurveyQuestionOptions to delete.
     * @example
     * // Delete a few SurveyQuestionOptions
     * const { count } = await prisma.surveyQuestionOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SurveyQuestionOptionDeleteManyArgs>(
      args?: SelectSubset<T, SurveyQuestionOptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyQuestionOptions
     * const surveyQuestionOption = await prisma.surveyQuestionOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SurveyQuestionOptionUpdateManyArgs>(
      args: SelectSubset<T, SurveyQuestionOptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyQuestionOption.
     * @param {SurveyQuestionOptionUpsertArgs} args - Arguments to update or create a SurveyQuestionOption.
     * @example
     * // Update or create a SurveyQuestionOption
     * const surveyQuestionOption = await prisma.surveyQuestionOption.upsert({
     *   create: {
     *     // ... data to create a SurveyQuestionOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyQuestionOption we want to update
     *   }
     * })
    **/
    upsert<T extends SurveyQuestionOptionUpsertArgs>(
      args: SelectSubset<T, SurveyQuestionOptionUpsertArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption>, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T>>>

    /**
     * Count the number of SurveyQuestionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionCountArgs} args - Arguments to filter SurveyQuestionOptions to count.
     * @example
     * // Count the number of SurveyQuestionOptions
     * const count = await prisma.surveyQuestionOption.count({
     *   where: {
     *     // ... the filter for the SurveyQuestionOptions we want to count
     *   }
     * })
    **/
    count<T extends SurveyQuestionOptionCountArgs>(
      args?: Subset<T, SurveyQuestionOptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyQuestionOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyQuestionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyQuestionOptionAggregateArgs>(args: Subset<T, SurveyQuestionOptionAggregateArgs>): PrismaPromise<GetSurveyQuestionOptionAggregateType<T>>

    /**
     * Group by SurveyQuestionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyQuestionOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyQuestionOptionGroupByArgs['orderBy'] }
        : { orderBy?: SurveyQuestionOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyQuestionOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyQuestionOptionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyQuestionOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SurveyQuestionOptionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    surveyQuestion<T extends SurveyQuestionArgs = {}>(args?: Subset<T, SurveyQuestionArgs>): CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion | null >, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T> | null >>;

    surveyQuestionAnswer<T extends SurveyQuestionAnswerFindManyArgs = {}>(args?: Subset<T, SurveyQuestionAnswerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SurveyQuestionAnswer>>, PrismaPromise<Array<SurveyQuestionAnswerGetPayload<T>>>>;

    intermediateSurveyQuestionAnswerProduct<T extends IntermediateSurveyQuestionAnswerProductFindManyArgs = {}>(args?: Subset<T, IntermediateSurveyQuestionAnswerProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateSurveyQuestionAnswerProduct>>, PrismaPromise<Array<IntermediateSurveyQuestionAnswerProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SurveyQuestionOption findUnique
   */
  export type SurveyQuestionOptionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     * 
    **/
    select?: SurveyQuestionOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionOptionInclude | null
    /**
     * Throw an Error if a SurveyQuestionOption can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SurveyQuestionOption to fetch.
     * 
    **/
    where: SurveyQuestionOptionWhereUniqueInput
  }


  /**
   * SurveyQuestionOption findFirst
   */
  export type SurveyQuestionOptionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     * 
    **/
    select?: SurveyQuestionOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionOptionInclude | null
    /**
     * Throw an Error if a SurveyQuestionOption can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SurveyQuestionOption to fetch.
     * 
    **/
    where?: SurveyQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionOptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestionOptions.
     * 
    **/
    cursor?: SurveyQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionOptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestionOptions.
     * 
    **/
    distinct?: Enumerable<SurveyQuestionOptionScalarFieldEnum>
  }


  /**
   * SurveyQuestionOption findMany
   */
  export type SurveyQuestionOptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     * 
    **/
    select?: SurveyQuestionOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionOptionInclude | null
    /**
     * Filter, which SurveyQuestionOptions to fetch.
     * 
    **/
    where?: SurveyQuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionOptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyQuestionOptions.
     * 
    **/
    cursor?: SurveyQuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionOptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SurveyQuestionOptionScalarFieldEnum>
  }


  /**
   * SurveyQuestionOption create
   */
  export type SurveyQuestionOptionCreateArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     * 
    **/
    select?: SurveyQuestionOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionOptionInclude | null
    /**
     * The data needed to create a SurveyQuestionOption.
     * 
    **/
    data: XOR<SurveyQuestionOptionCreateInput, SurveyQuestionOptionUncheckedCreateInput>
  }


  /**
   * SurveyQuestionOption createMany
   */
  export type SurveyQuestionOptionCreateManyArgs = {
    data: Enumerable<SurveyQuestionOptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SurveyQuestionOption update
   */
  export type SurveyQuestionOptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     * 
    **/
    select?: SurveyQuestionOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionOptionInclude | null
    /**
     * The data needed to update a SurveyQuestionOption.
     * 
    **/
    data: XOR<SurveyQuestionOptionUpdateInput, SurveyQuestionOptionUncheckedUpdateInput>
    /**
     * Choose, which SurveyQuestionOption to update.
     * 
    **/
    where: SurveyQuestionOptionWhereUniqueInput
  }


  /**
   * SurveyQuestionOption updateMany
   */
  export type SurveyQuestionOptionUpdateManyArgs = {
    data: XOR<SurveyQuestionOptionUpdateManyMutationInput, SurveyQuestionOptionUncheckedUpdateManyInput>
    where?: SurveyQuestionOptionWhereInput
  }


  /**
   * SurveyQuestionOption upsert
   */
  export type SurveyQuestionOptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     * 
    **/
    select?: SurveyQuestionOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionOptionInclude | null
    /**
     * The filter to search for the SurveyQuestionOption to update in case it exists.
     * 
    **/
    where: SurveyQuestionOptionWhereUniqueInput
    /**
     * In case the SurveyQuestionOption found by the `where` argument doesn't exist, create a new SurveyQuestionOption with this data.
     * 
    **/
    create: XOR<SurveyQuestionOptionCreateInput, SurveyQuestionOptionUncheckedCreateInput>
    /**
     * In case the SurveyQuestionOption was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SurveyQuestionOptionUpdateInput, SurveyQuestionOptionUncheckedUpdateInput>
  }


  /**
   * SurveyQuestionOption delete
   */
  export type SurveyQuestionOptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     * 
    **/
    select?: SurveyQuestionOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionOptionInclude | null
    /**
     * Filter which SurveyQuestionOption to delete.
     * 
    **/
    where: SurveyQuestionOptionWhereUniqueInput
  }


  /**
   * SurveyQuestionOption deleteMany
   */
  export type SurveyQuestionOptionDeleteManyArgs = {
    where?: SurveyQuestionOptionWhereInput
  }


  /**
   * SurveyQuestionOption without action
   */
  export type SurveyQuestionOptionArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionOption
     * 
    **/
    select?: SurveyQuestionOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionOptionInclude | null
  }



  /**
   * Model SurveyQuestionAnswer
   */


  export type AggregateSurveyQuestionAnswer = {
    _count: SurveyQuestionAnswerCountAggregateOutputType | null
    _avg: SurveyQuestionAnswerAvgAggregateOutputType | null
    _sum: SurveyQuestionAnswerSumAggregateOutputType | null
    _min: SurveyQuestionAnswerMinAggregateOutputType | null
    _max: SurveyQuestionAnswerMaxAggregateOutputType | null
  }

  export type SurveyQuestionAnswerAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    surveyQuestionId: number | null
    answerSingleOptionId: number | null
    answerNumeric: number | null
    answerCount: number | null
    productId: number | null
  }

  export type SurveyQuestionAnswerSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    surveyQuestionId: number | null
    answerSingleOptionId: number | null
    answerNumeric: number | null
    answerCount: number | null
    productId: number | null
  }

  export type SurveyQuestionAnswerMinAggregateOutputType = {
    id: number | null
    responseId: string | null
    customerId: number | null
    surveyQuestionId: number | null
    answerSingleOptionId: number | null
    answerNumeric: number | null
    answerText: string | null
    answerBool: boolean | null
    reason: string | null
    title: string | null
    content: string | null
    answerCount: number | null
    productId: number | null
    orderNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionAnswerMaxAggregateOutputType = {
    id: number | null
    responseId: string | null
    customerId: number | null
    surveyQuestionId: number | null
    answerSingleOptionId: number | null
    answerNumeric: number | null
    answerText: string | null
    answerBool: boolean | null
    reason: string | null
    title: string | null
    content: string | null
    answerCount: number | null
    productId: number | null
    orderNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SurveyQuestionAnswerCountAggregateOutputType = {
    id: number
    responseId: number
    customerId: number
    surveyQuestionId: number
    answerSingleOptionId: number
    answerNumeric: number
    answerText: number
    answerBool: number
    reason: number
    title: number
    content: number
    answerCount: number
    productId: number
    orderNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SurveyQuestionAnswerAvgAggregateInputType = {
    id?: true
    customerId?: true
    surveyQuestionId?: true
    answerSingleOptionId?: true
    answerNumeric?: true
    answerCount?: true
    productId?: true
  }

  export type SurveyQuestionAnswerSumAggregateInputType = {
    id?: true
    customerId?: true
    surveyQuestionId?: true
    answerSingleOptionId?: true
    answerNumeric?: true
    answerCount?: true
    productId?: true
  }

  export type SurveyQuestionAnswerMinAggregateInputType = {
    id?: true
    responseId?: true
    customerId?: true
    surveyQuestionId?: true
    answerSingleOptionId?: true
    answerNumeric?: true
    answerText?: true
    answerBool?: true
    reason?: true
    title?: true
    content?: true
    answerCount?: true
    productId?: true
    orderNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionAnswerMaxAggregateInputType = {
    id?: true
    responseId?: true
    customerId?: true
    surveyQuestionId?: true
    answerSingleOptionId?: true
    answerNumeric?: true
    answerText?: true
    answerBool?: true
    reason?: true
    title?: true
    content?: true
    answerCount?: true
    productId?: true
    orderNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SurveyQuestionAnswerCountAggregateInputType = {
    id?: true
    responseId?: true
    customerId?: true
    surveyQuestionId?: true
    answerSingleOptionId?: true
    answerNumeric?: true
    answerText?: true
    answerBool?: true
    reason?: true
    title?: true
    content?: true
    answerCount?: true
    productId?: true
    orderNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SurveyQuestionAnswerAggregateArgs = {
    /**
     * Filter which SurveyQuestionAnswer to aggregate.
     * 
    **/
    where?: SurveyQuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SurveyQuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyQuestionAnswers
    **/
    _count?: true | SurveyQuestionAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyQuestionAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyQuestionAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyQuestionAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyQuestionAnswerMaxAggregateInputType
  }

  export type GetSurveyQuestionAnswerAggregateType<T extends SurveyQuestionAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyQuestionAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyQuestionAnswer[P]>
      : GetScalarType<T[P], AggregateSurveyQuestionAnswer[P]>
  }




  export type SurveyQuestionAnswerGroupByArgs = {
    where?: SurveyQuestionAnswerWhereInput
    orderBy?: Enumerable<SurveyQuestionAnswerOrderByWithAggregationInput>
    by: Array<SurveyQuestionAnswerScalarFieldEnum>
    having?: SurveyQuestionAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyQuestionAnswerCountAggregateInputType | true
    _avg?: SurveyQuestionAnswerAvgAggregateInputType
    _sum?: SurveyQuestionAnswerSumAggregateInputType
    _min?: SurveyQuestionAnswerMinAggregateInputType
    _max?: SurveyQuestionAnswerMaxAggregateInputType
  }


  export type SurveyQuestionAnswerGroupByOutputType = {
    id: number
    responseId: string | null
    customerId: number
    surveyQuestionId: number
    answerSingleOptionId: number | null
    answerNumeric: number | null
    answerText: string | null
    answerBool: boolean | null
    reason: string | null
    title: string | null
    content: string | null
    answerCount: number | null
    productId: number | null
    orderNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: SurveyQuestionAnswerCountAggregateOutputType | null
    _avg: SurveyQuestionAnswerAvgAggregateOutputType | null
    _sum: SurveyQuestionAnswerSumAggregateOutputType | null
    _min: SurveyQuestionAnswerMinAggregateOutputType | null
    _max: SurveyQuestionAnswerMaxAggregateOutputType | null
  }

  type GetSurveyQuestionAnswerGroupByPayload<T extends SurveyQuestionAnswerGroupByArgs> = Promise<
    Array<
      PickArray<SurveyQuestionAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyQuestionAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyQuestionAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyQuestionAnswerGroupByOutputType[P]>
        }
      >
    >


  export type SurveyQuestionAnswerSelect = {
    id?: boolean
    intermediateSurveyQuestionAnswerProduct?: boolean | IntermediateSurveyQuestionAnswerProductFindManyArgs
    responseId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    surveyQuestion?: boolean | SurveyQuestionArgs
    surveyQuestionId?: boolean
    answerOption?: boolean | SurveyQuestionOptionArgs
    answerSingleOptionId?: boolean
    answerNumeric?: boolean
    answerText?: boolean
    answerBool?: boolean
    reason?: boolean
    title?: boolean
    content?: boolean
    answerCount?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    orderNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | SurveyQuestionAnswerCountOutputTypeArgs
  }

  export type SurveyQuestionAnswerInclude = {
    intermediateSurveyQuestionAnswerProduct?: boolean | IntermediateSurveyQuestionAnswerProductFindManyArgs
    customer?: boolean | CustomersArgs
    surveyQuestion?: boolean | SurveyQuestionArgs
    answerOption?: boolean | SurveyQuestionOptionArgs
    product?: boolean | ProductArgs
    _count?: boolean | SurveyQuestionAnswerCountOutputTypeArgs
  }

  export type SurveyQuestionAnswerGetPayload<
    S extends boolean | null | undefined | SurveyQuestionAnswerArgs,
    U = keyof S
      > = S extends true
        ? SurveyQuestionAnswer
    : S extends undefined
    ? never
    : S extends SurveyQuestionAnswerArgs | SurveyQuestionAnswerFindManyArgs
    ?'include' extends U
    ? SurveyQuestionAnswer  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'intermediateSurveyQuestionAnswerProduct'
        ? Array < IntermediateSurveyQuestionAnswerProductGetPayload<S['include'][P]>>  :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> :
        P extends 'surveyQuestion'
        ? SurveyQuestionGetPayload<S['include'][P]> :
        P extends 'answerOption'
        ? SurveyQuestionOptionGetPayload<S['include'][P]> | null :
        P extends 'product'
        ? ProductGetPayload<S['include'][P]> | null :
        P extends '_count'
        ? SurveyQuestionAnswerCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SurveyQuestionAnswer ?SurveyQuestionAnswer [P]
  : 
          P extends 'intermediateSurveyQuestionAnswerProduct'
        ? Array < IntermediateSurveyQuestionAnswerProductGetPayload<S['select'][P]>>  :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> :
        P extends 'surveyQuestion'
        ? SurveyQuestionGetPayload<S['select'][P]> :
        P extends 'answerOption'
        ? SurveyQuestionOptionGetPayload<S['select'][P]> | null :
        P extends 'product'
        ? ProductGetPayload<S['select'][P]> | null :
        P extends '_count'
        ? SurveyQuestionAnswerCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : SurveyQuestionAnswer
  : SurveyQuestionAnswer


  type SurveyQuestionAnswerCountArgs = Merge<
    Omit<SurveyQuestionAnswerFindManyArgs, 'select' | 'include'> & {
      select?: SurveyQuestionAnswerCountAggregateInputType | true
    }
  >

  export interface SurveyQuestionAnswerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SurveyQuestionAnswer that matches the filter.
     * @param {SurveyQuestionAnswerFindUniqueArgs} args - Arguments to find a SurveyQuestionAnswer
     * @example
     * // Get one SurveyQuestionAnswer
     * const surveyQuestionAnswer = await prisma.surveyQuestionAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SurveyQuestionAnswerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SurveyQuestionAnswerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SurveyQuestionAnswer'> extends True ? CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer>, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T>>> : CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer | null >, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T> | null >>

    /**
     * Find the first SurveyQuestionAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerFindFirstArgs} args - Arguments to find a SurveyQuestionAnswer
     * @example
     * // Get one SurveyQuestionAnswer
     * const surveyQuestionAnswer = await prisma.surveyQuestionAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SurveyQuestionAnswerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SurveyQuestionAnswerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SurveyQuestionAnswer'> extends True ? CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer>, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T>>> : CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer | null >, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T> | null >>

    /**
     * Find zero or more SurveyQuestionAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyQuestionAnswers
     * const surveyQuestionAnswers = await prisma.surveyQuestionAnswer.findMany()
     * 
     * // Get first 10 SurveyQuestionAnswers
     * const surveyQuestionAnswers = await prisma.surveyQuestionAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyQuestionAnswerWithIdOnly = await prisma.surveyQuestionAnswer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SurveyQuestionAnswerFindManyArgs>(
      args?: SelectSubset<T, SurveyQuestionAnswerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SurveyQuestionAnswer>>, PrismaPromise<Array<SurveyQuestionAnswerGetPayload<T>>>>

    /**
     * Create a SurveyQuestionAnswer.
     * @param {SurveyQuestionAnswerCreateArgs} args - Arguments to create a SurveyQuestionAnswer.
     * @example
     * // Create one SurveyQuestionAnswer
     * const SurveyQuestionAnswer = await prisma.surveyQuestionAnswer.create({
     *   data: {
     *     // ... data to create a SurveyQuestionAnswer
     *   }
     * })
     * 
    **/
    create<T extends SurveyQuestionAnswerCreateArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerCreateArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer>, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T>>>

    /**
     * Create many SurveyQuestionAnswers.
     *     @param {SurveyQuestionAnswerCreateManyArgs} args - Arguments to create many SurveyQuestionAnswers.
     *     @example
     *     // Create many SurveyQuestionAnswers
     *     const surveyQuestionAnswer = await prisma.surveyQuestionAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SurveyQuestionAnswerCreateManyArgs>(
      args?: SelectSubset<T, SurveyQuestionAnswerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyQuestionAnswer.
     * @param {SurveyQuestionAnswerDeleteArgs} args - Arguments to delete one SurveyQuestionAnswer.
     * @example
     * // Delete one SurveyQuestionAnswer
     * const SurveyQuestionAnswer = await prisma.surveyQuestionAnswer.delete({
     *   where: {
     *     // ... filter to delete one SurveyQuestionAnswer
     *   }
     * })
     * 
    **/
    delete<T extends SurveyQuestionAnswerDeleteArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerDeleteArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer>, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T>>>

    /**
     * Update one SurveyQuestionAnswer.
     * @param {SurveyQuestionAnswerUpdateArgs} args - Arguments to update one SurveyQuestionAnswer.
     * @example
     * // Update one SurveyQuestionAnswer
     * const surveyQuestionAnswer = await prisma.surveyQuestionAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SurveyQuestionAnswerUpdateArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerUpdateArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer>, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T>>>

    /**
     * Delete zero or more SurveyQuestionAnswers.
     * @param {SurveyQuestionAnswerDeleteManyArgs} args - Arguments to filter SurveyQuestionAnswers to delete.
     * @example
     * // Delete a few SurveyQuestionAnswers
     * const { count } = await prisma.surveyQuestionAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SurveyQuestionAnswerDeleteManyArgs>(
      args?: SelectSubset<T, SurveyQuestionAnswerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyQuestionAnswers
     * const surveyQuestionAnswer = await prisma.surveyQuestionAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SurveyQuestionAnswerUpdateManyArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyQuestionAnswer.
     * @param {SurveyQuestionAnswerUpsertArgs} args - Arguments to update or create a SurveyQuestionAnswer.
     * @example
     * // Update or create a SurveyQuestionAnswer
     * const surveyQuestionAnswer = await prisma.surveyQuestionAnswer.upsert({
     *   create: {
     *     // ... data to create a SurveyQuestionAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyQuestionAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends SurveyQuestionAnswerUpsertArgs>(
      args: SelectSubset<T, SurveyQuestionAnswerUpsertArgs>
    ): CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer>, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T>>>

    /**
     * Count the number of SurveyQuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerCountArgs} args - Arguments to filter SurveyQuestionAnswers to count.
     * @example
     * // Count the number of SurveyQuestionAnswers
     * const count = await prisma.surveyQuestionAnswer.count({
     *   where: {
     *     // ... the filter for the SurveyQuestionAnswers we want to count
     *   }
     * })
    **/
    count<T extends SurveyQuestionAnswerCountArgs>(
      args?: Subset<T, SurveyQuestionAnswerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyQuestionAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyQuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyQuestionAnswerAggregateArgs>(args: Subset<T, SurveyQuestionAnswerAggregateArgs>): PrismaPromise<GetSurveyQuestionAnswerAggregateType<T>>

    /**
     * Group by SurveyQuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyQuestionAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyQuestionAnswerGroupByArgs['orderBy'] }
        : { orderBy?: SurveyQuestionAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyQuestionAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyQuestionAnswerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyQuestionAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SurveyQuestionAnswerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    intermediateSurveyQuestionAnswerProduct<T extends IntermediateSurveyQuestionAnswerProductFindManyArgs = {}>(args?: Subset<T, IntermediateSurveyQuestionAnswerProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediateSurveyQuestionAnswerProduct>>, PrismaPromise<Array<IntermediateSurveyQuestionAnswerProductGetPayload<T>>>>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    surveyQuestion<T extends SurveyQuestionArgs = {}>(args?: Subset<T, SurveyQuestionArgs>): CheckSelect<T, Prisma__SurveyQuestionClient<SurveyQuestion | null >, Prisma__SurveyQuestionClient<SurveyQuestionGetPayload<T> | null >>;

    answerOption<T extends SurveyQuestionOptionArgs = {}>(args?: Subset<T, SurveyQuestionOptionArgs>): CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption | null >, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SurveyQuestionAnswer findUnique
   */
  export type SurveyQuestionAnswerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswer
     * 
    **/
    select?: SurveyQuestionAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerInclude | null
    /**
     * Throw an Error if a SurveyQuestionAnswer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SurveyQuestionAnswer to fetch.
     * 
    **/
    where: SurveyQuestionAnswerWhereUniqueInput
  }


  /**
   * SurveyQuestionAnswer findFirst
   */
  export type SurveyQuestionAnswerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswer
     * 
    **/
    select?: SurveyQuestionAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerInclude | null
    /**
     * Throw an Error if a SurveyQuestionAnswer can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SurveyQuestionAnswer to fetch.
     * 
    **/
    where?: SurveyQuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestionAnswers.
     * 
    **/
    cursor?: SurveyQuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestionAnswers.
     * 
    **/
    distinct?: Enumerable<SurveyQuestionAnswerScalarFieldEnum>
  }


  /**
   * SurveyQuestionAnswer findMany
   */
  export type SurveyQuestionAnswerFindManyArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswer
     * 
    **/
    select?: SurveyQuestionAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerInclude | null
    /**
     * Filter, which SurveyQuestionAnswers to fetch.
     * 
    **/
    where?: SurveyQuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestionAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<SurveyQuestionAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyQuestionAnswers.
     * 
    **/
    cursor?: SurveyQuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestionAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestionAnswers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SurveyQuestionAnswerScalarFieldEnum>
  }


  /**
   * SurveyQuestionAnswer create
   */
  export type SurveyQuestionAnswerCreateArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswer
     * 
    **/
    select?: SurveyQuestionAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerInclude | null
    /**
     * The data needed to create a SurveyQuestionAnswer.
     * 
    **/
    data: XOR<SurveyQuestionAnswerCreateInput, SurveyQuestionAnswerUncheckedCreateInput>
  }


  /**
   * SurveyQuestionAnswer createMany
   */
  export type SurveyQuestionAnswerCreateManyArgs = {
    data: Enumerable<SurveyQuestionAnswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SurveyQuestionAnswer update
   */
  export type SurveyQuestionAnswerUpdateArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswer
     * 
    **/
    select?: SurveyQuestionAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerInclude | null
    /**
     * The data needed to update a SurveyQuestionAnswer.
     * 
    **/
    data: XOR<SurveyQuestionAnswerUpdateInput, SurveyQuestionAnswerUncheckedUpdateInput>
    /**
     * Choose, which SurveyQuestionAnswer to update.
     * 
    **/
    where: SurveyQuestionAnswerWhereUniqueInput
  }


  /**
   * SurveyQuestionAnswer updateMany
   */
  export type SurveyQuestionAnswerUpdateManyArgs = {
    data: XOR<SurveyQuestionAnswerUpdateManyMutationInput, SurveyQuestionAnswerUncheckedUpdateManyInput>
    where?: SurveyQuestionAnswerWhereInput
  }


  /**
   * SurveyQuestionAnswer upsert
   */
  export type SurveyQuestionAnswerUpsertArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswer
     * 
    **/
    select?: SurveyQuestionAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerInclude | null
    /**
     * The filter to search for the SurveyQuestionAnswer to update in case it exists.
     * 
    **/
    where: SurveyQuestionAnswerWhereUniqueInput
    /**
     * In case the SurveyQuestionAnswer found by the `where` argument doesn't exist, create a new SurveyQuestionAnswer with this data.
     * 
    **/
    create: XOR<SurveyQuestionAnswerCreateInput, SurveyQuestionAnswerUncheckedCreateInput>
    /**
     * In case the SurveyQuestionAnswer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SurveyQuestionAnswerUpdateInput, SurveyQuestionAnswerUncheckedUpdateInput>
  }


  /**
   * SurveyQuestionAnswer delete
   */
  export type SurveyQuestionAnswerDeleteArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswer
     * 
    **/
    select?: SurveyQuestionAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerInclude | null
    /**
     * Filter which SurveyQuestionAnswer to delete.
     * 
    **/
    where: SurveyQuestionAnswerWhereUniqueInput
  }


  /**
   * SurveyQuestionAnswer deleteMany
   */
  export type SurveyQuestionAnswerDeleteManyArgs = {
    where?: SurveyQuestionAnswerWhereInput
  }


  /**
   * SurveyQuestionAnswer without action
   */
  export type SurveyQuestionAnswerArgs = {
    /**
     * Select specific fields to fetch from the SurveyQuestionAnswer
     * 
    **/
    select?: SurveyQuestionAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SurveyQuestionAnswerInclude | null
  }



  /**
   * Model IntermediateSurveyQuestionAnswerProduct
   */


  export type AggregateIntermediateSurveyQuestionAnswerProduct = {
    _count: IntermediateSurveyQuestionAnswerProductCountAggregateOutputType | null
    _avg: IntermediateSurveyQuestionAnswerProductAvgAggregateOutputType | null
    _sum: IntermediateSurveyQuestionAnswerProductSumAggregateOutputType | null
    _min: IntermediateSurveyQuestionAnswerProductMinAggregateOutputType | null
    _max: IntermediateSurveyQuestionAnswerProductMaxAggregateOutputType | null
  }

  export type IntermediateSurveyQuestionAnswerProductAvgAggregateOutputType = {
    surveyQuestionAnswerId: number | null
    surveyQuestionOptionId: number | null
  }

  export type IntermediateSurveyQuestionAnswerProductSumAggregateOutputType = {
    surveyQuestionAnswerId: number | null
    surveyQuestionOptionId: number | null
  }

  export type IntermediateSurveyQuestionAnswerProductMinAggregateOutputType = {
    surveyQuestionAnswerId: number | null
    surveyQuestionOptionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateSurveyQuestionAnswerProductMaxAggregateOutputType = {
    surveyQuestionAnswerId: number | null
    surveyQuestionOptionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediateSurveyQuestionAnswerProductCountAggregateOutputType = {
    surveyQuestionAnswerId: number
    surveyQuestionOptionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediateSurveyQuestionAnswerProductAvgAggregateInputType = {
    surveyQuestionAnswerId?: true
    surveyQuestionOptionId?: true
  }

  export type IntermediateSurveyQuestionAnswerProductSumAggregateInputType = {
    surveyQuestionAnswerId?: true
    surveyQuestionOptionId?: true
  }

  export type IntermediateSurveyQuestionAnswerProductMinAggregateInputType = {
    surveyQuestionAnswerId?: true
    surveyQuestionOptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateSurveyQuestionAnswerProductMaxAggregateInputType = {
    surveyQuestionAnswerId?: true
    surveyQuestionOptionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediateSurveyQuestionAnswerProductCountAggregateInputType = {
    surveyQuestionAnswerId?: true
    surveyQuestionOptionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediateSurveyQuestionAnswerProductAggregateArgs = {
    /**
     * Filter which IntermediateSurveyQuestionAnswerProduct to aggregate.
     * 
    **/
    where?: IntermediateSurveyQuestionAnswerProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateSurveyQuestionAnswerProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateSurveyQuestionAnswerProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateSurveyQuestionAnswerProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateSurveyQuestionAnswerProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediateSurveyQuestionAnswerProducts
    **/
    _count?: true | IntermediateSurveyQuestionAnswerProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediateSurveyQuestionAnswerProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediateSurveyQuestionAnswerProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediateSurveyQuestionAnswerProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediateSurveyQuestionAnswerProductMaxAggregateInputType
  }

  export type GetIntermediateSurveyQuestionAnswerProductAggregateType<T extends IntermediateSurveyQuestionAnswerProductAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediateSurveyQuestionAnswerProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediateSurveyQuestionAnswerProduct[P]>
      : GetScalarType<T[P], AggregateIntermediateSurveyQuestionAnswerProduct[P]>
  }




  export type IntermediateSurveyQuestionAnswerProductGroupByArgs = {
    where?: IntermediateSurveyQuestionAnswerProductWhereInput
    orderBy?: Enumerable<IntermediateSurveyQuestionAnswerProductOrderByWithAggregationInput>
    by: Array<IntermediateSurveyQuestionAnswerProductScalarFieldEnum>
    having?: IntermediateSurveyQuestionAnswerProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediateSurveyQuestionAnswerProductCountAggregateInputType | true
    _avg?: IntermediateSurveyQuestionAnswerProductAvgAggregateInputType
    _sum?: IntermediateSurveyQuestionAnswerProductSumAggregateInputType
    _min?: IntermediateSurveyQuestionAnswerProductMinAggregateInputType
    _max?: IntermediateSurveyQuestionAnswerProductMaxAggregateInputType
  }


  export type IntermediateSurveyQuestionAnswerProductGroupByOutputType = {
    surveyQuestionAnswerId: number
    surveyQuestionOptionId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediateSurveyQuestionAnswerProductCountAggregateOutputType | null
    _avg: IntermediateSurveyQuestionAnswerProductAvgAggregateOutputType | null
    _sum: IntermediateSurveyQuestionAnswerProductSumAggregateOutputType | null
    _min: IntermediateSurveyQuestionAnswerProductMinAggregateOutputType | null
    _max: IntermediateSurveyQuestionAnswerProductMaxAggregateOutputType | null
  }

  type GetIntermediateSurveyQuestionAnswerProductGroupByPayload<T extends IntermediateSurveyQuestionAnswerProductGroupByArgs> = Promise<
    Array<
      PickArray<IntermediateSurveyQuestionAnswerProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediateSurveyQuestionAnswerProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediateSurveyQuestionAnswerProductGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediateSurveyQuestionAnswerProductGroupByOutputType[P]>
        }
      >
    >


  export type IntermediateSurveyQuestionAnswerProductSelect = {
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerArgs
    surveyQuestionAnswerId?: boolean
    surveyQuestionOption?: boolean | SurveyQuestionOptionArgs
    surveyQuestionOptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediateSurveyQuestionAnswerProductInclude = {
    surveyQuestionAnswer?: boolean | SurveyQuestionAnswerArgs
    surveyQuestionOption?: boolean | SurveyQuestionOptionArgs
  }

  export type IntermediateSurveyQuestionAnswerProductGetPayload<
    S extends boolean | null | undefined | IntermediateSurveyQuestionAnswerProductArgs,
    U = keyof S
      > = S extends true
        ? IntermediateSurveyQuestionAnswerProduct
    : S extends undefined
    ? never
    : S extends IntermediateSurveyQuestionAnswerProductArgs | IntermediateSurveyQuestionAnswerProductFindManyArgs
    ?'include' extends U
    ? IntermediateSurveyQuestionAnswerProduct  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'surveyQuestionAnswer'
        ? SurveyQuestionAnswerGetPayload<S['include'][P]> :
        P extends 'surveyQuestionOption'
        ? SurveyQuestionOptionGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediateSurveyQuestionAnswerProduct ?IntermediateSurveyQuestionAnswerProduct [P]
  : 
          P extends 'surveyQuestionAnswer'
        ? SurveyQuestionAnswerGetPayload<S['select'][P]> :
        P extends 'surveyQuestionOption'
        ? SurveyQuestionOptionGetPayload<S['select'][P]> : never
  } 
    : IntermediateSurveyQuestionAnswerProduct
  : IntermediateSurveyQuestionAnswerProduct


  type IntermediateSurveyQuestionAnswerProductCountArgs = Merge<
    Omit<IntermediateSurveyQuestionAnswerProductFindManyArgs, 'select' | 'include'> & {
      select?: IntermediateSurveyQuestionAnswerProductCountAggregateInputType | true
    }
  >

  export interface IntermediateSurveyQuestionAnswerProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediateSurveyQuestionAnswerProduct that matches the filter.
     * @param {IntermediateSurveyQuestionAnswerProductFindUniqueArgs} args - Arguments to find a IntermediateSurveyQuestionAnswerProduct
     * @example
     * // Get one IntermediateSurveyQuestionAnswerProduct
     * const intermediateSurveyQuestionAnswerProduct = await prisma.intermediateSurveyQuestionAnswerProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediateSurveyQuestionAnswerProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediateSurveyQuestionAnswerProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediateSurveyQuestionAnswerProduct'> extends True ? CheckSelect<T, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProduct>, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProductGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProduct | null >, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProductGetPayload<T> | null >>

    /**
     * Find the first IntermediateSurveyQuestionAnswerProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionAnswerProductFindFirstArgs} args - Arguments to find a IntermediateSurveyQuestionAnswerProduct
     * @example
     * // Get one IntermediateSurveyQuestionAnswerProduct
     * const intermediateSurveyQuestionAnswerProduct = await prisma.intermediateSurveyQuestionAnswerProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediateSurveyQuestionAnswerProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediateSurveyQuestionAnswerProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediateSurveyQuestionAnswerProduct'> extends True ? CheckSelect<T, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProduct>, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProductGetPayload<T>>> : CheckSelect<T, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProduct | null >, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProductGetPayload<T> | null >>

    /**
     * Find zero or more IntermediateSurveyQuestionAnswerProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionAnswerProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediateSurveyQuestionAnswerProducts
     * const intermediateSurveyQuestionAnswerProducts = await prisma.intermediateSurveyQuestionAnswerProduct.findMany()
     * 
     * // Get first 10 IntermediateSurveyQuestionAnswerProducts
     * const intermediateSurveyQuestionAnswerProducts = await prisma.intermediateSurveyQuestionAnswerProduct.findMany({ take: 10 })
     * 
     * // Only select the `surveyQuestionAnswerId`
     * const intermediateSurveyQuestionAnswerProductWithSurveyQuestionAnswerIdOnly = await prisma.intermediateSurveyQuestionAnswerProduct.findMany({ select: { surveyQuestionAnswerId: true } })
     * 
    **/
    findMany<T extends IntermediateSurveyQuestionAnswerProductFindManyArgs>(
      args?: SelectSubset<T, IntermediateSurveyQuestionAnswerProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediateSurveyQuestionAnswerProduct>>, PrismaPromise<Array<IntermediateSurveyQuestionAnswerProductGetPayload<T>>>>

    /**
     * Create a IntermediateSurveyQuestionAnswerProduct.
     * @param {IntermediateSurveyQuestionAnswerProductCreateArgs} args - Arguments to create a IntermediateSurveyQuestionAnswerProduct.
     * @example
     * // Create one IntermediateSurveyQuestionAnswerProduct
     * const IntermediateSurveyQuestionAnswerProduct = await prisma.intermediateSurveyQuestionAnswerProduct.create({
     *   data: {
     *     // ... data to create a IntermediateSurveyQuestionAnswerProduct
     *   }
     * })
     * 
    **/
    create<T extends IntermediateSurveyQuestionAnswerProductCreateArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionAnswerProductCreateArgs>
    ): CheckSelect<T, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProduct>, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProductGetPayload<T>>>

    /**
     * Create many IntermediateSurveyQuestionAnswerProducts.
     *     @param {IntermediateSurveyQuestionAnswerProductCreateManyArgs} args - Arguments to create many IntermediateSurveyQuestionAnswerProducts.
     *     @example
     *     // Create many IntermediateSurveyQuestionAnswerProducts
     *     const intermediateSurveyQuestionAnswerProduct = await prisma.intermediateSurveyQuestionAnswerProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediateSurveyQuestionAnswerProductCreateManyArgs>(
      args?: SelectSubset<T, IntermediateSurveyQuestionAnswerProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediateSurveyQuestionAnswerProduct.
     * @param {IntermediateSurveyQuestionAnswerProductDeleteArgs} args - Arguments to delete one IntermediateSurveyQuestionAnswerProduct.
     * @example
     * // Delete one IntermediateSurveyQuestionAnswerProduct
     * const IntermediateSurveyQuestionAnswerProduct = await prisma.intermediateSurveyQuestionAnswerProduct.delete({
     *   where: {
     *     // ... filter to delete one IntermediateSurveyQuestionAnswerProduct
     *   }
     * })
     * 
    **/
    delete<T extends IntermediateSurveyQuestionAnswerProductDeleteArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionAnswerProductDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProduct>, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProductGetPayload<T>>>

    /**
     * Update one IntermediateSurveyQuestionAnswerProduct.
     * @param {IntermediateSurveyQuestionAnswerProductUpdateArgs} args - Arguments to update one IntermediateSurveyQuestionAnswerProduct.
     * @example
     * // Update one IntermediateSurveyQuestionAnswerProduct
     * const intermediateSurveyQuestionAnswerProduct = await prisma.intermediateSurveyQuestionAnswerProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediateSurveyQuestionAnswerProductUpdateArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionAnswerProductUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProduct>, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProductGetPayload<T>>>

    /**
     * Delete zero or more IntermediateSurveyQuestionAnswerProducts.
     * @param {IntermediateSurveyQuestionAnswerProductDeleteManyArgs} args - Arguments to filter IntermediateSurveyQuestionAnswerProducts to delete.
     * @example
     * // Delete a few IntermediateSurveyQuestionAnswerProducts
     * const { count } = await prisma.intermediateSurveyQuestionAnswerProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediateSurveyQuestionAnswerProductDeleteManyArgs>(
      args?: SelectSubset<T, IntermediateSurveyQuestionAnswerProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediateSurveyQuestionAnswerProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionAnswerProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediateSurveyQuestionAnswerProducts
     * const intermediateSurveyQuestionAnswerProduct = await prisma.intermediateSurveyQuestionAnswerProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediateSurveyQuestionAnswerProductUpdateManyArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionAnswerProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediateSurveyQuestionAnswerProduct.
     * @param {IntermediateSurveyQuestionAnswerProductUpsertArgs} args - Arguments to update or create a IntermediateSurveyQuestionAnswerProduct.
     * @example
     * // Update or create a IntermediateSurveyQuestionAnswerProduct
     * const intermediateSurveyQuestionAnswerProduct = await prisma.intermediateSurveyQuestionAnswerProduct.upsert({
     *   create: {
     *     // ... data to create a IntermediateSurveyQuestionAnswerProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediateSurveyQuestionAnswerProduct we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediateSurveyQuestionAnswerProductUpsertArgs>(
      args: SelectSubset<T, IntermediateSurveyQuestionAnswerProductUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProduct>, Prisma__IntermediateSurveyQuestionAnswerProductClient<IntermediateSurveyQuestionAnswerProductGetPayload<T>>>

    /**
     * Count the number of IntermediateSurveyQuestionAnswerProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionAnswerProductCountArgs} args - Arguments to filter IntermediateSurveyQuestionAnswerProducts to count.
     * @example
     * // Count the number of IntermediateSurveyQuestionAnswerProducts
     * const count = await prisma.intermediateSurveyQuestionAnswerProduct.count({
     *   where: {
     *     // ... the filter for the IntermediateSurveyQuestionAnswerProducts we want to count
     *   }
     * })
    **/
    count<T extends IntermediateSurveyQuestionAnswerProductCountArgs>(
      args?: Subset<T, IntermediateSurveyQuestionAnswerProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediateSurveyQuestionAnswerProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediateSurveyQuestionAnswerProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionAnswerProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediateSurveyQuestionAnswerProductAggregateArgs>(args: Subset<T, IntermediateSurveyQuestionAnswerProductAggregateArgs>): PrismaPromise<GetIntermediateSurveyQuestionAnswerProductAggregateType<T>>

    /**
     * Group by IntermediateSurveyQuestionAnswerProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediateSurveyQuestionAnswerProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediateSurveyQuestionAnswerProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediateSurveyQuestionAnswerProductGroupByArgs['orderBy'] }
        : { orderBy?: IntermediateSurveyQuestionAnswerProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediateSurveyQuestionAnswerProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediateSurveyQuestionAnswerProductGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediateSurveyQuestionAnswerProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediateSurveyQuestionAnswerProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    surveyQuestionAnswer<T extends SurveyQuestionAnswerArgs = {}>(args?: Subset<T, SurveyQuestionAnswerArgs>): CheckSelect<T, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswer | null >, Prisma__SurveyQuestionAnswerClient<SurveyQuestionAnswerGetPayload<T> | null >>;

    surveyQuestionOption<T extends SurveyQuestionOptionArgs = {}>(args?: Subset<T, SurveyQuestionOptionArgs>): CheckSelect<T, Prisma__SurveyQuestionOptionClient<SurveyQuestionOption | null >, Prisma__SurveyQuestionOptionClient<SurveyQuestionOptionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediateSurveyQuestionAnswerProduct findUnique
   */
  export type IntermediateSurveyQuestionAnswerProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestionAnswerProduct
     * 
    **/
    select?: IntermediateSurveyQuestionAnswerProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionAnswerProductInclude | null
    /**
     * Throw an Error if a IntermediateSurveyQuestionAnswerProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateSurveyQuestionAnswerProduct to fetch.
     * 
    **/
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct findFirst
   */
  export type IntermediateSurveyQuestionAnswerProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestionAnswerProduct
     * 
    **/
    select?: IntermediateSurveyQuestionAnswerProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionAnswerProductInclude | null
    /**
     * Throw an Error if a IntermediateSurveyQuestionAnswerProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediateSurveyQuestionAnswerProduct to fetch.
     * 
    **/
    where?: IntermediateSurveyQuestionAnswerProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateSurveyQuestionAnswerProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateSurveyQuestionAnswerProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediateSurveyQuestionAnswerProducts.
     * 
    **/
    cursor?: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateSurveyQuestionAnswerProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateSurveyQuestionAnswerProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediateSurveyQuestionAnswerProducts.
     * 
    **/
    distinct?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarFieldEnum>
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct findMany
   */
  export type IntermediateSurveyQuestionAnswerProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestionAnswerProduct
     * 
    **/
    select?: IntermediateSurveyQuestionAnswerProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionAnswerProductInclude | null
    /**
     * Filter, which IntermediateSurveyQuestionAnswerProducts to fetch.
     * 
    **/
    where?: IntermediateSurveyQuestionAnswerProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediateSurveyQuestionAnswerProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediateSurveyQuestionAnswerProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediateSurveyQuestionAnswerProducts.
     * 
    **/
    cursor?: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediateSurveyQuestionAnswerProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediateSurveyQuestionAnswerProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarFieldEnum>
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct create
   */
  export type IntermediateSurveyQuestionAnswerProductCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestionAnswerProduct
     * 
    **/
    select?: IntermediateSurveyQuestionAnswerProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionAnswerProductInclude | null
    /**
     * The data needed to create a IntermediateSurveyQuestionAnswerProduct.
     * 
    **/
    data: XOR<IntermediateSurveyQuestionAnswerProductCreateInput, IntermediateSurveyQuestionAnswerProductUncheckedCreateInput>
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct createMany
   */
  export type IntermediateSurveyQuestionAnswerProductCreateManyArgs = {
    data: Enumerable<IntermediateSurveyQuestionAnswerProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct update
   */
  export type IntermediateSurveyQuestionAnswerProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestionAnswerProduct
     * 
    **/
    select?: IntermediateSurveyQuestionAnswerProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionAnswerProductInclude | null
    /**
     * The data needed to update a IntermediateSurveyQuestionAnswerProduct.
     * 
    **/
    data: XOR<IntermediateSurveyQuestionAnswerProductUpdateInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateInput>
    /**
     * Choose, which IntermediateSurveyQuestionAnswerProduct to update.
     * 
    **/
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct updateMany
   */
  export type IntermediateSurveyQuestionAnswerProductUpdateManyArgs = {
    data: XOR<IntermediateSurveyQuestionAnswerProductUpdateManyMutationInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyInput>
    where?: IntermediateSurveyQuestionAnswerProductWhereInput
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct upsert
   */
  export type IntermediateSurveyQuestionAnswerProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestionAnswerProduct
     * 
    **/
    select?: IntermediateSurveyQuestionAnswerProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionAnswerProductInclude | null
    /**
     * The filter to search for the IntermediateSurveyQuestionAnswerProduct to update in case it exists.
     * 
    **/
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    /**
     * In case the IntermediateSurveyQuestionAnswerProduct found by the `where` argument doesn't exist, create a new IntermediateSurveyQuestionAnswerProduct with this data.
     * 
    **/
    create: XOR<IntermediateSurveyQuestionAnswerProductCreateInput, IntermediateSurveyQuestionAnswerProductUncheckedCreateInput>
    /**
     * In case the IntermediateSurveyQuestionAnswerProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediateSurveyQuestionAnswerProductUpdateInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateInput>
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct delete
   */
  export type IntermediateSurveyQuestionAnswerProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestionAnswerProduct
     * 
    **/
    select?: IntermediateSurveyQuestionAnswerProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionAnswerProductInclude | null
    /**
     * Filter which IntermediateSurveyQuestionAnswerProduct to delete.
     * 
    **/
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct deleteMany
   */
  export type IntermediateSurveyQuestionAnswerProductDeleteManyArgs = {
    where?: IntermediateSurveyQuestionAnswerProductWhereInput
  }


  /**
   * IntermediateSurveyQuestionAnswerProduct without action
   */
  export type IntermediateSurveyQuestionAnswerProductArgs = {
    /**
     * Select specific fields to fetch from the IntermediateSurveyQuestionAnswerProduct
     * 
    **/
    select?: IntermediateSurveyQuestionAnswerProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediateSurveyQuestionAnswerProductInclude | null
  }



  /**
   * Model CustomerProductDistance
   */


  export type AggregateCustomerProductDistance = {
    _count: CustomerProductDistanceCountAggregateOutputType | null
    _avg: CustomerProductDistanceAvgAggregateOutputType | null
    _sum: CustomerProductDistanceSumAggregateOutputType | null
    _min: CustomerProductDistanceMinAggregateOutputType | null
    _max: CustomerProductDistanceMaxAggregateOutputType | null
  }

  export type CustomerProductDistanceAvgAggregateOutputType = {
    id: number | null
    distance: number | null
    productId: number | null
    customerId: number | null
  }

  export type CustomerProductDistanceSumAggregateOutputType = {
    id: number | null
    distance: number | null
    productId: number | null
    customerId: number | null
  }

  export type CustomerProductDistanceMinAggregateOutputType = {
    id: number | null
    distance: number | null
    productId: number | null
    customerId: number | null
    version: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProductDistanceMaxAggregateOutputType = {
    id: number | null
    distance: number | null
    productId: number | null
    customerId: number | null
    version: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProductDistanceCountAggregateOutputType = {
    id: number
    distance: number
    productId: number
    customerId: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerProductDistanceAvgAggregateInputType = {
    id?: true
    distance?: true
    productId?: true
    customerId?: true
  }

  export type CustomerProductDistanceSumAggregateInputType = {
    id?: true
    distance?: true
    productId?: true
    customerId?: true
  }

  export type CustomerProductDistanceMinAggregateInputType = {
    id?: true
    distance?: true
    productId?: true
    customerId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProductDistanceMaxAggregateInputType = {
    id?: true
    distance?: true
    productId?: true
    customerId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProductDistanceCountAggregateInputType = {
    id?: true
    distance?: true
    productId?: true
    customerId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerProductDistanceAggregateArgs = {
    /**
     * Filter which CustomerProductDistance to aggregate.
     * 
    **/
    where?: CustomerProductDistanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProductDistances to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerProductDistanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerProductDistanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProductDistances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProductDistances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerProductDistances
    **/
    _count?: true | CustomerProductDistanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerProductDistanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerProductDistanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerProductDistanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerProductDistanceMaxAggregateInputType
  }

  export type GetCustomerProductDistanceAggregateType<T extends CustomerProductDistanceAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerProductDistance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerProductDistance[P]>
      : GetScalarType<T[P], AggregateCustomerProductDistance[P]>
  }




  export type CustomerProductDistanceGroupByArgs = {
    where?: CustomerProductDistanceWhereInput
    orderBy?: Enumerable<CustomerProductDistanceOrderByWithAggregationInput>
    by: Array<CustomerProductDistanceScalarFieldEnum>
    having?: CustomerProductDistanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerProductDistanceCountAggregateInputType | true
    _avg?: CustomerProductDistanceAvgAggregateInputType
    _sum?: CustomerProductDistanceSumAggregateInputType
    _min?: CustomerProductDistanceMinAggregateInputType
    _max?: CustomerProductDistanceMaxAggregateInputType
  }


  export type CustomerProductDistanceGroupByOutputType = {
    id: number
    distance: number
    productId: number
    customerId: number
    version: Date
    createdAt: Date
    updatedAt: Date
    _count: CustomerProductDistanceCountAggregateOutputType | null
    _avg: CustomerProductDistanceAvgAggregateOutputType | null
    _sum: CustomerProductDistanceSumAggregateOutputType | null
    _min: CustomerProductDistanceMinAggregateOutputType | null
    _max: CustomerProductDistanceMaxAggregateOutputType | null
  }

  type GetCustomerProductDistanceGroupByPayload<T extends CustomerProductDistanceGroupByArgs> = Promise<
    Array<
      PickArray<CustomerProductDistanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerProductDistanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerProductDistanceGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerProductDistanceGroupByOutputType[P]>
        }
      >
    >


  export type CustomerProductDistanceSelect = {
    id?: boolean
    distance?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerProductDistanceInclude = {
    product?: boolean | ProductArgs
    customer?: boolean | CustomersArgs
  }

  export type CustomerProductDistanceGetPayload<
    S extends boolean | null | undefined | CustomerProductDistanceArgs,
    U = keyof S
      > = S extends true
        ? CustomerProductDistance
    : S extends undefined
    ? never
    : S extends CustomerProductDistanceArgs | CustomerProductDistanceFindManyArgs
    ?'include' extends U
    ? CustomerProductDistance  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CustomerProductDistance ?CustomerProductDistance [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : CustomerProductDistance
  : CustomerProductDistance


  type CustomerProductDistanceCountArgs = Merge<
    Omit<CustomerProductDistanceFindManyArgs, 'select' | 'include'> & {
      select?: CustomerProductDistanceCountAggregateInputType | true
    }
  >

  export interface CustomerProductDistanceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CustomerProductDistance that matches the filter.
     * @param {CustomerProductDistanceFindUniqueArgs} args - Arguments to find a CustomerProductDistance
     * @example
     * // Get one CustomerProductDistance
     * const customerProductDistance = await prisma.customerProductDistance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerProductDistanceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerProductDistanceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerProductDistance'> extends True ? CheckSelect<T, Prisma__CustomerProductDistanceClient<CustomerProductDistance>, Prisma__CustomerProductDistanceClient<CustomerProductDistanceGetPayload<T>>> : CheckSelect<T, Prisma__CustomerProductDistanceClient<CustomerProductDistance | null >, Prisma__CustomerProductDistanceClient<CustomerProductDistanceGetPayload<T> | null >>

    /**
     * Find the first CustomerProductDistance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductDistanceFindFirstArgs} args - Arguments to find a CustomerProductDistance
     * @example
     * // Get one CustomerProductDistance
     * const customerProductDistance = await prisma.customerProductDistance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerProductDistanceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerProductDistanceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerProductDistance'> extends True ? CheckSelect<T, Prisma__CustomerProductDistanceClient<CustomerProductDistance>, Prisma__CustomerProductDistanceClient<CustomerProductDistanceGetPayload<T>>> : CheckSelect<T, Prisma__CustomerProductDistanceClient<CustomerProductDistance | null >, Prisma__CustomerProductDistanceClient<CustomerProductDistanceGetPayload<T> | null >>

    /**
     * Find zero or more CustomerProductDistances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductDistanceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerProductDistances
     * const customerProductDistances = await prisma.customerProductDistance.findMany()
     * 
     * // Get first 10 CustomerProductDistances
     * const customerProductDistances = await prisma.customerProductDistance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerProductDistanceWithIdOnly = await prisma.customerProductDistance.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerProductDistanceFindManyArgs>(
      args?: SelectSubset<T, CustomerProductDistanceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CustomerProductDistance>>, PrismaPromise<Array<CustomerProductDistanceGetPayload<T>>>>

    /**
     * Create a CustomerProductDistance.
     * @param {CustomerProductDistanceCreateArgs} args - Arguments to create a CustomerProductDistance.
     * @example
     * // Create one CustomerProductDistance
     * const CustomerProductDistance = await prisma.customerProductDistance.create({
     *   data: {
     *     // ... data to create a CustomerProductDistance
     *   }
     * })
     * 
    **/
    create<T extends CustomerProductDistanceCreateArgs>(
      args: SelectSubset<T, CustomerProductDistanceCreateArgs>
    ): CheckSelect<T, Prisma__CustomerProductDistanceClient<CustomerProductDistance>, Prisma__CustomerProductDistanceClient<CustomerProductDistanceGetPayload<T>>>

    /**
     * Create many CustomerProductDistances.
     *     @param {CustomerProductDistanceCreateManyArgs} args - Arguments to create many CustomerProductDistances.
     *     @example
     *     // Create many CustomerProductDistances
     *     const customerProductDistance = await prisma.customerProductDistance.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerProductDistanceCreateManyArgs>(
      args?: SelectSubset<T, CustomerProductDistanceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerProductDistance.
     * @param {CustomerProductDistanceDeleteArgs} args - Arguments to delete one CustomerProductDistance.
     * @example
     * // Delete one CustomerProductDistance
     * const CustomerProductDistance = await prisma.customerProductDistance.delete({
     *   where: {
     *     // ... filter to delete one CustomerProductDistance
     *   }
     * })
     * 
    **/
    delete<T extends CustomerProductDistanceDeleteArgs>(
      args: SelectSubset<T, CustomerProductDistanceDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerProductDistanceClient<CustomerProductDistance>, Prisma__CustomerProductDistanceClient<CustomerProductDistanceGetPayload<T>>>

    /**
     * Update one CustomerProductDistance.
     * @param {CustomerProductDistanceUpdateArgs} args - Arguments to update one CustomerProductDistance.
     * @example
     * // Update one CustomerProductDistance
     * const customerProductDistance = await prisma.customerProductDistance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerProductDistanceUpdateArgs>(
      args: SelectSubset<T, CustomerProductDistanceUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerProductDistanceClient<CustomerProductDistance>, Prisma__CustomerProductDistanceClient<CustomerProductDistanceGetPayload<T>>>

    /**
     * Delete zero or more CustomerProductDistances.
     * @param {CustomerProductDistanceDeleteManyArgs} args - Arguments to filter CustomerProductDistances to delete.
     * @example
     * // Delete a few CustomerProductDistances
     * const { count } = await prisma.customerProductDistance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerProductDistanceDeleteManyArgs>(
      args?: SelectSubset<T, CustomerProductDistanceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerProductDistances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductDistanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerProductDistances
     * const customerProductDistance = await prisma.customerProductDistance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerProductDistanceUpdateManyArgs>(
      args: SelectSubset<T, CustomerProductDistanceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerProductDistance.
     * @param {CustomerProductDistanceUpsertArgs} args - Arguments to update or create a CustomerProductDistance.
     * @example
     * // Update or create a CustomerProductDistance
     * const customerProductDistance = await prisma.customerProductDistance.upsert({
     *   create: {
     *     // ... data to create a CustomerProductDistance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerProductDistance we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerProductDistanceUpsertArgs>(
      args: SelectSubset<T, CustomerProductDistanceUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerProductDistanceClient<CustomerProductDistance>, Prisma__CustomerProductDistanceClient<CustomerProductDistanceGetPayload<T>>>

    /**
     * Count the number of CustomerProductDistances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductDistanceCountArgs} args - Arguments to filter CustomerProductDistances to count.
     * @example
     * // Count the number of CustomerProductDistances
     * const count = await prisma.customerProductDistance.count({
     *   where: {
     *     // ... the filter for the CustomerProductDistances we want to count
     *   }
     * })
    **/
    count<T extends CustomerProductDistanceCountArgs>(
      args?: Subset<T, CustomerProductDistanceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerProductDistanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerProductDistance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductDistanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerProductDistanceAggregateArgs>(args: Subset<T, CustomerProductDistanceAggregateArgs>): PrismaPromise<GetCustomerProductDistanceAggregateType<T>>

    /**
     * Group by CustomerProductDistance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductDistanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerProductDistanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerProductDistanceGroupByArgs['orderBy'] }
        : { orderBy?: CustomerProductDistanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerProductDistanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerProductDistanceGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerProductDistance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerProductDistanceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CustomerProductDistance findUnique
   */
  export type CustomerProductDistanceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CustomerProductDistance
     * 
    **/
    select?: CustomerProductDistanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerProductDistanceInclude | null
    /**
     * Throw an Error if a CustomerProductDistance can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CustomerProductDistance to fetch.
     * 
    **/
    where: CustomerProductDistanceWhereUniqueInput
  }


  /**
   * CustomerProductDistance findFirst
   */
  export type CustomerProductDistanceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CustomerProductDistance
     * 
    **/
    select?: CustomerProductDistanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerProductDistanceInclude | null
    /**
     * Throw an Error if a CustomerProductDistance can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CustomerProductDistance to fetch.
     * 
    **/
    where?: CustomerProductDistanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProductDistances to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerProductDistanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProductDistances.
     * 
    **/
    cursor?: CustomerProductDistanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProductDistances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProductDistances.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProductDistances.
     * 
    **/
    distinct?: Enumerable<CustomerProductDistanceScalarFieldEnum>
  }


  /**
   * CustomerProductDistance findMany
   */
  export type CustomerProductDistanceFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerProductDistance
     * 
    **/
    select?: CustomerProductDistanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerProductDistanceInclude | null
    /**
     * Filter, which CustomerProductDistances to fetch.
     * 
    **/
    where?: CustomerProductDistanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProductDistances to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerProductDistanceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerProductDistances.
     * 
    **/
    cursor?: CustomerProductDistanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProductDistances from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProductDistances.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerProductDistanceScalarFieldEnum>
  }


  /**
   * CustomerProductDistance create
   */
  export type CustomerProductDistanceCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerProductDistance
     * 
    **/
    select?: CustomerProductDistanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerProductDistanceInclude | null
    /**
     * The data needed to create a CustomerProductDistance.
     * 
    **/
    data: XOR<CustomerProductDistanceCreateInput, CustomerProductDistanceUncheckedCreateInput>
  }


  /**
   * CustomerProductDistance createMany
   */
  export type CustomerProductDistanceCreateManyArgs = {
    data: Enumerable<CustomerProductDistanceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerProductDistance update
   */
  export type CustomerProductDistanceUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerProductDistance
     * 
    **/
    select?: CustomerProductDistanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerProductDistanceInclude | null
    /**
     * The data needed to update a CustomerProductDistance.
     * 
    **/
    data: XOR<CustomerProductDistanceUpdateInput, CustomerProductDistanceUncheckedUpdateInput>
    /**
     * Choose, which CustomerProductDistance to update.
     * 
    **/
    where: CustomerProductDistanceWhereUniqueInput
  }


  /**
   * CustomerProductDistance updateMany
   */
  export type CustomerProductDistanceUpdateManyArgs = {
    data: XOR<CustomerProductDistanceUpdateManyMutationInput, CustomerProductDistanceUncheckedUpdateManyInput>
    where?: CustomerProductDistanceWhereInput
  }


  /**
   * CustomerProductDistance upsert
   */
  export type CustomerProductDistanceUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerProductDistance
     * 
    **/
    select?: CustomerProductDistanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerProductDistanceInclude | null
    /**
     * The filter to search for the CustomerProductDistance to update in case it exists.
     * 
    **/
    where: CustomerProductDistanceWhereUniqueInput
    /**
     * In case the CustomerProductDistance found by the `where` argument doesn't exist, create a new CustomerProductDistance with this data.
     * 
    **/
    create: XOR<CustomerProductDistanceCreateInput, CustomerProductDistanceUncheckedCreateInput>
    /**
     * In case the CustomerProductDistance was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerProductDistanceUpdateInput, CustomerProductDistanceUncheckedUpdateInput>
  }


  /**
   * CustomerProductDistance delete
   */
  export type CustomerProductDistanceDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerProductDistance
     * 
    **/
    select?: CustomerProductDistanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerProductDistanceInclude | null
    /**
     * Filter which CustomerProductDistance to delete.
     * 
    **/
    where: CustomerProductDistanceWhereUniqueInput
  }


  /**
   * CustomerProductDistance deleteMany
   */
  export type CustomerProductDistanceDeleteManyArgs = {
    where?: CustomerProductDistanceWhereInput
  }


  /**
   * CustomerProductDistance without action
   */
  export type CustomerProductDistanceArgs = {
    /**
     * Select specific fields to fetch from the CustomerProductDistance
     * 
    **/
    select?: CustomerProductDistanceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerProductDistanceInclude | null
  }



  /**
   * Model CustomerBoxItems
   */


  export type AggregateCustomerBoxItems = {
    _count: CustomerBoxItemsCountAggregateOutputType | null
    _avg: CustomerBoxItemsAvgAggregateOutputType | null
    _sum: CustomerBoxItemsSumAggregateOutputType | null
    _min: CustomerBoxItemsMinAggregateOutputType | null
    _max: CustomerBoxItemsMaxAggregateOutputType | null
  }

  export type CustomerBoxItemsAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    customerId: number | null
  }

  export type CustomerBoxItemsSumAggregateOutputType = {
    id: number | null
    productId: number | null
    customerId: number | null
  }

  export type CustomerBoxItemsMinAggregateOutputType = {
    id: number | null
    productId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerBoxItemsMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    customerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerBoxItemsCountAggregateOutputType = {
    id: number
    productId: number
    customerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerBoxItemsAvgAggregateInputType = {
    id?: true
    productId?: true
    customerId?: true
  }

  export type CustomerBoxItemsSumAggregateInputType = {
    id?: true
    productId?: true
    customerId?: true
  }

  export type CustomerBoxItemsMinAggregateInputType = {
    id?: true
    productId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerBoxItemsMaxAggregateInputType = {
    id?: true
    productId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerBoxItemsCountAggregateInputType = {
    id?: true
    productId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerBoxItemsAggregateArgs = {
    /**
     * Filter which CustomerBoxItems to aggregate.
     * 
    **/
    where?: CustomerBoxItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerBoxItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerBoxItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CustomerBoxItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerBoxItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerBoxItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerBoxItems
    **/
    _count?: true | CustomerBoxItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerBoxItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerBoxItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerBoxItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerBoxItemsMaxAggregateInputType
  }

  export type GetCustomerBoxItemsAggregateType<T extends CustomerBoxItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerBoxItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerBoxItems[P]>
      : GetScalarType<T[P], AggregateCustomerBoxItems[P]>
  }




  export type CustomerBoxItemsGroupByArgs = {
    where?: CustomerBoxItemsWhereInput
    orderBy?: Enumerable<CustomerBoxItemsOrderByWithAggregationInput>
    by: Array<CustomerBoxItemsScalarFieldEnum>
    having?: CustomerBoxItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerBoxItemsCountAggregateInputType | true
    _avg?: CustomerBoxItemsAvgAggregateInputType
    _sum?: CustomerBoxItemsSumAggregateInputType
    _min?: CustomerBoxItemsMinAggregateInputType
    _max?: CustomerBoxItemsMaxAggregateInputType
  }


  export type CustomerBoxItemsGroupByOutputType = {
    id: number
    productId: number
    customerId: number
    createdAt: Date
    updatedAt: Date
    _count: CustomerBoxItemsCountAggregateOutputType | null
    _avg: CustomerBoxItemsAvgAggregateOutputType | null
    _sum: CustomerBoxItemsSumAggregateOutputType | null
    _min: CustomerBoxItemsMinAggregateOutputType | null
    _max: CustomerBoxItemsMaxAggregateOutputType | null
  }

  type GetCustomerBoxItemsGroupByPayload<T extends CustomerBoxItemsGroupByArgs> = Promise<
    Array<
      PickArray<CustomerBoxItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerBoxItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerBoxItemsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerBoxItemsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerBoxItemsSelect = {
    id?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerBoxItemsInclude = {
    product?: boolean | ProductArgs
    customer?: boolean | CustomersArgs
  }

  export type CustomerBoxItemsGetPayload<
    S extends boolean | null | undefined | CustomerBoxItemsArgs,
    U = keyof S
      > = S extends true
        ? CustomerBoxItems
    : S extends undefined
    ? never
    : S extends CustomerBoxItemsArgs | CustomerBoxItemsFindManyArgs
    ?'include' extends U
    ? CustomerBoxItems  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CustomerBoxItems ?CustomerBoxItems [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> :
        P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : CustomerBoxItems
  : CustomerBoxItems


  type CustomerBoxItemsCountArgs = Merge<
    Omit<CustomerBoxItemsFindManyArgs, 'select' | 'include'> & {
      select?: CustomerBoxItemsCountAggregateInputType | true
    }
  >

  export interface CustomerBoxItemsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CustomerBoxItems that matches the filter.
     * @param {CustomerBoxItemsFindUniqueArgs} args - Arguments to find a CustomerBoxItems
     * @example
     * // Get one CustomerBoxItems
     * const customerBoxItems = await prisma.customerBoxItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerBoxItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerBoxItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerBoxItems'> extends True ? CheckSelect<T, Prisma__CustomerBoxItemsClient<CustomerBoxItems>, Prisma__CustomerBoxItemsClient<CustomerBoxItemsGetPayload<T>>> : CheckSelect<T, Prisma__CustomerBoxItemsClient<CustomerBoxItems | null >, Prisma__CustomerBoxItemsClient<CustomerBoxItemsGetPayload<T> | null >>

    /**
     * Find the first CustomerBoxItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBoxItemsFindFirstArgs} args - Arguments to find a CustomerBoxItems
     * @example
     * // Get one CustomerBoxItems
     * const customerBoxItems = await prisma.customerBoxItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerBoxItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerBoxItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerBoxItems'> extends True ? CheckSelect<T, Prisma__CustomerBoxItemsClient<CustomerBoxItems>, Prisma__CustomerBoxItemsClient<CustomerBoxItemsGetPayload<T>>> : CheckSelect<T, Prisma__CustomerBoxItemsClient<CustomerBoxItems | null >, Prisma__CustomerBoxItemsClient<CustomerBoxItemsGetPayload<T> | null >>

    /**
     * Find zero or more CustomerBoxItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBoxItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerBoxItems
     * const customerBoxItems = await prisma.customerBoxItems.findMany()
     * 
     * // Get first 10 CustomerBoxItems
     * const customerBoxItems = await prisma.customerBoxItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerBoxItemsWithIdOnly = await prisma.customerBoxItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerBoxItemsFindManyArgs>(
      args?: SelectSubset<T, CustomerBoxItemsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CustomerBoxItems>>, PrismaPromise<Array<CustomerBoxItemsGetPayload<T>>>>

    /**
     * Create a CustomerBoxItems.
     * @param {CustomerBoxItemsCreateArgs} args - Arguments to create a CustomerBoxItems.
     * @example
     * // Create one CustomerBoxItems
     * const CustomerBoxItems = await prisma.customerBoxItems.create({
     *   data: {
     *     // ... data to create a CustomerBoxItems
     *   }
     * })
     * 
    **/
    create<T extends CustomerBoxItemsCreateArgs>(
      args: SelectSubset<T, CustomerBoxItemsCreateArgs>
    ): CheckSelect<T, Prisma__CustomerBoxItemsClient<CustomerBoxItems>, Prisma__CustomerBoxItemsClient<CustomerBoxItemsGetPayload<T>>>

    /**
     * Create many CustomerBoxItems.
     *     @param {CustomerBoxItemsCreateManyArgs} args - Arguments to create many CustomerBoxItems.
     *     @example
     *     // Create many CustomerBoxItems
     *     const customerBoxItems = await prisma.customerBoxItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerBoxItemsCreateManyArgs>(
      args?: SelectSubset<T, CustomerBoxItemsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerBoxItems.
     * @param {CustomerBoxItemsDeleteArgs} args - Arguments to delete one CustomerBoxItems.
     * @example
     * // Delete one CustomerBoxItems
     * const CustomerBoxItems = await prisma.customerBoxItems.delete({
     *   where: {
     *     // ... filter to delete one CustomerBoxItems
     *   }
     * })
     * 
    **/
    delete<T extends CustomerBoxItemsDeleteArgs>(
      args: SelectSubset<T, CustomerBoxItemsDeleteArgs>
    ): CheckSelect<T, Prisma__CustomerBoxItemsClient<CustomerBoxItems>, Prisma__CustomerBoxItemsClient<CustomerBoxItemsGetPayload<T>>>

    /**
     * Update one CustomerBoxItems.
     * @param {CustomerBoxItemsUpdateArgs} args - Arguments to update one CustomerBoxItems.
     * @example
     * // Update one CustomerBoxItems
     * const customerBoxItems = await prisma.customerBoxItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerBoxItemsUpdateArgs>(
      args: SelectSubset<T, CustomerBoxItemsUpdateArgs>
    ): CheckSelect<T, Prisma__CustomerBoxItemsClient<CustomerBoxItems>, Prisma__CustomerBoxItemsClient<CustomerBoxItemsGetPayload<T>>>

    /**
     * Delete zero or more CustomerBoxItems.
     * @param {CustomerBoxItemsDeleteManyArgs} args - Arguments to filter CustomerBoxItems to delete.
     * @example
     * // Delete a few CustomerBoxItems
     * const { count } = await prisma.customerBoxItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerBoxItemsDeleteManyArgs>(
      args?: SelectSubset<T, CustomerBoxItemsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerBoxItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBoxItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerBoxItems
     * const customerBoxItems = await prisma.customerBoxItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerBoxItemsUpdateManyArgs>(
      args: SelectSubset<T, CustomerBoxItemsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerBoxItems.
     * @param {CustomerBoxItemsUpsertArgs} args - Arguments to update or create a CustomerBoxItems.
     * @example
     * // Update or create a CustomerBoxItems
     * const customerBoxItems = await prisma.customerBoxItems.upsert({
     *   create: {
     *     // ... data to create a CustomerBoxItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerBoxItems we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerBoxItemsUpsertArgs>(
      args: SelectSubset<T, CustomerBoxItemsUpsertArgs>
    ): CheckSelect<T, Prisma__CustomerBoxItemsClient<CustomerBoxItems>, Prisma__CustomerBoxItemsClient<CustomerBoxItemsGetPayload<T>>>

    /**
     * Count the number of CustomerBoxItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBoxItemsCountArgs} args - Arguments to filter CustomerBoxItems to count.
     * @example
     * // Count the number of CustomerBoxItems
     * const count = await prisma.customerBoxItems.count({
     *   where: {
     *     // ... the filter for the CustomerBoxItems we want to count
     *   }
     * })
    **/
    count<T extends CustomerBoxItemsCountArgs>(
      args?: Subset<T, CustomerBoxItemsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerBoxItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerBoxItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBoxItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerBoxItemsAggregateArgs>(args: Subset<T, CustomerBoxItemsAggregateArgs>): PrismaPromise<GetCustomerBoxItemsAggregateType<T>>

    /**
     * Group by CustomerBoxItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerBoxItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerBoxItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerBoxItemsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerBoxItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerBoxItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerBoxItemsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerBoxItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerBoxItemsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CustomerBoxItems findUnique
   */
  export type CustomerBoxItemsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CustomerBoxItems
     * 
    **/
    select?: CustomerBoxItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerBoxItemsInclude | null
    /**
     * Throw an Error if a CustomerBoxItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CustomerBoxItems to fetch.
     * 
    **/
    where: CustomerBoxItemsWhereUniqueInput
  }


  /**
   * CustomerBoxItems findFirst
   */
  export type CustomerBoxItemsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CustomerBoxItems
     * 
    **/
    select?: CustomerBoxItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerBoxItemsInclude | null
    /**
     * Throw an Error if a CustomerBoxItems can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CustomerBoxItems to fetch.
     * 
    **/
    where?: CustomerBoxItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerBoxItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerBoxItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerBoxItems.
     * 
    **/
    cursor?: CustomerBoxItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerBoxItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerBoxItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerBoxItems.
     * 
    **/
    distinct?: Enumerable<CustomerBoxItemsScalarFieldEnum>
  }


  /**
   * CustomerBoxItems findMany
   */
  export type CustomerBoxItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerBoxItems
     * 
    **/
    select?: CustomerBoxItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerBoxItemsInclude | null
    /**
     * Filter, which CustomerBoxItems to fetch.
     * 
    **/
    where?: CustomerBoxItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerBoxItems to fetch.
     * 
    **/
    orderBy?: Enumerable<CustomerBoxItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerBoxItems.
     * 
    **/
    cursor?: CustomerBoxItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerBoxItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerBoxItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CustomerBoxItemsScalarFieldEnum>
  }


  /**
   * CustomerBoxItems create
   */
  export type CustomerBoxItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerBoxItems
     * 
    **/
    select?: CustomerBoxItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerBoxItemsInclude | null
    /**
     * The data needed to create a CustomerBoxItems.
     * 
    **/
    data: XOR<CustomerBoxItemsCreateInput, CustomerBoxItemsUncheckedCreateInput>
  }


  /**
   * CustomerBoxItems createMany
   */
  export type CustomerBoxItemsCreateManyArgs = {
    data: Enumerable<CustomerBoxItemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerBoxItems update
   */
  export type CustomerBoxItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerBoxItems
     * 
    **/
    select?: CustomerBoxItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerBoxItemsInclude | null
    /**
     * The data needed to update a CustomerBoxItems.
     * 
    **/
    data: XOR<CustomerBoxItemsUpdateInput, CustomerBoxItemsUncheckedUpdateInput>
    /**
     * Choose, which CustomerBoxItems to update.
     * 
    **/
    where: CustomerBoxItemsWhereUniqueInput
  }


  /**
   * CustomerBoxItems updateMany
   */
  export type CustomerBoxItemsUpdateManyArgs = {
    data: XOR<CustomerBoxItemsUpdateManyMutationInput, CustomerBoxItemsUncheckedUpdateManyInput>
    where?: CustomerBoxItemsWhereInput
  }


  /**
   * CustomerBoxItems upsert
   */
  export type CustomerBoxItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerBoxItems
     * 
    **/
    select?: CustomerBoxItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerBoxItemsInclude | null
    /**
     * The filter to search for the CustomerBoxItems to update in case it exists.
     * 
    **/
    where: CustomerBoxItemsWhereUniqueInput
    /**
     * In case the CustomerBoxItems found by the `where` argument doesn't exist, create a new CustomerBoxItems with this data.
     * 
    **/
    create: XOR<CustomerBoxItemsCreateInput, CustomerBoxItemsUncheckedCreateInput>
    /**
     * In case the CustomerBoxItems was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CustomerBoxItemsUpdateInput, CustomerBoxItemsUncheckedUpdateInput>
  }


  /**
   * CustomerBoxItems delete
   */
  export type CustomerBoxItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerBoxItems
     * 
    **/
    select?: CustomerBoxItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerBoxItemsInclude | null
    /**
     * Filter which CustomerBoxItems to delete.
     * 
    **/
    where: CustomerBoxItemsWhereUniqueInput
  }


  /**
   * CustomerBoxItems deleteMany
   */
  export type CustomerBoxItemsDeleteManyArgs = {
    where?: CustomerBoxItemsWhereInput
  }


  /**
   * CustomerBoxItems without action
   */
  export type CustomerBoxItemsArgs = {
    /**
     * Select specific fields to fetch from the CustomerBoxItems
     * 
    **/
    select?: CustomerBoxItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CustomerBoxItemsInclude | null
  }



  /**
   * Model QueuedShopifyOrder
   */


  export type AggregateQueuedShopifyOrder = {
    _count: QueuedShopifyOrderCountAggregateOutputType | null
    _avg: QueuedShopifyOrderAvgAggregateOutputType | null
    _sum: QueuedShopifyOrderSumAggregateOutputType | null
    _min: QueuedShopifyOrderMinAggregateOutputType | null
    _max: QueuedShopifyOrderMaxAggregateOutputType | null
  }

  export type QueuedShopifyOrderAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type QueuedShopifyOrderSumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type QueuedShopifyOrderMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    orderName: string | null
    status: QueueStatus | null
    scheduledAt: string | null
    orderedAt: string | null
    fulfilledAt: string | null
  }

  export type QueuedShopifyOrderMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    orderName: string | null
    status: QueueStatus | null
    scheduledAt: string | null
    orderedAt: string | null
    fulfilledAt: string | null
  }

  export type QueuedShopifyOrderCountAggregateOutputType = {
    id: number
    customerId: number
    orderName: number
    status: number
    scheduledAt: number
    orderedAt: number
    fulfilledAt: number
    _all: number
  }


  export type QueuedShopifyOrderAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type QueuedShopifyOrderSumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type QueuedShopifyOrderMinAggregateInputType = {
    id?: true
    customerId?: true
    orderName?: true
    status?: true
    scheduledAt?: true
    orderedAt?: true
    fulfilledAt?: true
  }

  export type QueuedShopifyOrderMaxAggregateInputType = {
    id?: true
    customerId?: true
    orderName?: true
    status?: true
    scheduledAt?: true
    orderedAt?: true
    fulfilledAt?: true
  }

  export type QueuedShopifyOrderCountAggregateInputType = {
    id?: true
    customerId?: true
    orderName?: true
    status?: true
    scheduledAt?: true
    orderedAt?: true
    fulfilledAt?: true
    _all?: true
  }

  export type QueuedShopifyOrderAggregateArgs = {
    /**
     * Filter which QueuedShopifyOrder to aggregate.
     * 
    **/
    where?: QueuedShopifyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueuedShopifyOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<QueuedShopifyOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QueuedShopifyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueuedShopifyOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueuedShopifyOrders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueuedShopifyOrders
    **/
    _count?: true | QueuedShopifyOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueuedShopifyOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueuedShopifyOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueuedShopifyOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueuedShopifyOrderMaxAggregateInputType
  }

  export type GetQueuedShopifyOrderAggregateType<T extends QueuedShopifyOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateQueuedShopifyOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueuedShopifyOrder[P]>
      : GetScalarType<T[P], AggregateQueuedShopifyOrder[P]>
  }




  export type QueuedShopifyOrderGroupByArgs = {
    where?: QueuedShopifyOrderWhereInput
    orderBy?: Enumerable<QueuedShopifyOrderOrderByWithAggregationInput>
    by: Array<QueuedShopifyOrderScalarFieldEnum>
    having?: QueuedShopifyOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueuedShopifyOrderCountAggregateInputType | true
    _avg?: QueuedShopifyOrderAvgAggregateInputType
    _sum?: QueuedShopifyOrderSumAggregateInputType
    _min?: QueuedShopifyOrderMinAggregateInputType
    _max?: QueuedShopifyOrderMaxAggregateInputType
  }


  export type QueuedShopifyOrderGroupByOutputType = {
    id: number
    customerId: number
    orderName: string
    status: QueueStatus
    scheduledAt: string
    orderedAt: string | null
    fulfilledAt: string | null
    _count: QueuedShopifyOrderCountAggregateOutputType | null
    _avg: QueuedShopifyOrderAvgAggregateOutputType | null
    _sum: QueuedShopifyOrderSumAggregateOutputType | null
    _min: QueuedShopifyOrderMinAggregateOutputType | null
    _max: QueuedShopifyOrderMaxAggregateOutputType | null
  }

  type GetQueuedShopifyOrderGroupByPayload<T extends QueuedShopifyOrderGroupByArgs> = Promise<
    Array<
      PickArray<QueuedShopifyOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueuedShopifyOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueuedShopifyOrderGroupByOutputType[P]>
            : GetScalarType<T[P], QueuedShopifyOrderGroupByOutputType[P]>
        }
      >
    >


  export type QueuedShopifyOrderSelect = {
    id?: boolean
    customerId?: boolean
    orderName?: boolean
    status?: boolean
    customer?: boolean | CustomersArgs
    scheduledAt?: boolean
    orderedAt?: boolean
    fulfilledAt?: boolean
  }

  export type QueuedShopifyOrderInclude = {
    customer?: boolean | CustomersArgs
  }

  export type QueuedShopifyOrderGetPayload<
    S extends boolean | null | undefined | QueuedShopifyOrderArgs,
    U = keyof S
      > = S extends true
        ? QueuedShopifyOrder
    : S extends undefined
    ? never
    : S extends QueuedShopifyOrderArgs | QueuedShopifyOrderFindManyArgs
    ?'include' extends U
    ? QueuedShopifyOrder  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof QueuedShopifyOrder ?QueuedShopifyOrder [P]
  : 
          P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> : never
  } 
    : QueuedShopifyOrder
  : QueuedShopifyOrder


  type QueuedShopifyOrderCountArgs = Merge<
    Omit<QueuedShopifyOrderFindManyArgs, 'select' | 'include'> & {
      select?: QueuedShopifyOrderCountAggregateInputType | true
    }
  >

  export interface QueuedShopifyOrderDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one QueuedShopifyOrder that matches the filter.
     * @param {QueuedShopifyOrderFindUniqueArgs} args - Arguments to find a QueuedShopifyOrder
     * @example
     * // Get one QueuedShopifyOrder
     * const queuedShopifyOrder = await prisma.queuedShopifyOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QueuedShopifyOrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QueuedShopifyOrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QueuedShopifyOrder'> extends True ? CheckSelect<T, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrder>, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrderGetPayload<T>>> : CheckSelect<T, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrder | null >, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrderGetPayload<T> | null >>

    /**
     * Find the first QueuedShopifyOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueuedShopifyOrderFindFirstArgs} args - Arguments to find a QueuedShopifyOrder
     * @example
     * // Get one QueuedShopifyOrder
     * const queuedShopifyOrder = await prisma.queuedShopifyOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QueuedShopifyOrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QueuedShopifyOrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QueuedShopifyOrder'> extends True ? CheckSelect<T, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrder>, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrderGetPayload<T>>> : CheckSelect<T, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrder | null >, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrderGetPayload<T> | null >>

    /**
     * Find zero or more QueuedShopifyOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueuedShopifyOrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueuedShopifyOrders
     * const queuedShopifyOrders = await prisma.queuedShopifyOrder.findMany()
     * 
     * // Get first 10 QueuedShopifyOrders
     * const queuedShopifyOrders = await prisma.queuedShopifyOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queuedShopifyOrderWithIdOnly = await prisma.queuedShopifyOrder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QueuedShopifyOrderFindManyArgs>(
      args?: SelectSubset<T, QueuedShopifyOrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<QueuedShopifyOrder>>, PrismaPromise<Array<QueuedShopifyOrderGetPayload<T>>>>

    /**
     * Create a QueuedShopifyOrder.
     * @param {QueuedShopifyOrderCreateArgs} args - Arguments to create a QueuedShopifyOrder.
     * @example
     * // Create one QueuedShopifyOrder
     * const QueuedShopifyOrder = await prisma.queuedShopifyOrder.create({
     *   data: {
     *     // ... data to create a QueuedShopifyOrder
     *   }
     * })
     * 
    **/
    create<T extends QueuedShopifyOrderCreateArgs>(
      args: SelectSubset<T, QueuedShopifyOrderCreateArgs>
    ): CheckSelect<T, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrder>, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrderGetPayload<T>>>

    /**
     * Create many QueuedShopifyOrders.
     *     @param {QueuedShopifyOrderCreateManyArgs} args - Arguments to create many QueuedShopifyOrders.
     *     @example
     *     // Create many QueuedShopifyOrders
     *     const queuedShopifyOrder = await prisma.queuedShopifyOrder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QueuedShopifyOrderCreateManyArgs>(
      args?: SelectSubset<T, QueuedShopifyOrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QueuedShopifyOrder.
     * @param {QueuedShopifyOrderDeleteArgs} args - Arguments to delete one QueuedShopifyOrder.
     * @example
     * // Delete one QueuedShopifyOrder
     * const QueuedShopifyOrder = await prisma.queuedShopifyOrder.delete({
     *   where: {
     *     // ... filter to delete one QueuedShopifyOrder
     *   }
     * })
     * 
    **/
    delete<T extends QueuedShopifyOrderDeleteArgs>(
      args: SelectSubset<T, QueuedShopifyOrderDeleteArgs>
    ): CheckSelect<T, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrder>, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrderGetPayload<T>>>

    /**
     * Update one QueuedShopifyOrder.
     * @param {QueuedShopifyOrderUpdateArgs} args - Arguments to update one QueuedShopifyOrder.
     * @example
     * // Update one QueuedShopifyOrder
     * const queuedShopifyOrder = await prisma.queuedShopifyOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QueuedShopifyOrderUpdateArgs>(
      args: SelectSubset<T, QueuedShopifyOrderUpdateArgs>
    ): CheckSelect<T, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrder>, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrderGetPayload<T>>>

    /**
     * Delete zero or more QueuedShopifyOrders.
     * @param {QueuedShopifyOrderDeleteManyArgs} args - Arguments to filter QueuedShopifyOrders to delete.
     * @example
     * // Delete a few QueuedShopifyOrders
     * const { count } = await prisma.queuedShopifyOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QueuedShopifyOrderDeleteManyArgs>(
      args?: SelectSubset<T, QueuedShopifyOrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueuedShopifyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueuedShopifyOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueuedShopifyOrders
     * const queuedShopifyOrder = await prisma.queuedShopifyOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QueuedShopifyOrderUpdateManyArgs>(
      args: SelectSubset<T, QueuedShopifyOrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QueuedShopifyOrder.
     * @param {QueuedShopifyOrderUpsertArgs} args - Arguments to update or create a QueuedShopifyOrder.
     * @example
     * // Update or create a QueuedShopifyOrder
     * const queuedShopifyOrder = await prisma.queuedShopifyOrder.upsert({
     *   create: {
     *     // ... data to create a QueuedShopifyOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueuedShopifyOrder we want to update
     *   }
     * })
    **/
    upsert<T extends QueuedShopifyOrderUpsertArgs>(
      args: SelectSubset<T, QueuedShopifyOrderUpsertArgs>
    ): CheckSelect<T, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrder>, Prisma__QueuedShopifyOrderClient<QueuedShopifyOrderGetPayload<T>>>

    /**
     * Count the number of QueuedShopifyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueuedShopifyOrderCountArgs} args - Arguments to filter QueuedShopifyOrders to count.
     * @example
     * // Count the number of QueuedShopifyOrders
     * const count = await prisma.queuedShopifyOrder.count({
     *   where: {
     *     // ... the filter for the QueuedShopifyOrders we want to count
     *   }
     * })
    **/
    count<T extends QueuedShopifyOrderCountArgs>(
      args?: Subset<T, QueuedShopifyOrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueuedShopifyOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueuedShopifyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueuedShopifyOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueuedShopifyOrderAggregateArgs>(args: Subset<T, QueuedShopifyOrderAggregateArgs>): PrismaPromise<GetQueuedShopifyOrderAggregateType<T>>

    /**
     * Group by QueuedShopifyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueuedShopifyOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueuedShopifyOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueuedShopifyOrderGroupByArgs['orderBy'] }
        : { orderBy?: QueuedShopifyOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueuedShopifyOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueuedShopifyOrderGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueuedShopifyOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QueuedShopifyOrderClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * QueuedShopifyOrder findUnique
   */
  export type QueuedShopifyOrderFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the QueuedShopifyOrder
     * 
    **/
    select?: QueuedShopifyOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QueuedShopifyOrderInclude | null
    /**
     * Throw an Error if a QueuedShopifyOrder can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which QueuedShopifyOrder to fetch.
     * 
    **/
    where: QueuedShopifyOrderWhereUniqueInput
  }


  /**
   * QueuedShopifyOrder findFirst
   */
  export type QueuedShopifyOrderFindFirstArgs = {
    /**
     * Select specific fields to fetch from the QueuedShopifyOrder
     * 
    **/
    select?: QueuedShopifyOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QueuedShopifyOrderInclude | null
    /**
     * Throw an Error if a QueuedShopifyOrder can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which QueuedShopifyOrder to fetch.
     * 
    **/
    where?: QueuedShopifyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueuedShopifyOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<QueuedShopifyOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueuedShopifyOrders.
     * 
    **/
    cursor?: QueuedShopifyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueuedShopifyOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueuedShopifyOrders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueuedShopifyOrders.
     * 
    **/
    distinct?: Enumerable<QueuedShopifyOrderScalarFieldEnum>
  }


  /**
   * QueuedShopifyOrder findMany
   */
  export type QueuedShopifyOrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the QueuedShopifyOrder
     * 
    **/
    select?: QueuedShopifyOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QueuedShopifyOrderInclude | null
    /**
     * Filter, which QueuedShopifyOrders to fetch.
     * 
    **/
    where?: QueuedShopifyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueuedShopifyOrders to fetch.
     * 
    **/
    orderBy?: Enumerable<QueuedShopifyOrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueuedShopifyOrders.
     * 
    **/
    cursor?: QueuedShopifyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueuedShopifyOrders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueuedShopifyOrders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QueuedShopifyOrderScalarFieldEnum>
  }


  /**
   * QueuedShopifyOrder create
   */
  export type QueuedShopifyOrderCreateArgs = {
    /**
     * Select specific fields to fetch from the QueuedShopifyOrder
     * 
    **/
    select?: QueuedShopifyOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QueuedShopifyOrderInclude | null
    /**
     * The data needed to create a QueuedShopifyOrder.
     * 
    **/
    data: XOR<QueuedShopifyOrderCreateInput, QueuedShopifyOrderUncheckedCreateInput>
  }


  /**
   * QueuedShopifyOrder createMany
   */
  export type QueuedShopifyOrderCreateManyArgs = {
    data: Enumerable<QueuedShopifyOrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QueuedShopifyOrder update
   */
  export type QueuedShopifyOrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the QueuedShopifyOrder
     * 
    **/
    select?: QueuedShopifyOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QueuedShopifyOrderInclude | null
    /**
     * The data needed to update a QueuedShopifyOrder.
     * 
    **/
    data: XOR<QueuedShopifyOrderUpdateInput, QueuedShopifyOrderUncheckedUpdateInput>
    /**
     * Choose, which QueuedShopifyOrder to update.
     * 
    **/
    where: QueuedShopifyOrderWhereUniqueInput
  }


  /**
   * QueuedShopifyOrder updateMany
   */
  export type QueuedShopifyOrderUpdateManyArgs = {
    data: XOR<QueuedShopifyOrderUpdateManyMutationInput, QueuedShopifyOrderUncheckedUpdateManyInput>
    where?: QueuedShopifyOrderWhereInput
  }


  /**
   * QueuedShopifyOrder upsert
   */
  export type QueuedShopifyOrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the QueuedShopifyOrder
     * 
    **/
    select?: QueuedShopifyOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QueuedShopifyOrderInclude | null
    /**
     * The filter to search for the QueuedShopifyOrder to update in case it exists.
     * 
    **/
    where: QueuedShopifyOrderWhereUniqueInput
    /**
     * In case the QueuedShopifyOrder found by the `where` argument doesn't exist, create a new QueuedShopifyOrder with this data.
     * 
    **/
    create: XOR<QueuedShopifyOrderCreateInput, QueuedShopifyOrderUncheckedCreateInput>
    /**
     * In case the QueuedShopifyOrder was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QueuedShopifyOrderUpdateInput, QueuedShopifyOrderUncheckedUpdateInput>
  }


  /**
   * QueuedShopifyOrder delete
   */
  export type QueuedShopifyOrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the QueuedShopifyOrder
     * 
    **/
    select?: QueuedShopifyOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QueuedShopifyOrderInclude | null
    /**
     * Filter which QueuedShopifyOrder to delete.
     * 
    **/
    where: QueuedShopifyOrderWhereUniqueInput
  }


  /**
   * QueuedShopifyOrder deleteMany
   */
  export type QueuedShopifyOrderDeleteManyArgs = {
    where?: QueuedShopifyOrderWhereInput
  }


  /**
   * QueuedShopifyOrder without action
   */
  export type QueuedShopifyOrderArgs = {
    /**
     * Select specific fields to fetch from the QueuedShopifyOrder
     * 
    **/
    select?: QueuedShopifyOrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QueuedShopifyOrderInclude | null
  }



  /**
   * Model Practitioner
   */


  export type AggregatePractitioner = {
    _count: PractitionerCountAggregateOutputType | null
    _avg: PractitionerAvgAggregateOutputType | null
    _sum: PractitionerSumAggregateOutputType | null
    _min: PractitionerMinAggregateOutputType | null
    _max: PractitionerMaxAggregateOutputType | null
  }

  export type PractitionerAvgAggregateOutputType = {
    id: number | null
  }

  export type PractitionerSumAggregateOutputType = {
    id: number | null
  }

  export type PractitionerMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    phoneNumber: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PractitionerMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    phoneNumber: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PractitionerCountAggregateOutputType = {
    id: number
    uuid: number
    email: number
    phoneNumber: number
    firstName: number
    lastName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PractitionerAvgAggregateInputType = {
    id?: true
  }

  export type PractitionerSumAggregateInputType = {
    id?: true
  }

  export type PractitionerMinAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PractitionerMaxAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PractitionerCountAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PractitionerAggregateArgs = {
    /**
     * Filter which Practitioner to aggregate.
     * 
    **/
    where?: PractitionerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Practitioners to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PractitionerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Practitioners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Practitioners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Practitioners
    **/
    _count?: true | PractitionerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PractitionerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PractitionerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PractitionerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PractitionerMaxAggregateInputType
  }

  export type GetPractitionerAggregateType<T extends PractitionerAggregateArgs> = {
        [P in keyof T & keyof AggregatePractitioner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePractitioner[P]>
      : GetScalarType<T[P], AggregatePractitioner[P]>
  }




  export type PractitionerGroupByArgs = {
    where?: PractitionerWhereInput
    orderBy?: Enumerable<PractitionerOrderByWithAggregationInput>
    by: Array<PractitionerScalarFieldEnum>
    having?: PractitionerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PractitionerCountAggregateInputType | true
    _avg?: PractitionerAvgAggregateInputType
    _sum?: PractitionerSumAggregateInputType
    _min?: PractitionerMinAggregateInputType
    _max?: PractitionerMaxAggregateInputType
  }


  export type PractitionerGroupByOutputType = {
    id: number
    uuid: string
    email: string
    phoneNumber: string | null
    firstName: string
    lastName: string | null
    createdAt: Date
    updatedAt: Date
    _count: PractitionerCountAggregateOutputType | null
    _avg: PractitionerAvgAggregateOutputType | null
    _sum: PractitionerSumAggregateOutputType | null
    _min: PractitionerMinAggregateOutputType | null
    _max: PractitionerMaxAggregateOutputType | null
  }

  type GetPractitionerGroupByPayload<T extends PractitionerGroupByArgs> = Promise<
    Array<
      PickArray<PractitionerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PractitionerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PractitionerGroupByOutputType[P]>
            : GetScalarType<T[P], PractitionerGroupByOutputType[P]>
        }
      >
    >


  export type PractitionerSelect = {
    id?: boolean
    uuid?: boolean
    email?: boolean
    phoneNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    practitionerBox?: boolean | PractitionerBoxFindManyArgs
    practitionerSocialMedia?: boolean | PractitionerSocialMediaArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | PractitionerCountOutputTypeArgs
  }

  export type PractitionerInclude = {
    practitionerBox?: boolean | PractitionerBoxFindManyArgs
    practitionerSocialMedia?: boolean | PractitionerSocialMediaArgs
    _count?: boolean | PractitionerCountOutputTypeArgs
  }

  export type PractitionerGetPayload<
    S extends boolean | null | undefined | PractitionerArgs,
    U = keyof S
      > = S extends true
        ? Practitioner
    : S extends undefined
    ? never
    : S extends PractitionerArgs | PractitionerFindManyArgs
    ?'include' extends U
    ? Practitioner  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'practitionerBox'
        ? Array < PractitionerBoxGetPayload<S['include'][P]>>  :
        P extends 'practitionerSocialMedia'
        ? PractitionerSocialMediaGetPayload<S['include'][P]> | null :
        P extends '_count'
        ? PractitionerCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Practitioner ?Practitioner [P]
  : 
          P extends 'practitionerBox'
        ? Array < PractitionerBoxGetPayload<S['select'][P]>>  :
        P extends 'practitionerSocialMedia'
        ? PractitionerSocialMediaGetPayload<S['select'][P]> | null :
        P extends '_count'
        ? PractitionerCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : Practitioner
  : Practitioner


  type PractitionerCountArgs = Merge<
    Omit<PractitionerFindManyArgs, 'select' | 'include'> & {
      select?: PractitionerCountAggregateInputType | true
    }
  >

  export interface PractitionerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Practitioner that matches the filter.
     * @param {PractitionerFindUniqueArgs} args - Arguments to find a Practitioner
     * @example
     * // Get one Practitioner
     * const practitioner = await prisma.practitioner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PractitionerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PractitionerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Practitioner'> extends True ? CheckSelect<T, Prisma__PractitionerClient<Practitioner>, Prisma__PractitionerClient<PractitionerGetPayload<T>>> : CheckSelect<T, Prisma__PractitionerClient<Practitioner | null >, Prisma__PractitionerClient<PractitionerGetPayload<T> | null >>

    /**
     * Find the first Practitioner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerFindFirstArgs} args - Arguments to find a Practitioner
     * @example
     * // Get one Practitioner
     * const practitioner = await prisma.practitioner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PractitionerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PractitionerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Practitioner'> extends True ? CheckSelect<T, Prisma__PractitionerClient<Practitioner>, Prisma__PractitionerClient<PractitionerGetPayload<T>>> : CheckSelect<T, Prisma__PractitionerClient<Practitioner | null >, Prisma__PractitionerClient<PractitionerGetPayload<T> | null >>

    /**
     * Find zero or more Practitioners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Practitioners
     * const practitioners = await prisma.practitioner.findMany()
     * 
     * // Get first 10 Practitioners
     * const practitioners = await prisma.practitioner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practitionerWithIdOnly = await prisma.practitioner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PractitionerFindManyArgs>(
      args?: SelectSubset<T, PractitionerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Practitioner>>, PrismaPromise<Array<PractitionerGetPayload<T>>>>

    /**
     * Create a Practitioner.
     * @param {PractitionerCreateArgs} args - Arguments to create a Practitioner.
     * @example
     * // Create one Practitioner
     * const Practitioner = await prisma.practitioner.create({
     *   data: {
     *     // ... data to create a Practitioner
     *   }
     * })
     * 
    **/
    create<T extends PractitionerCreateArgs>(
      args: SelectSubset<T, PractitionerCreateArgs>
    ): CheckSelect<T, Prisma__PractitionerClient<Practitioner>, Prisma__PractitionerClient<PractitionerGetPayload<T>>>

    /**
     * Create many Practitioners.
     *     @param {PractitionerCreateManyArgs} args - Arguments to create many Practitioners.
     *     @example
     *     // Create many Practitioners
     *     const practitioner = await prisma.practitioner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PractitionerCreateManyArgs>(
      args?: SelectSubset<T, PractitionerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Practitioner.
     * @param {PractitionerDeleteArgs} args - Arguments to delete one Practitioner.
     * @example
     * // Delete one Practitioner
     * const Practitioner = await prisma.practitioner.delete({
     *   where: {
     *     // ... filter to delete one Practitioner
     *   }
     * })
     * 
    **/
    delete<T extends PractitionerDeleteArgs>(
      args: SelectSubset<T, PractitionerDeleteArgs>
    ): CheckSelect<T, Prisma__PractitionerClient<Practitioner>, Prisma__PractitionerClient<PractitionerGetPayload<T>>>

    /**
     * Update one Practitioner.
     * @param {PractitionerUpdateArgs} args - Arguments to update one Practitioner.
     * @example
     * // Update one Practitioner
     * const practitioner = await prisma.practitioner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PractitionerUpdateArgs>(
      args: SelectSubset<T, PractitionerUpdateArgs>
    ): CheckSelect<T, Prisma__PractitionerClient<Practitioner>, Prisma__PractitionerClient<PractitionerGetPayload<T>>>

    /**
     * Delete zero or more Practitioners.
     * @param {PractitionerDeleteManyArgs} args - Arguments to filter Practitioners to delete.
     * @example
     * // Delete a few Practitioners
     * const { count } = await prisma.practitioner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PractitionerDeleteManyArgs>(
      args?: SelectSubset<T, PractitionerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Practitioners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Practitioners
     * const practitioner = await prisma.practitioner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PractitionerUpdateManyArgs>(
      args: SelectSubset<T, PractitionerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Practitioner.
     * @param {PractitionerUpsertArgs} args - Arguments to update or create a Practitioner.
     * @example
     * // Update or create a Practitioner
     * const practitioner = await prisma.practitioner.upsert({
     *   create: {
     *     // ... data to create a Practitioner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Practitioner we want to update
     *   }
     * })
    **/
    upsert<T extends PractitionerUpsertArgs>(
      args: SelectSubset<T, PractitionerUpsertArgs>
    ): CheckSelect<T, Prisma__PractitionerClient<Practitioner>, Prisma__PractitionerClient<PractitionerGetPayload<T>>>

    /**
     * Count the number of Practitioners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerCountArgs} args - Arguments to filter Practitioners to count.
     * @example
     * // Count the number of Practitioners
     * const count = await prisma.practitioner.count({
     *   where: {
     *     // ... the filter for the Practitioners we want to count
     *   }
     * })
    **/
    count<T extends PractitionerCountArgs>(
      args?: Subset<T, PractitionerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PractitionerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Practitioner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PractitionerAggregateArgs>(args: Subset<T, PractitionerAggregateArgs>): PrismaPromise<GetPractitionerAggregateType<T>>

    /**
     * Group by Practitioner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PractitionerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PractitionerGroupByArgs['orderBy'] }
        : { orderBy?: PractitionerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PractitionerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPractitionerGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Practitioner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PractitionerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    practitionerBox<T extends PractitionerBoxFindManyArgs = {}>(args?: Subset<T, PractitionerBoxFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PractitionerBox>>, PrismaPromise<Array<PractitionerBoxGetPayload<T>>>>;

    practitionerSocialMedia<T extends PractitionerSocialMediaArgs = {}>(args?: Subset<T, PractitionerSocialMediaArgs>): CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia | null >, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Practitioner findUnique
   */
  export type PractitionerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Practitioner
     * 
    **/
    select?: PractitionerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerInclude | null
    /**
     * Throw an Error if a Practitioner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Practitioner to fetch.
     * 
    **/
    where: PractitionerWhereUniqueInput
  }


  /**
   * Practitioner findFirst
   */
  export type PractitionerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Practitioner
     * 
    **/
    select?: PractitionerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerInclude | null
    /**
     * Throw an Error if a Practitioner can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Practitioner to fetch.
     * 
    **/
    where?: PractitionerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Practitioners to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Practitioners.
     * 
    **/
    cursor?: PractitionerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Practitioners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Practitioners.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Practitioners.
     * 
    **/
    distinct?: Enumerable<PractitionerScalarFieldEnum>
  }


  /**
   * Practitioner findMany
   */
  export type PractitionerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Practitioner
     * 
    **/
    select?: PractitionerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerInclude | null
    /**
     * Filter, which Practitioners to fetch.
     * 
    **/
    where?: PractitionerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Practitioners to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Practitioners.
     * 
    **/
    cursor?: PractitionerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Practitioners from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Practitioners.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PractitionerScalarFieldEnum>
  }


  /**
   * Practitioner create
   */
  export type PractitionerCreateArgs = {
    /**
     * Select specific fields to fetch from the Practitioner
     * 
    **/
    select?: PractitionerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerInclude | null
    /**
     * The data needed to create a Practitioner.
     * 
    **/
    data: XOR<PractitionerCreateInput, PractitionerUncheckedCreateInput>
  }


  /**
   * Practitioner createMany
   */
  export type PractitionerCreateManyArgs = {
    data: Enumerable<PractitionerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Practitioner update
   */
  export type PractitionerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Practitioner
     * 
    **/
    select?: PractitionerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerInclude | null
    /**
     * The data needed to update a Practitioner.
     * 
    **/
    data: XOR<PractitionerUpdateInput, PractitionerUncheckedUpdateInput>
    /**
     * Choose, which Practitioner to update.
     * 
    **/
    where: PractitionerWhereUniqueInput
  }


  /**
   * Practitioner updateMany
   */
  export type PractitionerUpdateManyArgs = {
    data: XOR<PractitionerUpdateManyMutationInput, PractitionerUncheckedUpdateManyInput>
    where?: PractitionerWhereInput
  }


  /**
   * Practitioner upsert
   */
  export type PractitionerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Practitioner
     * 
    **/
    select?: PractitionerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerInclude | null
    /**
     * The filter to search for the Practitioner to update in case it exists.
     * 
    **/
    where: PractitionerWhereUniqueInput
    /**
     * In case the Practitioner found by the `where` argument doesn't exist, create a new Practitioner with this data.
     * 
    **/
    create: XOR<PractitionerCreateInput, PractitionerUncheckedCreateInput>
    /**
     * In case the Practitioner was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PractitionerUpdateInput, PractitionerUncheckedUpdateInput>
  }


  /**
   * Practitioner delete
   */
  export type PractitionerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Practitioner
     * 
    **/
    select?: PractitionerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerInclude | null
    /**
     * Filter which Practitioner to delete.
     * 
    **/
    where: PractitionerWhereUniqueInput
  }


  /**
   * Practitioner deleteMany
   */
  export type PractitionerDeleteManyArgs = {
    where?: PractitionerWhereInput
  }


  /**
   * Practitioner without action
   */
  export type PractitionerArgs = {
    /**
     * Select specific fields to fetch from the Practitioner
     * 
    **/
    select?: PractitionerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerInclude | null
  }



  /**
   * Model PractitionerSocialMedia
   */


  export type AggregatePractitionerSocialMedia = {
    _count: PractitionerSocialMediaCountAggregateOutputType | null
    _avg: PractitionerSocialMediaAvgAggregateOutputType | null
    _sum: PractitionerSocialMediaSumAggregateOutputType | null
    _min: PractitionerSocialMediaMinAggregateOutputType | null
    _max: PractitionerSocialMediaMaxAggregateOutputType | null
  }

  export type PractitionerSocialMediaAvgAggregateOutputType = {
    id: number | null
    practitionerId: number | null
  }

  export type PractitionerSocialMediaSumAggregateOutputType = {
    id: number | null
    practitionerId: number | null
  }

  export type PractitionerSocialMediaMinAggregateOutputType = {
    id: number | null
    practitionerId: number | null
    instagram: string | null
    facebook: string | null
    twitter: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PractitionerSocialMediaMaxAggregateOutputType = {
    id: number | null
    practitionerId: number | null
    instagram: string | null
    facebook: string | null
    twitter: string | null
    website: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PractitionerSocialMediaCountAggregateOutputType = {
    id: number
    practitionerId: number
    instagram: number
    facebook: number
    twitter: number
    website: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PractitionerSocialMediaAvgAggregateInputType = {
    id?: true
    practitionerId?: true
  }

  export type PractitionerSocialMediaSumAggregateInputType = {
    id?: true
    practitionerId?: true
  }

  export type PractitionerSocialMediaMinAggregateInputType = {
    id?: true
    practitionerId?: true
    instagram?: true
    facebook?: true
    twitter?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PractitionerSocialMediaMaxAggregateInputType = {
    id?: true
    practitionerId?: true
    instagram?: true
    facebook?: true
    twitter?: true
    website?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PractitionerSocialMediaCountAggregateInputType = {
    id?: true
    practitionerId?: true
    instagram?: true
    facebook?: true
    twitter?: true
    website?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PractitionerSocialMediaAggregateArgs = {
    /**
     * Filter which PractitionerSocialMedia to aggregate.
     * 
    **/
    where?: PractitionerSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerSocialMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerSocialMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PractitionerSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerSocialMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerSocialMedias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PractitionerSocialMedias
    **/
    _count?: true | PractitionerSocialMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PractitionerSocialMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PractitionerSocialMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PractitionerSocialMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PractitionerSocialMediaMaxAggregateInputType
  }

  export type GetPractitionerSocialMediaAggregateType<T extends PractitionerSocialMediaAggregateArgs> = {
        [P in keyof T & keyof AggregatePractitionerSocialMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePractitionerSocialMedia[P]>
      : GetScalarType<T[P], AggregatePractitionerSocialMedia[P]>
  }




  export type PractitionerSocialMediaGroupByArgs = {
    where?: PractitionerSocialMediaWhereInput
    orderBy?: Enumerable<PractitionerSocialMediaOrderByWithAggregationInput>
    by: Array<PractitionerSocialMediaScalarFieldEnum>
    having?: PractitionerSocialMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PractitionerSocialMediaCountAggregateInputType | true
    _avg?: PractitionerSocialMediaAvgAggregateInputType
    _sum?: PractitionerSocialMediaSumAggregateInputType
    _min?: PractitionerSocialMediaMinAggregateInputType
    _max?: PractitionerSocialMediaMaxAggregateInputType
  }


  export type PractitionerSocialMediaGroupByOutputType = {
    id: number
    practitionerId: number
    instagram: string | null
    facebook: string | null
    twitter: string | null
    website: string | null
    createdAt: Date
    updatedAt: Date
    _count: PractitionerSocialMediaCountAggregateOutputType | null
    _avg: PractitionerSocialMediaAvgAggregateOutputType | null
    _sum: PractitionerSocialMediaSumAggregateOutputType | null
    _min: PractitionerSocialMediaMinAggregateOutputType | null
    _max: PractitionerSocialMediaMaxAggregateOutputType | null
  }

  type GetPractitionerSocialMediaGroupByPayload<T extends PractitionerSocialMediaGroupByArgs> = Promise<
    Array<
      PickArray<PractitionerSocialMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PractitionerSocialMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PractitionerSocialMediaGroupByOutputType[P]>
            : GetScalarType<T[P], PractitionerSocialMediaGroupByOutputType[P]>
        }
      >
    >


  export type PractitionerSocialMediaSelect = {
    id?: boolean
    practitioner?: boolean | PractitionerArgs
    practitionerId?: boolean
    instagram?: boolean
    facebook?: boolean
    twitter?: boolean
    website?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PractitionerSocialMediaInclude = {
    practitioner?: boolean | PractitionerArgs
  }

  export type PractitionerSocialMediaGetPayload<
    S extends boolean | null | undefined | PractitionerSocialMediaArgs,
    U = keyof S
      > = S extends true
        ? PractitionerSocialMedia
    : S extends undefined
    ? never
    : S extends PractitionerSocialMediaArgs | PractitionerSocialMediaFindManyArgs
    ?'include' extends U
    ? PractitionerSocialMedia  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'practitioner'
        ? PractitionerGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PractitionerSocialMedia ?PractitionerSocialMedia [P]
  : 
          P extends 'practitioner'
        ? PractitionerGetPayload<S['select'][P]> : never
  } 
    : PractitionerSocialMedia
  : PractitionerSocialMedia


  type PractitionerSocialMediaCountArgs = Merge<
    Omit<PractitionerSocialMediaFindManyArgs, 'select' | 'include'> & {
      select?: PractitionerSocialMediaCountAggregateInputType | true
    }
  >

  export interface PractitionerSocialMediaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PractitionerSocialMedia that matches the filter.
     * @param {PractitionerSocialMediaFindUniqueArgs} args - Arguments to find a PractitionerSocialMedia
     * @example
     * // Get one PractitionerSocialMedia
     * const practitionerSocialMedia = await prisma.practitionerSocialMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PractitionerSocialMediaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PractitionerSocialMediaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PractitionerSocialMedia'> extends True ? CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia>, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T>>> : CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia | null >, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T> | null >>

    /**
     * Find the first PractitionerSocialMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerSocialMediaFindFirstArgs} args - Arguments to find a PractitionerSocialMedia
     * @example
     * // Get one PractitionerSocialMedia
     * const practitionerSocialMedia = await prisma.practitionerSocialMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PractitionerSocialMediaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PractitionerSocialMediaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PractitionerSocialMedia'> extends True ? CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia>, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T>>> : CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia | null >, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T> | null >>

    /**
     * Find zero or more PractitionerSocialMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerSocialMediaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PractitionerSocialMedias
     * const practitionerSocialMedias = await prisma.practitionerSocialMedia.findMany()
     * 
     * // Get first 10 PractitionerSocialMedias
     * const practitionerSocialMedias = await prisma.practitionerSocialMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practitionerSocialMediaWithIdOnly = await prisma.practitionerSocialMedia.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PractitionerSocialMediaFindManyArgs>(
      args?: SelectSubset<T, PractitionerSocialMediaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PractitionerSocialMedia>>, PrismaPromise<Array<PractitionerSocialMediaGetPayload<T>>>>

    /**
     * Create a PractitionerSocialMedia.
     * @param {PractitionerSocialMediaCreateArgs} args - Arguments to create a PractitionerSocialMedia.
     * @example
     * // Create one PractitionerSocialMedia
     * const PractitionerSocialMedia = await prisma.practitionerSocialMedia.create({
     *   data: {
     *     // ... data to create a PractitionerSocialMedia
     *   }
     * })
     * 
    **/
    create<T extends PractitionerSocialMediaCreateArgs>(
      args: SelectSubset<T, PractitionerSocialMediaCreateArgs>
    ): CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia>, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T>>>

    /**
     * Create many PractitionerSocialMedias.
     *     @param {PractitionerSocialMediaCreateManyArgs} args - Arguments to create many PractitionerSocialMedias.
     *     @example
     *     // Create many PractitionerSocialMedias
     *     const practitionerSocialMedia = await prisma.practitionerSocialMedia.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PractitionerSocialMediaCreateManyArgs>(
      args?: SelectSubset<T, PractitionerSocialMediaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PractitionerSocialMedia.
     * @param {PractitionerSocialMediaDeleteArgs} args - Arguments to delete one PractitionerSocialMedia.
     * @example
     * // Delete one PractitionerSocialMedia
     * const PractitionerSocialMedia = await prisma.practitionerSocialMedia.delete({
     *   where: {
     *     // ... filter to delete one PractitionerSocialMedia
     *   }
     * })
     * 
    **/
    delete<T extends PractitionerSocialMediaDeleteArgs>(
      args: SelectSubset<T, PractitionerSocialMediaDeleteArgs>
    ): CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia>, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T>>>

    /**
     * Update one PractitionerSocialMedia.
     * @param {PractitionerSocialMediaUpdateArgs} args - Arguments to update one PractitionerSocialMedia.
     * @example
     * // Update one PractitionerSocialMedia
     * const practitionerSocialMedia = await prisma.practitionerSocialMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PractitionerSocialMediaUpdateArgs>(
      args: SelectSubset<T, PractitionerSocialMediaUpdateArgs>
    ): CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia>, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T>>>

    /**
     * Delete zero or more PractitionerSocialMedias.
     * @param {PractitionerSocialMediaDeleteManyArgs} args - Arguments to filter PractitionerSocialMedias to delete.
     * @example
     * // Delete a few PractitionerSocialMedias
     * const { count } = await prisma.practitionerSocialMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PractitionerSocialMediaDeleteManyArgs>(
      args?: SelectSubset<T, PractitionerSocialMediaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PractitionerSocialMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerSocialMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PractitionerSocialMedias
     * const practitionerSocialMedia = await prisma.practitionerSocialMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PractitionerSocialMediaUpdateManyArgs>(
      args: SelectSubset<T, PractitionerSocialMediaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PractitionerSocialMedia.
     * @param {PractitionerSocialMediaUpsertArgs} args - Arguments to update or create a PractitionerSocialMedia.
     * @example
     * // Update or create a PractitionerSocialMedia
     * const practitionerSocialMedia = await prisma.practitionerSocialMedia.upsert({
     *   create: {
     *     // ... data to create a PractitionerSocialMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PractitionerSocialMedia we want to update
     *   }
     * })
    **/
    upsert<T extends PractitionerSocialMediaUpsertArgs>(
      args: SelectSubset<T, PractitionerSocialMediaUpsertArgs>
    ): CheckSelect<T, Prisma__PractitionerSocialMediaClient<PractitionerSocialMedia>, Prisma__PractitionerSocialMediaClient<PractitionerSocialMediaGetPayload<T>>>

    /**
     * Count the number of PractitionerSocialMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerSocialMediaCountArgs} args - Arguments to filter PractitionerSocialMedias to count.
     * @example
     * // Count the number of PractitionerSocialMedias
     * const count = await prisma.practitionerSocialMedia.count({
     *   where: {
     *     // ... the filter for the PractitionerSocialMedias we want to count
     *   }
     * })
    **/
    count<T extends PractitionerSocialMediaCountArgs>(
      args?: Subset<T, PractitionerSocialMediaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PractitionerSocialMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PractitionerSocialMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerSocialMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PractitionerSocialMediaAggregateArgs>(args: Subset<T, PractitionerSocialMediaAggregateArgs>): PrismaPromise<GetPractitionerSocialMediaAggregateType<T>>

    /**
     * Group by PractitionerSocialMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerSocialMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PractitionerSocialMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PractitionerSocialMediaGroupByArgs['orderBy'] }
        : { orderBy?: PractitionerSocialMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PractitionerSocialMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPractitionerSocialMediaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PractitionerSocialMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PractitionerSocialMediaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    practitioner<T extends PractitionerArgs = {}>(args?: Subset<T, PractitionerArgs>): CheckSelect<T, Prisma__PractitionerClient<Practitioner | null >, Prisma__PractitionerClient<PractitionerGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PractitionerSocialMedia findUnique
   */
  export type PractitionerSocialMediaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PractitionerSocialMedia
     * 
    **/
    select?: PractitionerSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerSocialMediaInclude | null
    /**
     * Throw an Error if a PractitionerSocialMedia can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PractitionerSocialMedia to fetch.
     * 
    **/
    where: PractitionerSocialMediaWhereUniqueInput
  }


  /**
   * PractitionerSocialMedia findFirst
   */
  export type PractitionerSocialMediaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PractitionerSocialMedia
     * 
    **/
    select?: PractitionerSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerSocialMediaInclude | null
    /**
     * Throw an Error if a PractitionerSocialMedia can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PractitionerSocialMedia to fetch.
     * 
    **/
    where?: PractitionerSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerSocialMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerSocialMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PractitionerSocialMedias.
     * 
    **/
    cursor?: PractitionerSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerSocialMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerSocialMedias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PractitionerSocialMedias.
     * 
    **/
    distinct?: Enumerable<PractitionerSocialMediaScalarFieldEnum>
  }


  /**
   * PractitionerSocialMedia findMany
   */
  export type PractitionerSocialMediaFindManyArgs = {
    /**
     * Select specific fields to fetch from the PractitionerSocialMedia
     * 
    **/
    select?: PractitionerSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerSocialMediaInclude | null
    /**
     * Filter, which PractitionerSocialMedias to fetch.
     * 
    **/
    where?: PractitionerSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerSocialMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerSocialMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PractitionerSocialMedias.
     * 
    **/
    cursor?: PractitionerSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerSocialMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerSocialMedias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PractitionerSocialMediaScalarFieldEnum>
  }


  /**
   * PractitionerSocialMedia create
   */
  export type PractitionerSocialMediaCreateArgs = {
    /**
     * Select specific fields to fetch from the PractitionerSocialMedia
     * 
    **/
    select?: PractitionerSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerSocialMediaInclude | null
    /**
     * The data needed to create a PractitionerSocialMedia.
     * 
    **/
    data: XOR<PractitionerSocialMediaCreateInput, PractitionerSocialMediaUncheckedCreateInput>
  }


  /**
   * PractitionerSocialMedia createMany
   */
  export type PractitionerSocialMediaCreateManyArgs = {
    data: Enumerable<PractitionerSocialMediaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PractitionerSocialMedia update
   */
  export type PractitionerSocialMediaUpdateArgs = {
    /**
     * Select specific fields to fetch from the PractitionerSocialMedia
     * 
    **/
    select?: PractitionerSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerSocialMediaInclude | null
    /**
     * The data needed to update a PractitionerSocialMedia.
     * 
    **/
    data: XOR<PractitionerSocialMediaUpdateInput, PractitionerSocialMediaUncheckedUpdateInput>
    /**
     * Choose, which PractitionerSocialMedia to update.
     * 
    **/
    where: PractitionerSocialMediaWhereUniqueInput
  }


  /**
   * PractitionerSocialMedia updateMany
   */
  export type PractitionerSocialMediaUpdateManyArgs = {
    data: XOR<PractitionerSocialMediaUpdateManyMutationInput, PractitionerSocialMediaUncheckedUpdateManyInput>
    where?: PractitionerSocialMediaWhereInput
  }


  /**
   * PractitionerSocialMedia upsert
   */
  export type PractitionerSocialMediaUpsertArgs = {
    /**
     * Select specific fields to fetch from the PractitionerSocialMedia
     * 
    **/
    select?: PractitionerSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerSocialMediaInclude | null
    /**
     * The filter to search for the PractitionerSocialMedia to update in case it exists.
     * 
    **/
    where: PractitionerSocialMediaWhereUniqueInput
    /**
     * In case the PractitionerSocialMedia found by the `where` argument doesn't exist, create a new PractitionerSocialMedia with this data.
     * 
    **/
    create: XOR<PractitionerSocialMediaCreateInput, PractitionerSocialMediaUncheckedCreateInput>
    /**
     * In case the PractitionerSocialMedia was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PractitionerSocialMediaUpdateInput, PractitionerSocialMediaUncheckedUpdateInput>
  }


  /**
   * PractitionerSocialMedia delete
   */
  export type PractitionerSocialMediaDeleteArgs = {
    /**
     * Select specific fields to fetch from the PractitionerSocialMedia
     * 
    **/
    select?: PractitionerSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerSocialMediaInclude | null
    /**
     * Filter which PractitionerSocialMedia to delete.
     * 
    **/
    where: PractitionerSocialMediaWhereUniqueInput
  }


  /**
   * PractitionerSocialMedia deleteMany
   */
  export type PractitionerSocialMediaDeleteManyArgs = {
    where?: PractitionerSocialMediaWhereInput
  }


  /**
   * PractitionerSocialMedia without action
   */
  export type PractitionerSocialMediaArgs = {
    /**
     * Select specific fields to fetch from the PractitionerSocialMedia
     * 
    **/
    select?: PractitionerSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerSocialMediaInclude | null
  }



  /**
   * Model PractitionerBox
   */


  export type AggregatePractitionerBox = {
    _count: PractitionerBoxCountAggregateOutputType | null
    _avg: PractitionerBoxAvgAggregateOutputType | null
    _sum: PractitionerBoxSumAggregateOutputType | null
    _min: PractitionerBoxMinAggregateOutputType | null
    _max: PractitionerBoxMaxAggregateOutputType | null
  }

  export type PractitionerBoxAvgAggregateOutputType = {
    id: number | null
    practitionerId: number | null
  }

  export type PractitionerBoxSumAggregateOutputType = {
    id: number | null
    practitionerId: number | null
  }

  export type PractitionerBoxMinAggregateOutputType = {
    id: number | null
    practitionerId: number | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PractitionerBoxMaxAggregateOutputType = {
    id: number | null
    practitionerId: number | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PractitionerBoxCountAggregateOutputType = {
    id: number
    practitionerId: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PractitionerBoxAvgAggregateInputType = {
    id?: true
    practitionerId?: true
  }

  export type PractitionerBoxSumAggregateInputType = {
    id?: true
    practitionerId?: true
  }

  export type PractitionerBoxMinAggregateInputType = {
    id?: true
    practitionerId?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PractitionerBoxMaxAggregateInputType = {
    id?: true
    practitionerId?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PractitionerBoxCountAggregateInputType = {
    id?: true
    practitionerId?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PractitionerBoxAggregateArgs = {
    /**
     * Filter which PractitionerBox to aggregate.
     * 
    **/
    where?: PractitionerBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerBoxes to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerBoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PractitionerBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerBoxes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerBoxes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PractitionerBoxes
    **/
    _count?: true | PractitionerBoxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PractitionerBoxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PractitionerBoxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PractitionerBoxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PractitionerBoxMaxAggregateInputType
  }

  export type GetPractitionerBoxAggregateType<T extends PractitionerBoxAggregateArgs> = {
        [P in keyof T & keyof AggregatePractitionerBox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePractitionerBox[P]>
      : GetScalarType<T[P], AggregatePractitionerBox[P]>
  }




  export type PractitionerBoxGroupByArgs = {
    where?: PractitionerBoxWhereInput
    orderBy?: Enumerable<PractitionerBoxOrderByWithAggregationInput>
    by: Array<PractitionerBoxScalarFieldEnum>
    having?: PractitionerBoxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PractitionerBoxCountAggregateInputType | true
    _avg?: PractitionerBoxAvgAggregateInputType
    _sum?: PractitionerBoxSumAggregateInputType
    _min?: PractitionerBoxMinAggregateInputType
    _max?: PractitionerBoxMaxAggregateInputType
  }


  export type PractitionerBoxGroupByOutputType = {
    id: number
    practitionerId: number
    label: string
    createdAt: Date
    updatedAt: Date
    _count: PractitionerBoxCountAggregateOutputType | null
    _avg: PractitionerBoxAvgAggregateOutputType | null
    _sum: PractitionerBoxSumAggregateOutputType | null
    _min: PractitionerBoxMinAggregateOutputType | null
    _max: PractitionerBoxMaxAggregateOutputType | null
  }

  type GetPractitionerBoxGroupByPayload<T extends PractitionerBoxGroupByArgs> = Promise<
    Array<
      PickArray<PractitionerBoxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PractitionerBoxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PractitionerBoxGroupByOutputType[P]>
            : GetScalarType<T[P], PractitionerBoxGroupByOutputType[P]>
        }
      >
    >


  export type PractitionerBoxSelect = {
    id?: boolean
    practitioner?: boolean | PractitionerArgs
    practitionerId?: boolean
    practitionerCustomerOrderHistory?: boolean | PractitionerCustomerOrderHistoryFindManyArgs
    label?: boolean
    intermediatePractitionerBoxProduct?: boolean | IntermediatePractitionerBoxProductFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
    _count?: boolean | PractitionerBoxCountOutputTypeArgs
  }

  export type PractitionerBoxInclude = {
    practitioner?: boolean | PractitionerArgs
    practitionerCustomerOrderHistory?: boolean | PractitionerCustomerOrderHistoryFindManyArgs
    intermediatePractitionerBoxProduct?: boolean | IntermediatePractitionerBoxProductFindManyArgs
    _count?: boolean | PractitionerBoxCountOutputTypeArgs
  }

  export type PractitionerBoxGetPayload<
    S extends boolean | null | undefined | PractitionerBoxArgs,
    U = keyof S
      > = S extends true
        ? PractitionerBox
    : S extends undefined
    ? never
    : S extends PractitionerBoxArgs | PractitionerBoxFindManyArgs
    ?'include' extends U
    ? PractitionerBox  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'practitioner'
        ? PractitionerGetPayload<S['include'][P]> :
        P extends 'practitionerCustomerOrderHistory'
        ? Array < PractitionerCustomerOrderHistoryGetPayload<S['include'][P]>>  :
        P extends 'intermediatePractitionerBoxProduct'
        ? Array < IntermediatePractitionerBoxProductGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? PractitionerBoxCountOutputTypeGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PractitionerBox ?PractitionerBox [P]
  : 
          P extends 'practitioner'
        ? PractitionerGetPayload<S['select'][P]> :
        P extends 'practitionerCustomerOrderHistory'
        ? Array < PractitionerCustomerOrderHistoryGetPayload<S['select'][P]>>  :
        P extends 'intermediatePractitionerBoxProduct'
        ? Array < IntermediatePractitionerBoxProductGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? PractitionerBoxCountOutputTypeGetPayload<S['select'][P]> : never
  } 
    : PractitionerBox
  : PractitionerBox


  type PractitionerBoxCountArgs = Merge<
    Omit<PractitionerBoxFindManyArgs, 'select' | 'include'> & {
      select?: PractitionerBoxCountAggregateInputType | true
    }
  >

  export interface PractitionerBoxDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PractitionerBox that matches the filter.
     * @param {PractitionerBoxFindUniqueArgs} args - Arguments to find a PractitionerBox
     * @example
     * // Get one PractitionerBox
     * const practitionerBox = await prisma.practitionerBox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PractitionerBoxFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PractitionerBoxFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PractitionerBox'> extends True ? CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox>, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T>>> : CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox | null >, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T> | null >>

    /**
     * Find the first PractitionerBox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerBoxFindFirstArgs} args - Arguments to find a PractitionerBox
     * @example
     * // Get one PractitionerBox
     * const practitionerBox = await prisma.practitionerBox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PractitionerBoxFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PractitionerBoxFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PractitionerBox'> extends True ? CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox>, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T>>> : CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox | null >, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T> | null >>

    /**
     * Find zero or more PractitionerBoxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerBoxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PractitionerBoxes
     * const practitionerBoxes = await prisma.practitionerBox.findMany()
     * 
     * // Get first 10 PractitionerBoxes
     * const practitionerBoxes = await prisma.practitionerBox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practitionerBoxWithIdOnly = await prisma.practitionerBox.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PractitionerBoxFindManyArgs>(
      args?: SelectSubset<T, PractitionerBoxFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PractitionerBox>>, PrismaPromise<Array<PractitionerBoxGetPayload<T>>>>

    /**
     * Create a PractitionerBox.
     * @param {PractitionerBoxCreateArgs} args - Arguments to create a PractitionerBox.
     * @example
     * // Create one PractitionerBox
     * const PractitionerBox = await prisma.practitionerBox.create({
     *   data: {
     *     // ... data to create a PractitionerBox
     *   }
     * })
     * 
    **/
    create<T extends PractitionerBoxCreateArgs>(
      args: SelectSubset<T, PractitionerBoxCreateArgs>
    ): CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox>, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T>>>

    /**
     * Create many PractitionerBoxes.
     *     @param {PractitionerBoxCreateManyArgs} args - Arguments to create many PractitionerBoxes.
     *     @example
     *     // Create many PractitionerBoxes
     *     const practitionerBox = await prisma.practitionerBox.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PractitionerBoxCreateManyArgs>(
      args?: SelectSubset<T, PractitionerBoxCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PractitionerBox.
     * @param {PractitionerBoxDeleteArgs} args - Arguments to delete one PractitionerBox.
     * @example
     * // Delete one PractitionerBox
     * const PractitionerBox = await prisma.practitionerBox.delete({
     *   where: {
     *     // ... filter to delete one PractitionerBox
     *   }
     * })
     * 
    **/
    delete<T extends PractitionerBoxDeleteArgs>(
      args: SelectSubset<T, PractitionerBoxDeleteArgs>
    ): CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox>, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T>>>

    /**
     * Update one PractitionerBox.
     * @param {PractitionerBoxUpdateArgs} args - Arguments to update one PractitionerBox.
     * @example
     * // Update one PractitionerBox
     * const practitionerBox = await prisma.practitionerBox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PractitionerBoxUpdateArgs>(
      args: SelectSubset<T, PractitionerBoxUpdateArgs>
    ): CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox>, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T>>>

    /**
     * Delete zero or more PractitionerBoxes.
     * @param {PractitionerBoxDeleteManyArgs} args - Arguments to filter PractitionerBoxes to delete.
     * @example
     * // Delete a few PractitionerBoxes
     * const { count } = await prisma.practitionerBox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PractitionerBoxDeleteManyArgs>(
      args?: SelectSubset<T, PractitionerBoxDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PractitionerBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerBoxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PractitionerBoxes
     * const practitionerBox = await prisma.practitionerBox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PractitionerBoxUpdateManyArgs>(
      args: SelectSubset<T, PractitionerBoxUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PractitionerBox.
     * @param {PractitionerBoxUpsertArgs} args - Arguments to update or create a PractitionerBox.
     * @example
     * // Update or create a PractitionerBox
     * const practitionerBox = await prisma.practitionerBox.upsert({
     *   create: {
     *     // ... data to create a PractitionerBox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PractitionerBox we want to update
     *   }
     * })
    **/
    upsert<T extends PractitionerBoxUpsertArgs>(
      args: SelectSubset<T, PractitionerBoxUpsertArgs>
    ): CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox>, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T>>>

    /**
     * Count the number of PractitionerBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerBoxCountArgs} args - Arguments to filter PractitionerBoxes to count.
     * @example
     * // Count the number of PractitionerBoxes
     * const count = await prisma.practitionerBox.count({
     *   where: {
     *     // ... the filter for the PractitionerBoxes we want to count
     *   }
     * })
    **/
    count<T extends PractitionerBoxCountArgs>(
      args?: Subset<T, PractitionerBoxCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PractitionerBoxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PractitionerBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerBoxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PractitionerBoxAggregateArgs>(args: Subset<T, PractitionerBoxAggregateArgs>): PrismaPromise<GetPractitionerBoxAggregateType<T>>

    /**
     * Group by PractitionerBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerBoxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PractitionerBoxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PractitionerBoxGroupByArgs['orderBy'] }
        : { orderBy?: PractitionerBoxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PractitionerBoxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPractitionerBoxGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PractitionerBox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PractitionerBoxClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    practitioner<T extends PractitionerArgs = {}>(args?: Subset<T, PractitionerArgs>): CheckSelect<T, Prisma__PractitionerClient<Practitioner | null >, Prisma__PractitionerClient<PractitionerGetPayload<T> | null >>;

    practitionerCustomerOrderHistory<T extends PractitionerCustomerOrderHistoryFindManyArgs = {}>(args?: Subset<T, PractitionerCustomerOrderHistoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PractitionerCustomerOrderHistory>>, PrismaPromise<Array<PractitionerCustomerOrderHistoryGetPayload<T>>>>;

    intermediatePractitionerBoxProduct<T extends IntermediatePractitionerBoxProductFindManyArgs = {}>(args?: Subset<T, IntermediatePractitionerBoxProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<IntermediatePractitionerBoxProduct>>, PrismaPromise<Array<IntermediatePractitionerBoxProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PractitionerBox findUnique
   */
  export type PractitionerBoxFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBox
     * 
    **/
    select?: PractitionerBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerBoxInclude | null
    /**
     * Throw an Error if a PractitionerBox can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PractitionerBox to fetch.
     * 
    **/
    where: PractitionerBoxWhereUniqueInput
  }


  /**
   * PractitionerBox findFirst
   */
  export type PractitionerBoxFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBox
     * 
    **/
    select?: PractitionerBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerBoxInclude | null
    /**
     * Throw an Error if a PractitionerBox can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PractitionerBox to fetch.
     * 
    **/
    where?: PractitionerBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerBoxes to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerBoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PractitionerBoxes.
     * 
    **/
    cursor?: PractitionerBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerBoxes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerBoxes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PractitionerBoxes.
     * 
    **/
    distinct?: Enumerable<PractitionerBoxScalarFieldEnum>
  }


  /**
   * PractitionerBox findMany
   */
  export type PractitionerBoxFindManyArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBox
     * 
    **/
    select?: PractitionerBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerBoxInclude | null
    /**
     * Filter, which PractitionerBoxes to fetch.
     * 
    **/
    where?: PractitionerBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerBoxes to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerBoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PractitionerBoxes.
     * 
    **/
    cursor?: PractitionerBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerBoxes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerBoxes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PractitionerBoxScalarFieldEnum>
  }


  /**
   * PractitionerBox create
   */
  export type PractitionerBoxCreateArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBox
     * 
    **/
    select?: PractitionerBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerBoxInclude | null
    /**
     * The data needed to create a PractitionerBox.
     * 
    **/
    data: XOR<PractitionerBoxCreateInput, PractitionerBoxUncheckedCreateInput>
  }


  /**
   * PractitionerBox createMany
   */
  export type PractitionerBoxCreateManyArgs = {
    data: Enumerable<PractitionerBoxCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PractitionerBox update
   */
  export type PractitionerBoxUpdateArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBox
     * 
    **/
    select?: PractitionerBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerBoxInclude | null
    /**
     * The data needed to update a PractitionerBox.
     * 
    **/
    data: XOR<PractitionerBoxUpdateInput, PractitionerBoxUncheckedUpdateInput>
    /**
     * Choose, which PractitionerBox to update.
     * 
    **/
    where: PractitionerBoxWhereUniqueInput
  }


  /**
   * PractitionerBox updateMany
   */
  export type PractitionerBoxUpdateManyArgs = {
    data: XOR<PractitionerBoxUpdateManyMutationInput, PractitionerBoxUncheckedUpdateManyInput>
    where?: PractitionerBoxWhereInput
  }


  /**
   * PractitionerBox upsert
   */
  export type PractitionerBoxUpsertArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBox
     * 
    **/
    select?: PractitionerBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerBoxInclude | null
    /**
     * The filter to search for the PractitionerBox to update in case it exists.
     * 
    **/
    where: PractitionerBoxWhereUniqueInput
    /**
     * In case the PractitionerBox found by the `where` argument doesn't exist, create a new PractitionerBox with this data.
     * 
    **/
    create: XOR<PractitionerBoxCreateInput, PractitionerBoxUncheckedCreateInput>
    /**
     * In case the PractitionerBox was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PractitionerBoxUpdateInput, PractitionerBoxUncheckedUpdateInput>
  }


  /**
   * PractitionerBox delete
   */
  export type PractitionerBoxDeleteArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBox
     * 
    **/
    select?: PractitionerBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerBoxInclude | null
    /**
     * Filter which PractitionerBox to delete.
     * 
    **/
    where: PractitionerBoxWhereUniqueInput
  }


  /**
   * PractitionerBox deleteMany
   */
  export type PractitionerBoxDeleteManyArgs = {
    where?: PractitionerBoxWhereInput
  }


  /**
   * PractitionerBox without action
   */
  export type PractitionerBoxArgs = {
    /**
     * Select specific fields to fetch from the PractitionerBox
     * 
    **/
    select?: PractitionerBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerBoxInclude | null
  }



  /**
   * Model IntermediatePractitionerBoxProduct
   */


  export type AggregateIntermediatePractitionerBoxProduct = {
    _count: IntermediatePractitionerBoxProductCountAggregateOutputType | null
    _avg: IntermediatePractitionerBoxProductAvgAggregateOutputType | null
    _sum: IntermediatePractitionerBoxProductSumAggregateOutputType | null
    _min: IntermediatePractitionerBoxProductMinAggregateOutputType | null
    _max: IntermediatePractitionerBoxProductMaxAggregateOutputType | null
  }

  export type IntermediatePractitionerBoxProductAvgAggregateOutputType = {
    practitionerBoxId: number | null
    productId: number | null
  }

  export type IntermediatePractitionerBoxProductSumAggregateOutputType = {
    practitionerBoxId: number | null
    productId: number | null
  }

  export type IntermediatePractitionerBoxProductMinAggregateOutputType = {
    practitionerBoxId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediatePractitionerBoxProductMaxAggregateOutputType = {
    practitionerBoxId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntermediatePractitionerBoxProductCountAggregateOutputType = {
    practitionerBoxId: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntermediatePractitionerBoxProductAvgAggregateInputType = {
    practitionerBoxId?: true
    productId?: true
  }

  export type IntermediatePractitionerBoxProductSumAggregateInputType = {
    practitionerBoxId?: true
    productId?: true
  }

  export type IntermediatePractitionerBoxProductMinAggregateInputType = {
    practitionerBoxId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediatePractitionerBoxProductMaxAggregateInputType = {
    practitionerBoxId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntermediatePractitionerBoxProductCountAggregateInputType = {
    practitionerBoxId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntermediatePractitionerBoxProductAggregateArgs = {
    /**
     * Filter which IntermediatePractitionerBoxProduct to aggregate.
     * 
    **/
    where?: IntermediatePractitionerBoxProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediatePractitionerBoxProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediatePractitionerBoxProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IntermediatePractitionerBoxProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediatePractitionerBoxProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediatePractitionerBoxProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntermediatePractitionerBoxProducts
    **/
    _count?: true | IntermediatePractitionerBoxProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntermediatePractitionerBoxProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntermediatePractitionerBoxProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntermediatePractitionerBoxProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntermediatePractitionerBoxProductMaxAggregateInputType
  }

  export type GetIntermediatePractitionerBoxProductAggregateType<T extends IntermediatePractitionerBoxProductAggregateArgs> = {
        [P in keyof T & keyof AggregateIntermediatePractitionerBoxProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntermediatePractitionerBoxProduct[P]>
      : GetScalarType<T[P], AggregateIntermediatePractitionerBoxProduct[P]>
  }




  export type IntermediatePractitionerBoxProductGroupByArgs = {
    where?: IntermediatePractitionerBoxProductWhereInput
    orderBy?: Enumerable<IntermediatePractitionerBoxProductOrderByWithAggregationInput>
    by: Array<IntermediatePractitionerBoxProductScalarFieldEnum>
    having?: IntermediatePractitionerBoxProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntermediatePractitionerBoxProductCountAggregateInputType | true
    _avg?: IntermediatePractitionerBoxProductAvgAggregateInputType
    _sum?: IntermediatePractitionerBoxProductSumAggregateInputType
    _min?: IntermediatePractitionerBoxProductMinAggregateInputType
    _max?: IntermediatePractitionerBoxProductMaxAggregateInputType
  }


  export type IntermediatePractitionerBoxProductGroupByOutputType = {
    practitionerBoxId: number
    productId: number
    createdAt: Date
    updatedAt: Date
    _count: IntermediatePractitionerBoxProductCountAggregateOutputType | null
    _avg: IntermediatePractitionerBoxProductAvgAggregateOutputType | null
    _sum: IntermediatePractitionerBoxProductSumAggregateOutputType | null
    _min: IntermediatePractitionerBoxProductMinAggregateOutputType | null
    _max: IntermediatePractitionerBoxProductMaxAggregateOutputType | null
  }

  type GetIntermediatePractitionerBoxProductGroupByPayload<T extends IntermediatePractitionerBoxProductGroupByArgs> = Promise<
    Array<
      PickArray<IntermediatePractitionerBoxProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntermediatePractitionerBoxProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntermediatePractitionerBoxProductGroupByOutputType[P]>
            : GetScalarType<T[P], IntermediatePractitionerBoxProductGroupByOutputType[P]>
        }
      >
    >


  export type IntermediatePractitionerBoxProductSelect = {
    practitionerBox?: boolean | PractitionerBoxArgs
    practitionerBoxId?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntermediatePractitionerBoxProductInclude = {
    practitionerBox?: boolean | PractitionerBoxArgs
    product?: boolean | ProductArgs
  }

  export type IntermediatePractitionerBoxProductGetPayload<
    S extends boolean | null | undefined | IntermediatePractitionerBoxProductArgs,
    U = keyof S
      > = S extends true
        ? IntermediatePractitionerBoxProduct
    : S extends undefined
    ? never
    : S extends IntermediatePractitionerBoxProductArgs | IntermediatePractitionerBoxProductFindManyArgs
    ?'include' extends U
    ? IntermediatePractitionerBoxProduct  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'practitionerBox'
        ? PractitionerBoxGetPayload<S['include'][P]> :
        P extends 'product'
        ? ProductGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IntermediatePractitionerBoxProduct ?IntermediatePractitionerBoxProduct [P]
  : 
          P extends 'practitionerBox'
        ? PractitionerBoxGetPayload<S['select'][P]> :
        P extends 'product'
        ? ProductGetPayload<S['select'][P]> : never
  } 
    : IntermediatePractitionerBoxProduct
  : IntermediatePractitionerBoxProduct


  type IntermediatePractitionerBoxProductCountArgs = Merge<
    Omit<IntermediatePractitionerBoxProductFindManyArgs, 'select' | 'include'> & {
      select?: IntermediatePractitionerBoxProductCountAggregateInputType | true
    }
  >

  export interface IntermediatePractitionerBoxProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one IntermediatePractitionerBoxProduct that matches the filter.
     * @param {IntermediatePractitionerBoxProductFindUniqueArgs} args - Arguments to find a IntermediatePractitionerBoxProduct
     * @example
     * // Get one IntermediatePractitionerBoxProduct
     * const intermediatePractitionerBoxProduct = await prisma.intermediatePractitionerBoxProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IntermediatePractitionerBoxProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IntermediatePractitionerBoxProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'IntermediatePractitionerBoxProduct'> extends True ? CheckSelect<T, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProduct>, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProductGetPayload<T>>> : CheckSelect<T, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProduct | null >, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProductGetPayload<T> | null >>

    /**
     * Find the first IntermediatePractitionerBoxProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediatePractitionerBoxProductFindFirstArgs} args - Arguments to find a IntermediatePractitionerBoxProduct
     * @example
     * // Get one IntermediatePractitionerBoxProduct
     * const intermediatePractitionerBoxProduct = await prisma.intermediatePractitionerBoxProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IntermediatePractitionerBoxProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IntermediatePractitionerBoxProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'IntermediatePractitionerBoxProduct'> extends True ? CheckSelect<T, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProduct>, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProductGetPayload<T>>> : CheckSelect<T, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProduct | null >, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProductGetPayload<T> | null >>

    /**
     * Find zero or more IntermediatePractitionerBoxProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediatePractitionerBoxProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntermediatePractitionerBoxProducts
     * const intermediatePractitionerBoxProducts = await prisma.intermediatePractitionerBoxProduct.findMany()
     * 
     * // Get first 10 IntermediatePractitionerBoxProducts
     * const intermediatePractitionerBoxProducts = await prisma.intermediatePractitionerBoxProduct.findMany({ take: 10 })
     * 
     * // Only select the `practitionerBoxId`
     * const intermediatePractitionerBoxProductWithPractitionerBoxIdOnly = await prisma.intermediatePractitionerBoxProduct.findMany({ select: { practitionerBoxId: true } })
     * 
    **/
    findMany<T extends IntermediatePractitionerBoxProductFindManyArgs>(
      args?: SelectSubset<T, IntermediatePractitionerBoxProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<IntermediatePractitionerBoxProduct>>, PrismaPromise<Array<IntermediatePractitionerBoxProductGetPayload<T>>>>

    /**
     * Create a IntermediatePractitionerBoxProduct.
     * @param {IntermediatePractitionerBoxProductCreateArgs} args - Arguments to create a IntermediatePractitionerBoxProduct.
     * @example
     * // Create one IntermediatePractitionerBoxProduct
     * const IntermediatePractitionerBoxProduct = await prisma.intermediatePractitionerBoxProduct.create({
     *   data: {
     *     // ... data to create a IntermediatePractitionerBoxProduct
     *   }
     * })
     * 
    **/
    create<T extends IntermediatePractitionerBoxProductCreateArgs>(
      args: SelectSubset<T, IntermediatePractitionerBoxProductCreateArgs>
    ): CheckSelect<T, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProduct>, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProductGetPayload<T>>>

    /**
     * Create many IntermediatePractitionerBoxProducts.
     *     @param {IntermediatePractitionerBoxProductCreateManyArgs} args - Arguments to create many IntermediatePractitionerBoxProducts.
     *     @example
     *     // Create many IntermediatePractitionerBoxProducts
     *     const intermediatePractitionerBoxProduct = await prisma.intermediatePractitionerBoxProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IntermediatePractitionerBoxProductCreateManyArgs>(
      args?: SelectSubset<T, IntermediatePractitionerBoxProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a IntermediatePractitionerBoxProduct.
     * @param {IntermediatePractitionerBoxProductDeleteArgs} args - Arguments to delete one IntermediatePractitionerBoxProduct.
     * @example
     * // Delete one IntermediatePractitionerBoxProduct
     * const IntermediatePractitionerBoxProduct = await prisma.intermediatePractitionerBoxProduct.delete({
     *   where: {
     *     // ... filter to delete one IntermediatePractitionerBoxProduct
     *   }
     * })
     * 
    **/
    delete<T extends IntermediatePractitionerBoxProductDeleteArgs>(
      args: SelectSubset<T, IntermediatePractitionerBoxProductDeleteArgs>
    ): CheckSelect<T, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProduct>, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProductGetPayload<T>>>

    /**
     * Update one IntermediatePractitionerBoxProduct.
     * @param {IntermediatePractitionerBoxProductUpdateArgs} args - Arguments to update one IntermediatePractitionerBoxProduct.
     * @example
     * // Update one IntermediatePractitionerBoxProduct
     * const intermediatePractitionerBoxProduct = await prisma.intermediatePractitionerBoxProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IntermediatePractitionerBoxProductUpdateArgs>(
      args: SelectSubset<T, IntermediatePractitionerBoxProductUpdateArgs>
    ): CheckSelect<T, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProduct>, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProductGetPayload<T>>>

    /**
     * Delete zero or more IntermediatePractitionerBoxProducts.
     * @param {IntermediatePractitionerBoxProductDeleteManyArgs} args - Arguments to filter IntermediatePractitionerBoxProducts to delete.
     * @example
     * // Delete a few IntermediatePractitionerBoxProducts
     * const { count } = await prisma.intermediatePractitionerBoxProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IntermediatePractitionerBoxProductDeleteManyArgs>(
      args?: SelectSubset<T, IntermediatePractitionerBoxProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntermediatePractitionerBoxProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediatePractitionerBoxProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntermediatePractitionerBoxProducts
     * const intermediatePractitionerBoxProduct = await prisma.intermediatePractitionerBoxProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IntermediatePractitionerBoxProductUpdateManyArgs>(
      args: SelectSubset<T, IntermediatePractitionerBoxProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one IntermediatePractitionerBoxProduct.
     * @param {IntermediatePractitionerBoxProductUpsertArgs} args - Arguments to update or create a IntermediatePractitionerBoxProduct.
     * @example
     * // Update or create a IntermediatePractitionerBoxProduct
     * const intermediatePractitionerBoxProduct = await prisma.intermediatePractitionerBoxProduct.upsert({
     *   create: {
     *     // ... data to create a IntermediatePractitionerBoxProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntermediatePractitionerBoxProduct we want to update
     *   }
     * })
    **/
    upsert<T extends IntermediatePractitionerBoxProductUpsertArgs>(
      args: SelectSubset<T, IntermediatePractitionerBoxProductUpsertArgs>
    ): CheckSelect<T, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProduct>, Prisma__IntermediatePractitionerBoxProductClient<IntermediatePractitionerBoxProductGetPayload<T>>>

    /**
     * Count the number of IntermediatePractitionerBoxProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediatePractitionerBoxProductCountArgs} args - Arguments to filter IntermediatePractitionerBoxProducts to count.
     * @example
     * // Count the number of IntermediatePractitionerBoxProducts
     * const count = await prisma.intermediatePractitionerBoxProduct.count({
     *   where: {
     *     // ... the filter for the IntermediatePractitionerBoxProducts we want to count
     *   }
     * })
    **/
    count<T extends IntermediatePractitionerBoxProductCountArgs>(
      args?: Subset<T, IntermediatePractitionerBoxProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntermediatePractitionerBoxProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntermediatePractitionerBoxProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediatePractitionerBoxProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntermediatePractitionerBoxProductAggregateArgs>(args: Subset<T, IntermediatePractitionerBoxProductAggregateArgs>): PrismaPromise<GetIntermediatePractitionerBoxProductAggregateType<T>>

    /**
     * Group by IntermediatePractitionerBoxProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntermediatePractitionerBoxProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntermediatePractitionerBoxProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntermediatePractitionerBoxProductGroupByArgs['orderBy'] }
        : { orderBy?: IntermediatePractitionerBoxProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntermediatePractitionerBoxProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntermediatePractitionerBoxProductGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntermediatePractitionerBoxProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IntermediatePractitionerBoxProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    practitionerBox<T extends PractitionerBoxArgs = {}>(args?: Subset<T, PractitionerBoxArgs>): CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox | null >, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IntermediatePractitionerBoxProduct findUnique
   */
  export type IntermediatePractitionerBoxProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IntermediatePractitionerBoxProduct
     * 
    **/
    select?: IntermediatePractitionerBoxProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediatePractitionerBoxProductInclude | null
    /**
     * Throw an Error if a IntermediatePractitionerBoxProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediatePractitionerBoxProduct to fetch.
     * 
    **/
    where: IntermediatePractitionerBoxProductWhereUniqueInput
  }


  /**
   * IntermediatePractitionerBoxProduct findFirst
   */
  export type IntermediatePractitionerBoxProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IntermediatePractitionerBoxProduct
     * 
    **/
    select?: IntermediatePractitionerBoxProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediatePractitionerBoxProductInclude | null
    /**
     * Throw an Error if a IntermediatePractitionerBoxProduct can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IntermediatePractitionerBoxProduct to fetch.
     * 
    **/
    where?: IntermediatePractitionerBoxProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediatePractitionerBoxProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediatePractitionerBoxProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntermediatePractitionerBoxProducts.
     * 
    **/
    cursor?: IntermediatePractitionerBoxProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediatePractitionerBoxProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediatePractitionerBoxProducts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntermediatePractitionerBoxProducts.
     * 
    **/
    distinct?: Enumerable<IntermediatePractitionerBoxProductScalarFieldEnum>
  }


  /**
   * IntermediatePractitionerBoxProduct findMany
   */
  export type IntermediatePractitionerBoxProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the IntermediatePractitionerBoxProduct
     * 
    **/
    select?: IntermediatePractitionerBoxProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediatePractitionerBoxProductInclude | null
    /**
     * Filter, which IntermediatePractitionerBoxProducts to fetch.
     * 
    **/
    where?: IntermediatePractitionerBoxProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntermediatePractitionerBoxProducts to fetch.
     * 
    **/
    orderBy?: Enumerable<IntermediatePractitionerBoxProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntermediatePractitionerBoxProducts.
     * 
    **/
    cursor?: IntermediatePractitionerBoxProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntermediatePractitionerBoxProducts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntermediatePractitionerBoxProducts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IntermediatePractitionerBoxProductScalarFieldEnum>
  }


  /**
   * IntermediatePractitionerBoxProduct create
   */
  export type IntermediatePractitionerBoxProductCreateArgs = {
    /**
     * Select specific fields to fetch from the IntermediatePractitionerBoxProduct
     * 
    **/
    select?: IntermediatePractitionerBoxProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediatePractitionerBoxProductInclude | null
    /**
     * The data needed to create a IntermediatePractitionerBoxProduct.
     * 
    **/
    data: XOR<IntermediatePractitionerBoxProductCreateInput, IntermediatePractitionerBoxProductUncheckedCreateInput>
  }


  /**
   * IntermediatePractitionerBoxProduct createMany
   */
  export type IntermediatePractitionerBoxProductCreateManyArgs = {
    data: Enumerable<IntermediatePractitionerBoxProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * IntermediatePractitionerBoxProduct update
   */
  export type IntermediatePractitionerBoxProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the IntermediatePractitionerBoxProduct
     * 
    **/
    select?: IntermediatePractitionerBoxProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediatePractitionerBoxProductInclude | null
    /**
     * The data needed to update a IntermediatePractitionerBoxProduct.
     * 
    **/
    data: XOR<IntermediatePractitionerBoxProductUpdateInput, IntermediatePractitionerBoxProductUncheckedUpdateInput>
    /**
     * Choose, which IntermediatePractitionerBoxProduct to update.
     * 
    **/
    where: IntermediatePractitionerBoxProductWhereUniqueInput
  }


  /**
   * IntermediatePractitionerBoxProduct updateMany
   */
  export type IntermediatePractitionerBoxProductUpdateManyArgs = {
    data: XOR<IntermediatePractitionerBoxProductUpdateManyMutationInput, IntermediatePractitionerBoxProductUncheckedUpdateManyInput>
    where?: IntermediatePractitionerBoxProductWhereInput
  }


  /**
   * IntermediatePractitionerBoxProduct upsert
   */
  export type IntermediatePractitionerBoxProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the IntermediatePractitionerBoxProduct
     * 
    **/
    select?: IntermediatePractitionerBoxProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediatePractitionerBoxProductInclude | null
    /**
     * The filter to search for the IntermediatePractitionerBoxProduct to update in case it exists.
     * 
    **/
    where: IntermediatePractitionerBoxProductWhereUniqueInput
    /**
     * In case the IntermediatePractitionerBoxProduct found by the `where` argument doesn't exist, create a new IntermediatePractitionerBoxProduct with this data.
     * 
    **/
    create: XOR<IntermediatePractitionerBoxProductCreateInput, IntermediatePractitionerBoxProductUncheckedCreateInput>
    /**
     * In case the IntermediatePractitionerBoxProduct was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IntermediatePractitionerBoxProductUpdateInput, IntermediatePractitionerBoxProductUncheckedUpdateInput>
  }


  /**
   * IntermediatePractitionerBoxProduct delete
   */
  export type IntermediatePractitionerBoxProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the IntermediatePractitionerBoxProduct
     * 
    **/
    select?: IntermediatePractitionerBoxProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediatePractitionerBoxProductInclude | null
    /**
     * Filter which IntermediatePractitionerBoxProduct to delete.
     * 
    **/
    where: IntermediatePractitionerBoxProductWhereUniqueInput
  }


  /**
   * IntermediatePractitionerBoxProduct deleteMany
   */
  export type IntermediatePractitionerBoxProductDeleteManyArgs = {
    where?: IntermediatePractitionerBoxProductWhereInput
  }


  /**
   * IntermediatePractitionerBoxProduct without action
   */
  export type IntermediatePractitionerBoxProductArgs = {
    /**
     * Select specific fields to fetch from the IntermediatePractitionerBoxProduct
     * 
    **/
    select?: IntermediatePractitionerBoxProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IntermediatePractitionerBoxProductInclude | null
  }



  /**
   * Model PractitionerCustomerOrderHistory
   */


  export type AggregatePractitionerCustomerOrderHistory = {
    _count: PractitionerCustomerOrderHistoryCountAggregateOutputType | null
    _avg: PractitionerCustomerOrderHistoryAvgAggregateOutputType | null
    _sum: PractitionerCustomerOrderHistorySumAggregateOutputType | null
    _min: PractitionerCustomerOrderHistoryMinAggregateOutputType | null
    _max: PractitionerCustomerOrderHistoryMaxAggregateOutputType | null
  }

  export type PractitionerCustomerOrderHistoryAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    practitionerBoxId: number | null
    purchasePrice: number | null
  }

  export type PractitionerCustomerOrderHistorySumAggregateOutputType = {
    id: number | null
    customerId: number | null
    practitionerBoxId: number | null
    purchasePrice: number | null
  }

  export type PractitionerCustomerOrderHistoryMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    practitionerBoxId: number | null
    orderNumber: string | null
    purchasePrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PractitionerCustomerOrderHistoryMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    practitionerBoxId: number | null
    orderNumber: string | null
    purchasePrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PractitionerCustomerOrderHistoryCountAggregateOutputType = {
    id: number
    customerId: number
    practitionerBoxId: number
    orderNumber: number
    purchasePrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PractitionerCustomerOrderHistoryAvgAggregateInputType = {
    id?: true
    customerId?: true
    practitionerBoxId?: true
    purchasePrice?: true
  }

  export type PractitionerCustomerOrderHistorySumAggregateInputType = {
    id?: true
    customerId?: true
    practitionerBoxId?: true
    purchasePrice?: true
  }

  export type PractitionerCustomerOrderHistoryMinAggregateInputType = {
    id?: true
    customerId?: true
    practitionerBoxId?: true
    orderNumber?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PractitionerCustomerOrderHistoryMaxAggregateInputType = {
    id?: true
    customerId?: true
    practitionerBoxId?: true
    orderNumber?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PractitionerCustomerOrderHistoryCountAggregateInputType = {
    id?: true
    customerId?: true
    practitionerBoxId?: true
    orderNumber?: true
    purchasePrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PractitionerCustomerOrderHistoryAggregateArgs = {
    /**
     * Filter which PractitionerCustomerOrderHistory to aggregate.
     * 
    **/
    where?: PractitionerCustomerOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerCustomerOrderHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerCustomerOrderHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PractitionerCustomerOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerCustomerOrderHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerCustomerOrderHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PractitionerCustomerOrderHistories
    **/
    _count?: true | PractitionerCustomerOrderHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PractitionerCustomerOrderHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PractitionerCustomerOrderHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PractitionerCustomerOrderHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PractitionerCustomerOrderHistoryMaxAggregateInputType
  }

  export type GetPractitionerCustomerOrderHistoryAggregateType<T extends PractitionerCustomerOrderHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePractitionerCustomerOrderHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePractitionerCustomerOrderHistory[P]>
      : GetScalarType<T[P], AggregatePractitionerCustomerOrderHistory[P]>
  }




  export type PractitionerCustomerOrderHistoryGroupByArgs = {
    where?: PractitionerCustomerOrderHistoryWhereInput
    orderBy?: Enumerable<PractitionerCustomerOrderHistoryOrderByWithAggregationInput>
    by: Array<PractitionerCustomerOrderHistoryScalarFieldEnum>
    having?: PractitionerCustomerOrderHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PractitionerCustomerOrderHistoryCountAggregateInputType | true
    _avg?: PractitionerCustomerOrderHistoryAvgAggregateInputType
    _sum?: PractitionerCustomerOrderHistorySumAggregateInputType
    _min?: PractitionerCustomerOrderHistoryMinAggregateInputType
    _max?: PractitionerCustomerOrderHistoryMaxAggregateInputType
  }


  export type PractitionerCustomerOrderHistoryGroupByOutputType = {
    id: number
    customerId: number
    practitionerBoxId: number
    orderNumber: string
    purchasePrice: number
    createdAt: Date
    updatedAt: Date
    _count: PractitionerCustomerOrderHistoryCountAggregateOutputType | null
    _avg: PractitionerCustomerOrderHistoryAvgAggregateOutputType | null
    _sum: PractitionerCustomerOrderHistorySumAggregateOutputType | null
    _min: PractitionerCustomerOrderHistoryMinAggregateOutputType | null
    _max: PractitionerCustomerOrderHistoryMaxAggregateOutputType | null
  }

  type GetPractitionerCustomerOrderHistoryGroupByPayload<T extends PractitionerCustomerOrderHistoryGroupByArgs> = Promise<
    Array<
      PickArray<PractitionerCustomerOrderHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PractitionerCustomerOrderHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PractitionerCustomerOrderHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PractitionerCustomerOrderHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PractitionerCustomerOrderHistorySelect = {
    id?: boolean
    customer?: boolean | CustomersArgs
    customerId?: boolean
    practitionerBox?: boolean | PractitionerBoxArgs
    practitionerBoxId?: boolean
    orderNumber?: boolean
    purchasePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PractitionerCustomerOrderHistoryInclude = {
    customer?: boolean | CustomersArgs
    practitionerBox?: boolean | PractitionerBoxArgs
  }

  export type PractitionerCustomerOrderHistoryGetPayload<
    S extends boolean | null | undefined | PractitionerCustomerOrderHistoryArgs,
    U = keyof S
      > = S extends true
        ? PractitionerCustomerOrderHistory
    : S extends undefined
    ? never
    : S extends PractitionerCustomerOrderHistoryArgs | PractitionerCustomerOrderHistoryFindManyArgs
    ?'include' extends U
    ? PractitionerCustomerOrderHistory  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'customer'
        ? CustomersGetPayload<S['include'][P]> :
        P extends 'practitionerBox'
        ? PractitionerBoxGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PractitionerCustomerOrderHistory ?PractitionerCustomerOrderHistory [P]
  : 
          P extends 'customer'
        ? CustomersGetPayload<S['select'][P]> :
        P extends 'practitionerBox'
        ? PractitionerBoxGetPayload<S['select'][P]> : never
  } 
    : PractitionerCustomerOrderHistory
  : PractitionerCustomerOrderHistory


  type PractitionerCustomerOrderHistoryCountArgs = Merge<
    Omit<PractitionerCustomerOrderHistoryFindManyArgs, 'select' | 'include'> & {
      select?: PractitionerCustomerOrderHistoryCountAggregateInputType | true
    }
  >

  export interface PractitionerCustomerOrderHistoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PractitionerCustomerOrderHistory that matches the filter.
     * @param {PractitionerCustomerOrderHistoryFindUniqueArgs} args - Arguments to find a PractitionerCustomerOrderHistory
     * @example
     * // Get one PractitionerCustomerOrderHistory
     * const practitionerCustomerOrderHistory = await prisma.practitionerCustomerOrderHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PractitionerCustomerOrderHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PractitionerCustomerOrderHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PractitionerCustomerOrderHistory'> extends True ? CheckSelect<T, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistory>, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistoryGetPayload<T>>> : CheckSelect<T, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistory | null >, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistoryGetPayload<T> | null >>

    /**
     * Find the first PractitionerCustomerOrderHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerCustomerOrderHistoryFindFirstArgs} args - Arguments to find a PractitionerCustomerOrderHistory
     * @example
     * // Get one PractitionerCustomerOrderHistory
     * const practitionerCustomerOrderHistory = await prisma.practitionerCustomerOrderHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PractitionerCustomerOrderHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PractitionerCustomerOrderHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PractitionerCustomerOrderHistory'> extends True ? CheckSelect<T, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistory>, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistoryGetPayload<T>>> : CheckSelect<T, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistory | null >, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistoryGetPayload<T> | null >>

    /**
     * Find zero or more PractitionerCustomerOrderHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerCustomerOrderHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PractitionerCustomerOrderHistories
     * const practitionerCustomerOrderHistories = await prisma.practitionerCustomerOrderHistory.findMany()
     * 
     * // Get first 10 PractitionerCustomerOrderHistories
     * const practitionerCustomerOrderHistories = await prisma.practitionerCustomerOrderHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practitionerCustomerOrderHistoryWithIdOnly = await prisma.practitionerCustomerOrderHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PractitionerCustomerOrderHistoryFindManyArgs>(
      args?: SelectSubset<T, PractitionerCustomerOrderHistoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PractitionerCustomerOrderHistory>>, PrismaPromise<Array<PractitionerCustomerOrderHistoryGetPayload<T>>>>

    /**
     * Create a PractitionerCustomerOrderHistory.
     * @param {PractitionerCustomerOrderHistoryCreateArgs} args - Arguments to create a PractitionerCustomerOrderHistory.
     * @example
     * // Create one PractitionerCustomerOrderHistory
     * const PractitionerCustomerOrderHistory = await prisma.practitionerCustomerOrderHistory.create({
     *   data: {
     *     // ... data to create a PractitionerCustomerOrderHistory
     *   }
     * })
     * 
    **/
    create<T extends PractitionerCustomerOrderHistoryCreateArgs>(
      args: SelectSubset<T, PractitionerCustomerOrderHistoryCreateArgs>
    ): CheckSelect<T, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistory>, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistoryGetPayload<T>>>

    /**
     * Create many PractitionerCustomerOrderHistories.
     *     @param {PractitionerCustomerOrderHistoryCreateManyArgs} args - Arguments to create many PractitionerCustomerOrderHistories.
     *     @example
     *     // Create many PractitionerCustomerOrderHistories
     *     const practitionerCustomerOrderHistory = await prisma.practitionerCustomerOrderHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PractitionerCustomerOrderHistoryCreateManyArgs>(
      args?: SelectSubset<T, PractitionerCustomerOrderHistoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PractitionerCustomerOrderHistory.
     * @param {PractitionerCustomerOrderHistoryDeleteArgs} args - Arguments to delete one PractitionerCustomerOrderHistory.
     * @example
     * // Delete one PractitionerCustomerOrderHistory
     * const PractitionerCustomerOrderHistory = await prisma.practitionerCustomerOrderHistory.delete({
     *   where: {
     *     // ... filter to delete one PractitionerCustomerOrderHistory
     *   }
     * })
     * 
    **/
    delete<T extends PractitionerCustomerOrderHistoryDeleteArgs>(
      args: SelectSubset<T, PractitionerCustomerOrderHistoryDeleteArgs>
    ): CheckSelect<T, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistory>, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistoryGetPayload<T>>>

    /**
     * Update one PractitionerCustomerOrderHistory.
     * @param {PractitionerCustomerOrderHistoryUpdateArgs} args - Arguments to update one PractitionerCustomerOrderHistory.
     * @example
     * // Update one PractitionerCustomerOrderHistory
     * const practitionerCustomerOrderHistory = await prisma.practitionerCustomerOrderHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PractitionerCustomerOrderHistoryUpdateArgs>(
      args: SelectSubset<T, PractitionerCustomerOrderHistoryUpdateArgs>
    ): CheckSelect<T, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistory>, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistoryGetPayload<T>>>

    /**
     * Delete zero or more PractitionerCustomerOrderHistories.
     * @param {PractitionerCustomerOrderHistoryDeleteManyArgs} args - Arguments to filter PractitionerCustomerOrderHistories to delete.
     * @example
     * // Delete a few PractitionerCustomerOrderHistories
     * const { count } = await prisma.practitionerCustomerOrderHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PractitionerCustomerOrderHistoryDeleteManyArgs>(
      args?: SelectSubset<T, PractitionerCustomerOrderHistoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PractitionerCustomerOrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerCustomerOrderHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PractitionerCustomerOrderHistories
     * const practitionerCustomerOrderHistory = await prisma.practitionerCustomerOrderHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PractitionerCustomerOrderHistoryUpdateManyArgs>(
      args: SelectSubset<T, PractitionerCustomerOrderHistoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PractitionerCustomerOrderHistory.
     * @param {PractitionerCustomerOrderHistoryUpsertArgs} args - Arguments to update or create a PractitionerCustomerOrderHistory.
     * @example
     * // Update or create a PractitionerCustomerOrderHistory
     * const practitionerCustomerOrderHistory = await prisma.practitionerCustomerOrderHistory.upsert({
     *   create: {
     *     // ... data to create a PractitionerCustomerOrderHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PractitionerCustomerOrderHistory we want to update
     *   }
     * })
    **/
    upsert<T extends PractitionerCustomerOrderHistoryUpsertArgs>(
      args: SelectSubset<T, PractitionerCustomerOrderHistoryUpsertArgs>
    ): CheckSelect<T, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistory>, Prisma__PractitionerCustomerOrderHistoryClient<PractitionerCustomerOrderHistoryGetPayload<T>>>

    /**
     * Count the number of PractitionerCustomerOrderHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerCustomerOrderHistoryCountArgs} args - Arguments to filter PractitionerCustomerOrderHistories to count.
     * @example
     * // Count the number of PractitionerCustomerOrderHistories
     * const count = await prisma.practitionerCustomerOrderHistory.count({
     *   where: {
     *     // ... the filter for the PractitionerCustomerOrderHistories we want to count
     *   }
     * })
    **/
    count<T extends PractitionerCustomerOrderHistoryCountArgs>(
      args?: Subset<T, PractitionerCustomerOrderHistoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PractitionerCustomerOrderHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PractitionerCustomerOrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerCustomerOrderHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PractitionerCustomerOrderHistoryAggregateArgs>(args: Subset<T, PractitionerCustomerOrderHistoryAggregateArgs>): PrismaPromise<GetPractitionerCustomerOrderHistoryAggregateType<T>>

    /**
     * Group by PractitionerCustomerOrderHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PractitionerCustomerOrderHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PractitionerCustomerOrderHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PractitionerCustomerOrderHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PractitionerCustomerOrderHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PractitionerCustomerOrderHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPractitionerCustomerOrderHistoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PractitionerCustomerOrderHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PractitionerCustomerOrderHistoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    customer<T extends CustomersArgs = {}>(args?: Subset<T, CustomersArgs>): CheckSelect<T, Prisma__CustomersClient<Customers | null >, Prisma__CustomersClient<CustomersGetPayload<T> | null >>;

    practitionerBox<T extends PractitionerBoxArgs = {}>(args?: Subset<T, PractitionerBoxArgs>): CheckSelect<T, Prisma__PractitionerBoxClient<PractitionerBox | null >, Prisma__PractitionerBoxClient<PractitionerBoxGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PractitionerCustomerOrderHistory findUnique
   */
  export type PractitionerCustomerOrderHistoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCustomerOrderHistory
     * 
    **/
    select?: PractitionerCustomerOrderHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerCustomerOrderHistoryInclude | null
    /**
     * Throw an Error if a PractitionerCustomerOrderHistory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PractitionerCustomerOrderHistory to fetch.
     * 
    **/
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
  }


  /**
   * PractitionerCustomerOrderHistory findFirst
   */
  export type PractitionerCustomerOrderHistoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCustomerOrderHistory
     * 
    **/
    select?: PractitionerCustomerOrderHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerCustomerOrderHistoryInclude | null
    /**
     * Throw an Error if a PractitionerCustomerOrderHistory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PractitionerCustomerOrderHistory to fetch.
     * 
    **/
    where?: PractitionerCustomerOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerCustomerOrderHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerCustomerOrderHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PractitionerCustomerOrderHistories.
     * 
    **/
    cursor?: PractitionerCustomerOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerCustomerOrderHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerCustomerOrderHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PractitionerCustomerOrderHistories.
     * 
    **/
    distinct?: Enumerable<PractitionerCustomerOrderHistoryScalarFieldEnum>
  }


  /**
   * PractitionerCustomerOrderHistory findMany
   */
  export type PractitionerCustomerOrderHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCustomerOrderHistory
     * 
    **/
    select?: PractitionerCustomerOrderHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerCustomerOrderHistoryInclude | null
    /**
     * Filter, which PractitionerCustomerOrderHistories to fetch.
     * 
    **/
    where?: PractitionerCustomerOrderHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PractitionerCustomerOrderHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<PractitionerCustomerOrderHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PractitionerCustomerOrderHistories.
     * 
    **/
    cursor?: PractitionerCustomerOrderHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PractitionerCustomerOrderHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PractitionerCustomerOrderHistories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PractitionerCustomerOrderHistoryScalarFieldEnum>
  }


  /**
   * PractitionerCustomerOrderHistory create
   */
  export type PractitionerCustomerOrderHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCustomerOrderHistory
     * 
    **/
    select?: PractitionerCustomerOrderHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerCustomerOrderHistoryInclude | null
    /**
     * The data needed to create a PractitionerCustomerOrderHistory.
     * 
    **/
    data: XOR<PractitionerCustomerOrderHistoryCreateInput, PractitionerCustomerOrderHistoryUncheckedCreateInput>
  }


  /**
   * PractitionerCustomerOrderHistory createMany
   */
  export type PractitionerCustomerOrderHistoryCreateManyArgs = {
    data: Enumerable<PractitionerCustomerOrderHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PractitionerCustomerOrderHistory update
   */
  export type PractitionerCustomerOrderHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCustomerOrderHistory
     * 
    **/
    select?: PractitionerCustomerOrderHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerCustomerOrderHistoryInclude | null
    /**
     * The data needed to update a PractitionerCustomerOrderHistory.
     * 
    **/
    data: XOR<PractitionerCustomerOrderHistoryUpdateInput, PractitionerCustomerOrderHistoryUncheckedUpdateInput>
    /**
     * Choose, which PractitionerCustomerOrderHistory to update.
     * 
    **/
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
  }


  /**
   * PractitionerCustomerOrderHistory updateMany
   */
  export type PractitionerCustomerOrderHistoryUpdateManyArgs = {
    data: XOR<PractitionerCustomerOrderHistoryUpdateManyMutationInput, PractitionerCustomerOrderHistoryUncheckedUpdateManyInput>
    where?: PractitionerCustomerOrderHistoryWhereInput
  }


  /**
   * PractitionerCustomerOrderHistory upsert
   */
  export type PractitionerCustomerOrderHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCustomerOrderHistory
     * 
    **/
    select?: PractitionerCustomerOrderHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerCustomerOrderHistoryInclude | null
    /**
     * The filter to search for the PractitionerCustomerOrderHistory to update in case it exists.
     * 
    **/
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
    /**
     * In case the PractitionerCustomerOrderHistory found by the `where` argument doesn't exist, create a new PractitionerCustomerOrderHistory with this data.
     * 
    **/
    create: XOR<PractitionerCustomerOrderHistoryCreateInput, PractitionerCustomerOrderHistoryUncheckedCreateInput>
    /**
     * In case the PractitionerCustomerOrderHistory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PractitionerCustomerOrderHistoryUpdateInput, PractitionerCustomerOrderHistoryUncheckedUpdateInput>
  }


  /**
   * PractitionerCustomerOrderHistory delete
   */
  export type PractitionerCustomerOrderHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCustomerOrderHistory
     * 
    **/
    select?: PractitionerCustomerOrderHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerCustomerOrderHistoryInclude | null
    /**
     * Filter which PractitionerCustomerOrderHistory to delete.
     * 
    **/
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
  }


  /**
   * PractitionerCustomerOrderHistory deleteMany
   */
  export type PractitionerCustomerOrderHistoryDeleteManyArgs = {
    where?: PractitionerCustomerOrderHistoryWhereInput
  }


  /**
   * PractitionerCustomerOrderHistory without action
   */
  export type PractitionerCustomerOrderHistoryArgs = {
    /**
     * Select specific fields to fetch from the PractitionerCustomerOrderHistory
     * 
    **/
    select?: PractitionerCustomerOrderHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PractitionerCustomerOrderHistoryInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const DiscoveriesScalarFieldEnum: {
    id: 'id',
    email: 'email',
    typeform_id: 'typeform_id',
    BMR: 'BMR',
    carbs_macronutrients: 'carbs_macronutrients',
    protein_macronutrients: 'protein_macronutrients',
    fat_macronutrients: 'fat_macronutrients',
    carbs_per_meal: 'carbs_per_meal',
    protein_per_meal: 'protein_per_meal',
    fat_per_meal: 'fat_per_meal',
    calorie_per_meal: 'calorie_per_meal'
  };

  export type DiscoveriesScalarFieldEnum = (typeof DiscoveriesScalarFieldEnum)[keyof typeof DiscoveriesScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    email: 'email',
    age: 'age',
    weightKg: 'weightKg',
    heightCm: 'heightCm',
    gender: 'gender',
    activeLevel: 'activeLevel',
    mealsPerDay: 'mealsPerDay',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const IntermediateCustomerNutritionNeedScalarFieldEnum: {
    customerNutritionNeedId: 'customerNutritionNeedId',
    customerId: 'customerId',
    nutritionValue: 'nutritionValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateCustomerNutritionNeedScalarFieldEnum = (typeof IntermediateCustomerNutritionNeedScalarFieldEnum)[keyof typeof IntermediateCustomerNutritionNeedScalarFieldEnum]


  export const CustomerNutritionNeedScalarFieldEnum: {
    id: 'id',
    name: 'name',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerNutritionNeedScalarFieldEnum = (typeof CustomerNutritionNeedScalarFieldEnum)[keyof typeof CustomerNutritionNeedScalarFieldEnum]


  export const IntermediateCustomerMedicalConditionScalarFieldEnum: {
    medicalConditionValue: 'medicalConditionValue',
    customerMedicalConditionId: 'customerMedicalConditionId',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateCustomerMedicalConditionScalarFieldEnum = (typeof IntermediateCustomerMedicalConditionScalarFieldEnum)[keyof typeof IntermediateCustomerMedicalConditionScalarFieldEnum]


  export const CustomerMedicalConditionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerMedicalConditionScalarFieldEnum = (typeof CustomerMedicalConditionScalarFieldEnum)[keyof typeof CustomerMedicalConditionScalarFieldEnum]


  export const IntermediateCustomerFoodTypeScalarFieldEnum: {
    productFoodTypeId: 'productFoodTypeId',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateCustomerFoodTypeScalarFieldEnum = (typeof IntermediateCustomerFoodTypeScalarFieldEnum)[keyof typeof IntermediateCustomerFoodTypeScalarFieldEnum]


  export const ProductFoodTypeScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductFoodTypeScalarFieldEnum = (typeof ProductFoodTypeScalarFieldEnum)[keyof typeof ProductFoodTypeScalarFieldEnum]


  export const IntermediateProductFoodTypeScalarFieldEnum: {
    productFoodTypeId: 'productFoodTypeId',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateProductFoodTypeScalarFieldEnum = (typeof IntermediateProductFoodTypeScalarFieldEnum)[keyof typeof IntermediateProductFoodTypeScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    activeStatus: 'activeStatus',
    name: 'name',
    label: 'label',
    ingredientLabel: 'ingredientLabel',
    allergenLabel: 'allergenLabel',
    expertComment: 'expertComment',
    productProviderId: 'productProviderId',
    productCategoryId: 'productCategoryId',
    productFlavorId: 'productFlavorId',
    productVendorId: 'productVendorId',
    externalSku: 'externalSku',
    upcCode: 'upcCode',
    MSP: 'MSP',
    WSP: 'WSP',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    src: 'src',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const IntermediateProductCookingMethodScalarFieldEnum: {
    productId: 'productId',
    productCookingMethodId: 'productCookingMethodId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateProductCookingMethodScalarFieldEnum = (typeof IntermediateProductCookingMethodScalarFieldEnum)[keyof typeof IntermediateProductCookingMethodScalarFieldEnum]


  export const IntermediateCustomerUnavailableCookingMethodScalarFieldEnum: {
    customerId: 'customerId',
    productCookingMethodId: 'productCookingMethodId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateCustomerUnavailableCookingMethodScalarFieldEnum = (typeof IntermediateCustomerUnavailableCookingMethodScalarFieldEnum)[keyof typeof IntermediateCustomerUnavailableCookingMethodScalarFieldEnum]


  export const ProductCookingMethodScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCookingMethodScalarFieldEnum = (typeof ProductCookingMethodScalarFieldEnum)[keyof typeof ProductCookingMethodScalarFieldEnum]


  export const ProductFlavorScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductFlavorScalarFieldEnum = (typeof ProductFlavorScalarFieldEnum)[keyof typeof ProductFlavorScalarFieldEnum]


  export const ProductVendorScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVendorScalarFieldEnum = (typeof ProductVendorScalarFieldEnum)[keyof typeof ProductVendorScalarFieldEnum]


  export const IntermediateCustomerFlavorDislikeScalarFieldEnum: {
    productFlavorId: 'productFlavorId',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateCustomerFlavorDislikeScalarFieldEnum = (typeof IntermediateCustomerFlavorDislikeScalarFieldEnum)[keyof typeof IntermediateCustomerFlavorDislikeScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    src: 'src',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const IntermediateCustomerCategoryPreferenceScalarFieldEnum: {
    productCategoryId: 'productCategoryId',
    customerId: 'customerId',
    rank: 'rank',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateCustomerCategoryPreferenceScalarFieldEnum = (typeof IntermediateCustomerCategoryPreferenceScalarFieldEnum)[keyof typeof IntermediateCustomerCategoryPreferenceScalarFieldEnum]


  export const IntermediateProductIngredientScalarFieldEnum: {
    productId: 'productId',
    productIngredientId: 'productIngredientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateProductIngredientScalarFieldEnum = (typeof IntermediateProductIngredientScalarFieldEnum)[keyof typeof IntermediateProductIngredientScalarFieldEnum]


  export const ProductIngredientScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductIngredientScalarFieldEnum = (typeof ProductIngredientScalarFieldEnum)[keyof typeof ProductIngredientScalarFieldEnum]


  export const IntermediateCustomerIngredientDislikeScalarFieldEnum: {
    productIngredientId: 'productIngredientId',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateCustomerIngredientDislikeScalarFieldEnum = (typeof IntermediateCustomerIngredientDislikeScalarFieldEnum)[keyof typeof IntermediateCustomerIngredientDislikeScalarFieldEnum]


  export const IntermediateProductAllergenScalarFieldEnum: {
    productId: 'productId',
    productAllergenId: 'productAllergenId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateProductAllergenScalarFieldEnum = (typeof IntermediateProductAllergenScalarFieldEnum)[keyof typeof IntermediateProductAllergenScalarFieldEnum]


  export const ProductAllergenScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductAllergenScalarFieldEnum = (typeof ProductAllergenScalarFieldEnum)[keyof typeof ProductAllergenScalarFieldEnum]


  export const IntermediateCustomerAllergenScalarFieldEnum: {
    customerId: 'customerId',
    productAllergenId: 'productAllergenId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateCustomerAllergenScalarFieldEnum = (typeof IntermediateCustomerAllergenScalarFieldEnum)[keyof typeof IntermediateCustomerAllergenScalarFieldEnum]


  export const ProductNutritionFactScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    quantity: 'quantity',
    servingSize: 'servingSize',
    calories: 'calories',
    totalFatG: 'totalFatG',
    saturatedFatG: 'saturatedFatG',
    transFatG: 'transFatG',
    cholesteroleMg: 'cholesteroleMg',
    sodiumMg: 'sodiumMg',
    totalCarbohydrateG: 'totalCarbohydrateG',
    dietaryFiberG: 'dietaryFiberG',
    totalSugarG: 'totalSugarG',
    addedSugarG: 'addedSugarG',
    proteinG: 'proteinG',
    sweet: 'sweet',
    sour: 'sour',
    salty: 'salty',
    bitter: 'bitter',
    spicy: 'spicy',
    texture: 'texture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductNutritionFactScalarFieldEnum = (typeof ProductNutritionFactScalarFieldEnum)[keyof typeof ProductNutritionFactScalarFieldEnum]


  export const ProductProviderScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductProviderScalarFieldEnum = (typeof ProductProviderScalarFieldEnum)[keyof typeof ProductProviderScalarFieldEnum]


  export const SurveyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyScalarFieldEnum = (typeof SurveyScalarFieldEnum)[keyof typeof SurveyScalarFieldEnum]


  export const IntermediateSurveyQuestionScalarFieldEnum: {
    surveyId: 'surveyId',
    displayOrder: 'displayOrder',
    surveyQuestionId: 'surveyQuestionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateSurveyQuestionScalarFieldEnum = (typeof IntermediateSurveyQuestionScalarFieldEnum)[keyof typeof IntermediateSurveyQuestionScalarFieldEnum]


  export const SurveyQuestionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    label: 'label',
    questionCategoryId: 'questionCategoryId',
    mustBeAnswered: 'mustBeAnswered',
    instruction: 'instruction',
    placeholder: 'placeholder',
    surveyQuestionAnswerTypeId: 'surveyQuestionAnswerTypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyQuestionScalarFieldEnum = (typeof SurveyQuestionScalarFieldEnum)[keyof typeof SurveyQuestionScalarFieldEnum]


  export const QuestionCategoryScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionCategoryScalarFieldEnum = (typeof QuestionCategoryScalarFieldEnum)[keyof typeof QuestionCategoryScalarFieldEnum]


  export const SurveyQuestionAnswerTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyQuestionAnswerTypeScalarFieldEnum = (typeof SurveyQuestionAnswerTypeScalarFieldEnum)[keyof typeof SurveyQuestionAnswerTypeScalarFieldEnum]


  export const SurveyQuestionOptionScalarFieldEnum: {
    id: 'id',
    label: 'label',
    name: 'name',
    surveyQuestionId: 'surveyQuestionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyQuestionOptionScalarFieldEnum = (typeof SurveyQuestionOptionScalarFieldEnum)[keyof typeof SurveyQuestionOptionScalarFieldEnum]


  export const SurveyQuestionAnswerScalarFieldEnum: {
    id: 'id',
    responseId: 'responseId',
    customerId: 'customerId',
    surveyQuestionId: 'surveyQuestionId',
    answerSingleOptionId: 'answerSingleOptionId',
    answerNumeric: 'answerNumeric',
    answerText: 'answerText',
    answerBool: 'answerBool',
    reason: 'reason',
    title: 'title',
    content: 'content',
    answerCount: 'answerCount',
    productId: 'productId',
    orderNumber: 'orderNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SurveyQuestionAnswerScalarFieldEnum = (typeof SurveyQuestionAnswerScalarFieldEnum)[keyof typeof SurveyQuestionAnswerScalarFieldEnum]


  export const IntermediateSurveyQuestionAnswerProductScalarFieldEnum: {
    surveyQuestionAnswerId: 'surveyQuestionAnswerId',
    surveyQuestionOptionId: 'surveyQuestionOptionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediateSurveyQuestionAnswerProductScalarFieldEnum = (typeof IntermediateSurveyQuestionAnswerProductScalarFieldEnum)[keyof typeof IntermediateSurveyQuestionAnswerProductScalarFieldEnum]


  export const CustomerProductDistanceScalarFieldEnum: {
    id: 'id',
    distance: 'distance',
    productId: 'productId',
    customerId: 'customerId',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerProductDistanceScalarFieldEnum = (typeof CustomerProductDistanceScalarFieldEnum)[keyof typeof CustomerProductDistanceScalarFieldEnum]


  export const CustomerBoxItemsScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerBoxItemsScalarFieldEnum = (typeof CustomerBoxItemsScalarFieldEnum)[keyof typeof CustomerBoxItemsScalarFieldEnum]


  export const QueuedShopifyOrderScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    orderName: 'orderName',
    status: 'status',
    scheduledAt: 'scheduledAt',
    orderedAt: 'orderedAt',
    fulfilledAt: 'fulfilledAt'
  };

  export type QueuedShopifyOrderScalarFieldEnum = (typeof QueuedShopifyOrderScalarFieldEnum)[keyof typeof QueuedShopifyOrderScalarFieldEnum]


  export const PractitionerScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    email: 'email',
    phoneNumber: 'phoneNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PractitionerScalarFieldEnum = (typeof PractitionerScalarFieldEnum)[keyof typeof PractitionerScalarFieldEnum]


  export const PractitionerSocialMediaScalarFieldEnum: {
    id: 'id',
    practitionerId: 'practitionerId',
    instagram: 'instagram',
    facebook: 'facebook',
    twitter: 'twitter',
    website: 'website',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PractitionerSocialMediaScalarFieldEnum = (typeof PractitionerSocialMediaScalarFieldEnum)[keyof typeof PractitionerSocialMediaScalarFieldEnum]


  export const PractitionerBoxScalarFieldEnum: {
    id: 'id',
    practitionerId: 'practitionerId',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PractitionerBoxScalarFieldEnum = (typeof PractitionerBoxScalarFieldEnum)[keyof typeof PractitionerBoxScalarFieldEnum]


  export const IntermediatePractitionerBoxProductScalarFieldEnum: {
    practitionerBoxId: 'practitionerBoxId',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntermediatePractitionerBoxProductScalarFieldEnum = (typeof IntermediatePractitionerBoxProductScalarFieldEnum)[keyof typeof IntermediatePractitionerBoxProductScalarFieldEnum]


  export const PractitionerCustomerOrderHistoryScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    practitionerBoxId: 'practitionerBoxId',
    orderNumber: 'orderNumber',
    purchasePrice: 'purchasePrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PractitionerCustomerOrderHistoryScalarFieldEnum = (typeof PractitionerCustomerOrderHistoryScalarFieldEnum)[keyof typeof PractitionerCustomerOrderHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type DiscoveriesWhereInput = {
    AND?: Enumerable<DiscoveriesWhereInput>
    OR?: Enumerable<DiscoveriesWhereInput>
    NOT?: Enumerable<DiscoveriesWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    typeform_id?: StringFilter | string
    BMR?: IntFilter | number
    carbs_macronutrients?: IntFilter | number
    protein_macronutrients?: IntFilter | number
    fat_macronutrients?: IntFilter | number
    carbs_per_meal?: IntFilter | number
    protein_per_meal?: IntFilter | number
    fat_per_meal?: IntFilter | number
    calorie_per_meal?: IntFilter | number
  }

  export type DiscoveriesOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    typeform_id?: SortOrder
    BMR?: SortOrder
    carbs_macronutrients?: SortOrder
    protein_macronutrients?: SortOrder
    fat_macronutrients?: SortOrder
    carbs_per_meal?: SortOrder
    protein_per_meal?: SortOrder
    fat_per_meal?: SortOrder
    calorie_per_meal?: SortOrder
  }

  export type DiscoveriesWhereUniqueInput = {
    id?: number
  }

  export type DiscoveriesOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    typeform_id?: SortOrder
    BMR?: SortOrder
    carbs_macronutrients?: SortOrder
    protein_macronutrients?: SortOrder
    fat_macronutrients?: SortOrder
    carbs_per_meal?: SortOrder
    protein_per_meal?: SortOrder
    fat_per_meal?: SortOrder
    calorie_per_meal?: SortOrder
    _count?: DiscoveriesCountOrderByAggregateInput
    _avg?: DiscoveriesAvgOrderByAggregateInput
    _max?: DiscoveriesMaxOrderByAggregateInput
    _min?: DiscoveriesMinOrderByAggregateInput
    _sum?: DiscoveriesSumOrderByAggregateInput
  }

  export type DiscoveriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DiscoveriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<DiscoveriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DiscoveriesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    typeform_id?: StringWithAggregatesFilter | string
    BMR?: IntWithAggregatesFilter | number
    carbs_macronutrients?: IntWithAggregatesFilter | number
    protein_macronutrients?: IntWithAggregatesFilter | number
    fat_macronutrients?: IntWithAggregatesFilter | number
    carbs_per_meal?: IntWithAggregatesFilter | number
    protein_per_meal?: IntWithAggregatesFilter | number
    fat_per_meal?: IntWithAggregatesFilter | number
    calorie_per_meal?: IntWithAggregatesFilter | number
  }

  export type CustomersWhereInput = {
    AND?: Enumerable<CustomersWhereInput>
    OR?: Enumerable<CustomersWhereInput>
    NOT?: Enumerable<CustomersWhereInput>
    id?: IntFilter | number
    uuid?: StringNullableFilter | string | null
    email?: StringFilter | string
    age?: IntNullableFilter | number | null
    weightKg?: FloatNullableFilter | number | null
    heightCm?: FloatNullableFilter | number | null
    gender?: StringNullableFilter | string | null
    activeLevel?: StringNullableFilter | string | null
    mealsPerDay?: IntNullableFilter | number | null
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedListRelationFilter
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionListRelationFilter
    intermediateCustomerAllergens?: IntermediateCustomerAllergenListRelationFilter
    surveyQuestionAnswer?: SurveyQuestionAnswerListRelationFilter
    customerProductDistances?: CustomerProductDistanceListRelationFilter
    customerBoxItems?: CustomerBoxItemsListRelationFilter
    queuedShopifyOrder?: QueuedShopifyOrderListRelationFilter
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeListRelationFilter
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceListRelationFilter
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeListRelationFilter
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeListRelationFilter
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodListRelationFilter
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomersOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    gender?: SortOrder
    activeLevel?: SortOrder
    mealsPerDay?: SortOrder
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedOrderByRelationAggregateInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionOrderByRelationAggregateInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenOrderByRelationAggregateInput
    surveyQuestionAnswer?: SurveyQuestionAnswerOrderByRelationAggregateInput
    customerProductDistances?: CustomerProductDistanceOrderByRelationAggregateInput
    customerBoxItems?: CustomerBoxItemsOrderByRelationAggregateInput
    queuedShopifyOrder?: QueuedShopifyOrderOrderByRelationAggregateInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeOrderByRelationAggregateInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceOrderByRelationAggregateInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeOrderByRelationAggregateInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeOrderByRelationAggregateInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodOrderByRelationAggregateInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersWhereUniqueInput = {
    id?: number
    uuid?: string
    email?: string
  }

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    gender?: SortOrder
    activeLevel?: SortOrder
    mealsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uuid?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    age?: IntNullableWithAggregatesFilter | number | null
    weightKg?: FloatNullableWithAggregatesFilter | number | null
    heightCm?: FloatNullableWithAggregatesFilter | number | null
    gender?: StringNullableWithAggregatesFilter | string | null
    activeLevel?: StringNullableWithAggregatesFilter | string | null
    mealsPerDay?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateCustomerNutritionNeedWhereInput = {
    AND?: Enumerable<IntermediateCustomerNutritionNeedWhereInput>
    OR?: Enumerable<IntermediateCustomerNutritionNeedWhereInput>
    NOT?: Enumerable<IntermediateCustomerNutritionNeedWhereInput>
    customerNutritionNeed?: XOR<CustomerNutritionNeedRelationFilter, CustomerNutritionNeedWhereInput>
    customerNutritionNeedId?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    nutritionValue?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerNutritionNeedOrderByWithRelationInput = {
    customerNutritionNeed?: CustomerNutritionNeedOrderByWithRelationInput
    customerNutritionNeedId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    nutritionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerNutritionNeedWhereUniqueInput = {
    customerNutritionNeedId_customerId?: IntermediateCustomerNutritionNeedCustomerNutritionNeedIdCustomerIdCompoundUniqueInput
  }

  export type IntermediateCustomerNutritionNeedOrderByWithAggregationInput = {
    customerNutritionNeedId?: SortOrder
    customerId?: SortOrder
    nutritionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateCustomerNutritionNeedCountOrderByAggregateInput
    _avg?: IntermediateCustomerNutritionNeedAvgOrderByAggregateInput
    _max?: IntermediateCustomerNutritionNeedMaxOrderByAggregateInput
    _min?: IntermediateCustomerNutritionNeedMinOrderByAggregateInput
    _sum?: IntermediateCustomerNutritionNeedSumOrderByAggregateInput
  }

  export type IntermediateCustomerNutritionNeedScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereWithAggregatesInput>
    customerNutritionNeedId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    nutritionValue?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomerNutritionNeedWhereInput = {
    AND?: Enumerable<CustomerNutritionNeedWhereInput>
    OR?: Enumerable<CustomerNutritionNeedWhereInput>
    NOT?: Enumerable<CustomerNutritionNeedWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    label?: StringFilter | string
    intermediateCustomerNutritionNeed?: IntermediateCustomerNutritionNeedListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerNutritionNeedOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    intermediateCustomerNutritionNeed?: IntermediateCustomerNutritionNeedOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerNutritionNeedWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CustomerNutritionNeedOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerNutritionNeedCountOrderByAggregateInput
    _avg?: CustomerNutritionNeedAvgOrderByAggregateInput
    _max?: CustomerNutritionNeedMaxOrderByAggregateInput
    _min?: CustomerNutritionNeedMinOrderByAggregateInput
    _sum?: CustomerNutritionNeedSumOrderByAggregateInput
  }

  export type CustomerNutritionNeedScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerNutritionNeedScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerNutritionNeedScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerNutritionNeedScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateCustomerMedicalConditionWhereInput = {
    AND?: Enumerable<IntermediateCustomerMedicalConditionWhereInput>
    OR?: Enumerable<IntermediateCustomerMedicalConditionWhereInput>
    NOT?: Enumerable<IntermediateCustomerMedicalConditionWhereInput>
    medicalConditionValue?: StringFilter | string
    customerMedicalCondition?: XOR<CustomerMedicalConditionRelationFilter, CustomerMedicalConditionWhereInput>
    customerMedicalConditionId?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerMedicalConditionOrderByWithRelationInput = {
    medicalConditionValue?: SortOrder
    customerMedicalCondition?: CustomerMedicalConditionOrderByWithRelationInput
    customerMedicalConditionId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerMedicalConditionWhereUniqueInput = {
    customerMedicalConditionId_customerId?: IntermediateCustomerMedicalConditionCustomerMedicalConditionIdCustomerIdCompoundUniqueInput
  }

  export type IntermediateCustomerMedicalConditionOrderByWithAggregationInput = {
    medicalConditionValue?: SortOrder
    customerMedicalConditionId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateCustomerMedicalConditionCountOrderByAggregateInput
    _avg?: IntermediateCustomerMedicalConditionAvgOrderByAggregateInput
    _max?: IntermediateCustomerMedicalConditionMaxOrderByAggregateInput
    _min?: IntermediateCustomerMedicalConditionMinOrderByAggregateInput
    _sum?: IntermediateCustomerMedicalConditionSumOrderByAggregateInput
  }

  export type IntermediateCustomerMedicalConditionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereWithAggregatesInput>
    medicalConditionValue?: StringWithAggregatesFilter | string
    customerMedicalConditionId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomerMedicalConditionWhereInput = {
    AND?: Enumerable<CustomerMedicalConditionWhereInput>
    OR?: Enumerable<CustomerMedicalConditionWhereInput>
    NOT?: Enumerable<CustomerMedicalConditionWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    label?: StringFilter | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerMedicalConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMedicalConditionWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CustomerMedicalConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerMedicalConditionCountOrderByAggregateInput
    _avg?: CustomerMedicalConditionAvgOrderByAggregateInput
    _max?: CustomerMedicalConditionMaxOrderByAggregateInput
    _min?: CustomerMedicalConditionMinOrderByAggregateInput
    _sum?: CustomerMedicalConditionSumOrderByAggregateInput
  }

  export type CustomerMedicalConditionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerMedicalConditionScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerMedicalConditionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerMedicalConditionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateCustomerFoodTypeWhereInput = {
    AND?: Enumerable<IntermediateCustomerFoodTypeWhereInput>
    OR?: Enumerable<IntermediateCustomerFoodTypeWhereInput>
    NOT?: Enumerable<IntermediateCustomerFoodTypeWhereInput>
    productFoodType?: XOR<ProductFoodTypeRelationFilter, ProductFoodTypeWhereInput>
    productFoodTypeId?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerFoodTypeOrderByWithRelationInput = {
    productFoodType?: ProductFoodTypeOrderByWithRelationInput
    productFoodTypeId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerFoodTypeWhereUniqueInput = {
    productFoodTypeId_customerId?: IntermediateCustomerFoodTypeProductFoodTypeIdCustomerIdCompoundUniqueInput
  }

  export type IntermediateCustomerFoodTypeOrderByWithAggregationInput = {
    productFoodTypeId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateCustomerFoodTypeCountOrderByAggregateInput
    _avg?: IntermediateCustomerFoodTypeAvgOrderByAggregateInput
    _max?: IntermediateCustomerFoodTypeMaxOrderByAggregateInput
    _min?: IntermediateCustomerFoodTypeMinOrderByAggregateInput
    _sum?: IntermediateCustomerFoodTypeSumOrderByAggregateInput
  }

  export type IntermediateCustomerFoodTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateCustomerFoodTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateCustomerFoodTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateCustomerFoodTypeScalarWhereWithAggregatesInput>
    productFoodTypeId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductFoodTypeWhereInput = {
    AND?: Enumerable<ProductFoodTypeWhereInput>
    OR?: Enumerable<ProductFoodTypeWhereInput>
    NOT?: Enumerable<ProductFoodTypeWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeListRelationFilter
    intermediateProductFoodTypes?: IntermediateProductFoodTypeListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductFoodTypeOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeOrderByRelationAggregateInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFoodTypeWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ProductFoodTypeOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductFoodTypeCountOrderByAggregateInput
    _avg?: ProductFoodTypeAvgOrderByAggregateInput
    _max?: ProductFoodTypeMaxOrderByAggregateInput
    _min?: ProductFoodTypeMinOrderByAggregateInput
    _sum?: ProductFoodTypeSumOrderByAggregateInput
  }

  export type ProductFoodTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductFoodTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductFoodTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductFoodTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateProductFoodTypeWhereInput = {
    AND?: Enumerable<IntermediateProductFoodTypeWhereInput>
    OR?: Enumerable<IntermediateProductFoodTypeWhereInput>
    NOT?: Enumerable<IntermediateProductFoodTypeWhereInput>
    productFoodType?: XOR<ProductFoodTypeRelationFilter, ProductFoodTypeWhereInput>
    productFoodTypeId?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateProductFoodTypeOrderByWithRelationInput = {
    productFoodType?: ProductFoodTypeOrderByWithRelationInput
    productFoodTypeId?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductFoodTypeWhereUniqueInput = {
    productFoodTypeId_productId?: IntermediateProductFoodTypeProductFoodTypeIdProductIdCompoundUniqueInput
  }

  export type IntermediateProductFoodTypeOrderByWithAggregationInput = {
    productFoodTypeId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateProductFoodTypeCountOrderByAggregateInput
    _avg?: IntermediateProductFoodTypeAvgOrderByAggregateInput
    _max?: IntermediateProductFoodTypeMaxOrderByAggregateInput
    _min?: IntermediateProductFoodTypeMinOrderByAggregateInput
    _sum?: IntermediateProductFoodTypeSumOrderByAggregateInput
  }

  export type IntermediateProductFoodTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateProductFoodTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateProductFoodTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateProductFoodTypeScalarWhereWithAggregatesInput>
    productFoodTypeId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: IntFilter | number
    activeStatus?: EnumActiveStatusNullableFilter | ActiveStatus | null
    name?: StringNullableFilter | string | null
    label?: StringNullableFilter | string | null
    ingredientLabel?: StringNullableFilter | string | null
    allergenLabel?: StringNullableFilter | string | null
    expertComment?: StringNullableFilter | string | null
    productProvider?: XOR<ProductProviderRelationFilter, ProductProviderWhereInput>
    productProviderId?: IntFilter | number
    productCategory?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput> | null
    productCategoryId?: IntNullableFilter | number | null
    productFlavor?: XOR<ProductFlavorRelationFilter, ProductFlavorWhereInput> | null
    productFlavorId?: IntNullableFilter | number | null
    productVendor?: XOR<ProductVendorRelationFilter, ProductVendorWhereInput> | null
    productVendorId?: IntNullableFilter | number | null
    intermediateProductFoodTypes?: IntermediateProductFoodTypeListRelationFilter
    intermediateProductIngredients?: IntermediateProductIngredientListRelationFilter
    intermediateProductAllergens?: IntermediateProductAllergenListRelationFilter
    intermediateProductCookingMethods?: IntermediateProductCookingMethodListRelationFilter
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductListRelationFilter
    productNutritionFact?: XOR<ProductNutritionFactRelationFilter, ProductNutritionFactWhereInput> | null
    externalSku?: StringFilter | string
    upcCode?: StringNullableFilter | string | null
    MSP?: FloatNullableFilter | number | null
    WSP?: FloatNullableFilter | number | null
    surveyQuestionAnswer?: SurveyQuestionAnswerListRelationFilter
    customerProductDistances?: CustomerProductDistanceListRelationFilter
    customerBoxItems?: CustomerBoxItemsListRelationFilter
    productImages?: ProductImageListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    activeStatus?: SortOrder
    name?: SortOrder
    label?: SortOrder
    ingredientLabel?: SortOrder
    allergenLabel?: SortOrder
    expertComment?: SortOrder
    productProvider?: ProductProviderOrderByWithRelationInput
    productProviderId?: SortOrder
    productCategory?: ProductCategoryOrderByWithRelationInput
    productCategoryId?: SortOrder
    productFlavor?: ProductFlavorOrderByWithRelationInput
    productFlavorId?: SortOrder
    productVendor?: ProductVendorOrderByWithRelationInput
    productVendorId?: SortOrder
    intermediateProductFoodTypes?: IntermediateProductFoodTypeOrderByRelationAggregateInput
    intermediateProductIngredients?: IntermediateProductIngredientOrderByRelationAggregateInput
    intermediateProductAllergens?: IntermediateProductAllergenOrderByRelationAggregateInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodOrderByRelationAggregateInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductOrderByRelationAggregateInput
    productNutritionFact?: ProductNutritionFactOrderByWithRelationInput
    externalSku?: SortOrder
    upcCode?: SortOrder
    MSP?: SortOrder
    WSP?: SortOrder
    surveyQuestionAnswer?: SurveyQuestionAnswerOrderByRelationAggregateInput
    customerProductDistances?: CustomerProductDistanceOrderByRelationAggregateInput
    customerBoxItems?: CustomerBoxItemsOrderByRelationAggregateInput
    productImages?: ProductImageOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductWhereUniqueInput = {
    id?: number
    externalSku?: string
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    activeStatus?: SortOrder
    name?: SortOrder
    label?: SortOrder
    ingredientLabel?: SortOrder
    allergenLabel?: SortOrder
    expertComment?: SortOrder
    productProviderId?: SortOrder
    productCategoryId?: SortOrder
    productFlavorId?: SortOrder
    productVendorId?: SortOrder
    externalSku?: SortOrder
    upcCode?: SortOrder
    MSP?: SortOrder
    WSP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    activeStatus?: EnumActiveStatusNullableWithAggregatesFilter | ActiveStatus | null
    name?: StringNullableWithAggregatesFilter | string | null
    label?: StringNullableWithAggregatesFilter | string | null
    ingredientLabel?: StringNullableWithAggregatesFilter | string | null
    allergenLabel?: StringNullableWithAggregatesFilter | string | null
    expertComment?: StringNullableWithAggregatesFilter | string | null
    productProviderId?: IntWithAggregatesFilter | number
    productCategoryId?: IntNullableWithAggregatesFilter | number | null
    productFlavorId?: IntNullableWithAggregatesFilter | number | null
    productVendorId?: IntNullableWithAggregatesFilter | number | null
    externalSku?: StringWithAggregatesFilter | string
    upcCode?: StringNullableWithAggregatesFilter | string | null
    MSP?: FloatNullableWithAggregatesFilter | number | null
    WSP?: FloatNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductImageWhereInput = {
    AND?: Enumerable<ProductImageWhereInput>
    OR?: Enumerable<ProductImageWhereInput>
    NOT?: Enumerable<ProductImageWhereInput>
    id?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    src?: StringFilter | string
    position?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    src?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageWhereUniqueInput = {
    id?: number
  }

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    src?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductImageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    src?: StringWithAggregatesFilter | string
    position?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateProductCookingMethodWhereInput = {
    AND?: Enumerable<IntermediateProductCookingMethodWhereInput>
    OR?: Enumerable<IntermediateProductCookingMethodWhereInput>
    NOT?: Enumerable<IntermediateProductCookingMethodWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    productCookingMethod?: XOR<ProductCookingMethodRelationFilter, ProductCookingMethodWhereInput>
    productCookingMethodId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateProductCookingMethodOrderByWithRelationInput = {
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    productCookingMethod?: ProductCookingMethodOrderByWithRelationInput
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductCookingMethodWhereUniqueInput = {
    productId_productCookingMethodId?: IntermediateProductCookingMethodProductIdProductCookingMethodIdCompoundUniqueInput
  }

  export type IntermediateProductCookingMethodOrderByWithAggregationInput = {
    productId?: SortOrder
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateProductCookingMethodCountOrderByAggregateInput
    _avg?: IntermediateProductCookingMethodAvgOrderByAggregateInput
    _max?: IntermediateProductCookingMethodMaxOrderByAggregateInput
    _min?: IntermediateProductCookingMethodMinOrderByAggregateInput
    _sum?: IntermediateProductCookingMethodSumOrderByAggregateInput
  }

  export type IntermediateProductCookingMethodScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateProductCookingMethodScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateProductCookingMethodScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateProductCookingMethodScalarWhereWithAggregatesInput>
    productId?: IntWithAggregatesFilter | number
    productCookingMethodId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodWhereInput = {
    AND?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereInput>
    OR?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereInput>
    NOT?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereInput>
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    productCookingMethod?: XOR<ProductCookingMethodRelationFilter, ProductCookingMethodWhereInput>
    productCookingMethodId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodOrderByWithRelationInput = {
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    productCookingMethod?: ProductCookingMethodOrderByWithRelationInput
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerUnavailableCookingMethodWhereUniqueInput = {
    customerId_productCookingMethodId?: IntermediateCustomerUnavailableCookingMethodCustomerIdProductCookingMethodIdCompoundUniqueInput
  }

  export type IntermediateCustomerUnavailableCookingMethodOrderByWithAggregationInput = {
    customerId?: SortOrder
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateCustomerUnavailableCookingMethodCountOrderByAggregateInput
    _avg?: IntermediateCustomerUnavailableCookingMethodAvgOrderByAggregateInput
    _max?: IntermediateCustomerUnavailableCookingMethodMaxOrderByAggregateInput
    _min?: IntermediateCustomerUnavailableCookingMethodMinOrderByAggregateInput
    _sum?: IntermediateCustomerUnavailableCookingMethodSumOrderByAggregateInput
  }

  export type IntermediateCustomerUnavailableCookingMethodScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereWithAggregatesInput>
    customerId?: IntWithAggregatesFilter | number
    productCookingMethodId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductCookingMethodWhereInput = {
    AND?: Enumerable<ProductCookingMethodWhereInput>
    OR?: Enumerable<ProductCookingMethodWhereInput>
    NOT?: Enumerable<ProductCookingMethodWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodListRelationFilter
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductCookingMethodOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    intermediateProductCookingMethods?: IntermediateProductCookingMethodOrderByRelationAggregateInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCookingMethodWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ProductCookingMethodOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCookingMethodCountOrderByAggregateInput
    _avg?: ProductCookingMethodAvgOrderByAggregateInput
    _max?: ProductCookingMethodMaxOrderByAggregateInput
    _min?: ProductCookingMethodMinOrderByAggregateInput
    _sum?: ProductCookingMethodSumOrderByAggregateInput
  }

  export type ProductCookingMethodScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductCookingMethodScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductCookingMethodScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductCookingMethodScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductFlavorWhereInput = {
    AND?: Enumerable<ProductFlavorWhereInput>
    OR?: Enumerable<ProductFlavorWhereInput>
    NOT?: Enumerable<ProductFlavorWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    products?: ProductListRelationFilter
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductFlavorOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFlavorWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ProductFlavorOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductFlavorCountOrderByAggregateInput
    _avg?: ProductFlavorAvgOrderByAggregateInput
    _max?: ProductFlavorMaxOrderByAggregateInput
    _min?: ProductFlavorMinOrderByAggregateInput
    _sum?: ProductFlavorSumOrderByAggregateInput
  }

  export type ProductFlavorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductFlavorScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductFlavorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductFlavorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductVendorWhereInput = {
    AND?: Enumerable<ProductVendorWhereInput>
    OR?: Enumerable<ProductVendorWhereInput>
    NOT?: Enumerable<ProductVendorWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    products?: ProductListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductVendorOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVendorWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ProductVendorOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVendorCountOrderByAggregateInput
    _avg?: ProductVendorAvgOrderByAggregateInput
    _max?: ProductVendorMaxOrderByAggregateInput
    _min?: ProductVendorMinOrderByAggregateInput
    _sum?: ProductVendorSumOrderByAggregateInput
  }

  export type ProductVendorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductVendorScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductVendorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductVendorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateCustomerFlavorDislikeWhereInput = {
    AND?: Enumerable<IntermediateCustomerFlavorDislikeWhereInput>
    OR?: Enumerable<IntermediateCustomerFlavorDislikeWhereInput>
    NOT?: Enumerable<IntermediateCustomerFlavorDislikeWhereInput>
    productFlavor?: XOR<ProductFlavorRelationFilter, ProductFlavorWhereInput>
    productFlavorId?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerFlavorDislikeOrderByWithRelationInput = {
    productFlavor?: ProductFlavorOrderByWithRelationInput
    productFlavorId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerFlavorDislikeWhereUniqueInput = {
    productFlavorId_customerId?: IntermediateCustomerFlavorDislikeProductFlavorIdCustomerIdCompoundUniqueInput
  }

  export type IntermediateCustomerFlavorDislikeOrderByWithAggregationInput = {
    productFlavorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateCustomerFlavorDislikeCountOrderByAggregateInput
    _avg?: IntermediateCustomerFlavorDislikeAvgOrderByAggregateInput
    _max?: IntermediateCustomerFlavorDislikeMaxOrderByAggregateInput
    _min?: IntermediateCustomerFlavorDislikeMinOrderByAggregateInput
    _sum?: IntermediateCustomerFlavorDislikeSumOrderByAggregateInput
  }

  export type IntermediateCustomerFlavorDislikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereWithAggregatesInput>
    productFlavorId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: Enumerable<ProductCategoryWhereInput>
    OR?: Enumerable<ProductCategoryWhereInput>
    NOT?: Enumerable<ProductCategoryWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    src?: StringNullableFilter | string | null
    products?: ProductListRelationFilter
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    src?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    src?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    src?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateCustomerCategoryPreferenceWhereInput = {
    AND?: Enumerable<IntermediateCustomerCategoryPreferenceWhereInput>
    OR?: Enumerable<IntermediateCustomerCategoryPreferenceWhereInput>
    NOT?: Enumerable<IntermediateCustomerCategoryPreferenceWhereInput>
    productCategory?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
    productCategoryId?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    rank?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerCategoryPreferenceOrderByWithRelationInput = {
    productCategory?: ProductCategoryOrderByWithRelationInput
    productCategoryId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerCategoryPreferenceWhereUniqueInput = {
    productCategoryId_customerId?: IntermediateCustomerCategoryPreferenceProductCategoryIdCustomerIdCompoundUniqueInput
  }

  export type IntermediateCustomerCategoryPreferenceOrderByWithAggregationInput = {
    productCategoryId?: SortOrder
    customerId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateCustomerCategoryPreferenceCountOrderByAggregateInput
    _avg?: IntermediateCustomerCategoryPreferenceAvgOrderByAggregateInput
    _max?: IntermediateCustomerCategoryPreferenceMaxOrderByAggregateInput
    _min?: IntermediateCustomerCategoryPreferenceMinOrderByAggregateInput
    _sum?: IntermediateCustomerCategoryPreferenceSumOrderByAggregateInput
  }

  export type IntermediateCustomerCategoryPreferenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereWithAggregatesInput>
    productCategoryId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    rank?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateProductIngredientWhereInput = {
    AND?: Enumerable<IntermediateProductIngredientWhereInput>
    OR?: Enumerable<IntermediateProductIngredientWhereInput>
    NOT?: Enumerable<IntermediateProductIngredientWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    productIngredient?: XOR<ProductIngredientRelationFilter, ProductIngredientWhereInput>
    productIngredientId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateProductIngredientOrderByWithRelationInput = {
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    productIngredient?: ProductIngredientOrderByWithRelationInput
    productIngredientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductIngredientWhereUniqueInput = {
    productId_productIngredientId?: IntermediateProductIngredientProductIdProductIngredientIdCompoundUniqueInput
  }

  export type IntermediateProductIngredientOrderByWithAggregationInput = {
    productId?: SortOrder
    productIngredientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateProductIngredientCountOrderByAggregateInput
    _avg?: IntermediateProductIngredientAvgOrderByAggregateInput
    _max?: IntermediateProductIngredientMaxOrderByAggregateInput
    _min?: IntermediateProductIngredientMinOrderByAggregateInput
    _sum?: IntermediateProductIngredientSumOrderByAggregateInput
  }

  export type IntermediateProductIngredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateProductIngredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateProductIngredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateProductIngredientScalarWhereWithAggregatesInput>
    productId?: IntWithAggregatesFilter | number
    productIngredientId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductIngredientWhereInput = {
    AND?: Enumerable<ProductIngredientWhereInput>
    OR?: Enumerable<ProductIngredientWhereInput>
    NOT?: Enumerable<ProductIngredientWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    intermediateProductIngredients?: IntermediateProductIngredientListRelationFilter
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductIngredientOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    intermediateProductIngredients?: IntermediateProductIngredientOrderByRelationAggregateInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductIngredientWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ProductIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductIngredientCountOrderByAggregateInput
    _avg?: ProductIngredientAvgOrderByAggregateInput
    _max?: ProductIngredientMaxOrderByAggregateInput
    _min?: ProductIngredientMinOrderByAggregateInput
    _sum?: ProductIngredientSumOrderByAggregateInput
  }

  export type ProductIngredientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductIngredientScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductIngredientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductIngredientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateCustomerIngredientDislikeWhereInput = {
    AND?: Enumerable<IntermediateCustomerIngredientDislikeWhereInput>
    OR?: Enumerable<IntermediateCustomerIngredientDislikeWhereInput>
    NOT?: Enumerable<IntermediateCustomerIngredientDislikeWhereInput>
    productIngredient?: XOR<ProductIngredientRelationFilter, ProductIngredientWhereInput>
    productIngredientId?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerIngredientDislikeOrderByWithRelationInput = {
    productIngredient?: ProductIngredientOrderByWithRelationInput
    productIngredientId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerIngredientDislikeWhereUniqueInput = {
    productIngredientId_customerId?: IntermediateCustomerIngredientDislikeProductIngredientIdCustomerIdCompoundUniqueInput
  }

  export type IntermediateCustomerIngredientDislikeOrderByWithAggregationInput = {
    productIngredientId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateCustomerIngredientDislikeCountOrderByAggregateInput
    _avg?: IntermediateCustomerIngredientDislikeAvgOrderByAggregateInput
    _max?: IntermediateCustomerIngredientDislikeMaxOrderByAggregateInput
    _min?: IntermediateCustomerIngredientDislikeMinOrderByAggregateInput
    _sum?: IntermediateCustomerIngredientDislikeSumOrderByAggregateInput
  }

  export type IntermediateCustomerIngredientDislikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereWithAggregatesInput>
    productIngredientId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateProductAllergenWhereInput = {
    AND?: Enumerable<IntermediateProductAllergenWhereInput>
    OR?: Enumerable<IntermediateProductAllergenWhereInput>
    NOT?: Enumerable<IntermediateProductAllergenWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    productAllergen?: XOR<ProductAllergenRelationFilter, ProductAllergenWhereInput>
    productAllergenId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateProductAllergenOrderByWithRelationInput = {
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    productAllergen?: ProductAllergenOrderByWithRelationInput
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductAllergenWhereUniqueInput = {
    productId_productAllergenId?: IntermediateProductAllergenProductIdProductAllergenIdCompoundUniqueInput
  }

  export type IntermediateProductAllergenOrderByWithAggregationInput = {
    productId?: SortOrder
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateProductAllergenCountOrderByAggregateInput
    _avg?: IntermediateProductAllergenAvgOrderByAggregateInput
    _max?: IntermediateProductAllergenMaxOrderByAggregateInput
    _min?: IntermediateProductAllergenMinOrderByAggregateInput
    _sum?: IntermediateProductAllergenSumOrderByAggregateInput
  }

  export type IntermediateProductAllergenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateProductAllergenScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateProductAllergenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateProductAllergenScalarWhereWithAggregatesInput>
    productId?: IntWithAggregatesFilter | number
    productAllergenId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductAllergenWhereInput = {
    AND?: Enumerable<ProductAllergenWhereInput>
    OR?: Enumerable<ProductAllergenWhereInput>
    NOT?: Enumerable<ProductAllergenWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    intermediateProductAllergens?: IntermediateProductAllergenListRelationFilter
    intermediateCustomerAllergens?: IntermediateCustomerAllergenListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductAllergenOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    intermediateProductAllergens?: IntermediateProductAllergenOrderByRelationAggregateInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAllergenWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ProductAllergenOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductAllergenCountOrderByAggregateInput
    _avg?: ProductAllergenAvgOrderByAggregateInput
    _max?: ProductAllergenMaxOrderByAggregateInput
    _min?: ProductAllergenMinOrderByAggregateInput
    _sum?: ProductAllergenSumOrderByAggregateInput
  }

  export type ProductAllergenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductAllergenScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductAllergenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductAllergenScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateCustomerAllergenWhereInput = {
    AND?: Enumerable<IntermediateCustomerAllergenWhereInput>
    OR?: Enumerable<IntermediateCustomerAllergenWhereInput>
    NOT?: Enumerable<IntermediateCustomerAllergenWhereInput>
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    productAllergen?: XOR<ProductAllergenRelationFilter, ProductAllergenWhereInput>
    productAllergenId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerAllergenOrderByWithRelationInput = {
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    productAllergen?: ProductAllergenOrderByWithRelationInput
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerAllergenWhereUniqueInput = {
    customerId_productAllergenId?: IntermediateCustomerAllergenCustomerIdProductAllergenIdCompoundUniqueInput
  }

  export type IntermediateCustomerAllergenOrderByWithAggregationInput = {
    customerId?: SortOrder
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateCustomerAllergenCountOrderByAggregateInput
    _avg?: IntermediateCustomerAllergenAvgOrderByAggregateInput
    _max?: IntermediateCustomerAllergenMaxOrderByAggregateInput
    _min?: IntermediateCustomerAllergenMinOrderByAggregateInput
    _sum?: IntermediateCustomerAllergenSumOrderByAggregateInput
  }

  export type IntermediateCustomerAllergenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateCustomerAllergenScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateCustomerAllergenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateCustomerAllergenScalarWhereWithAggregatesInput>
    customerId?: IntWithAggregatesFilter | number
    productAllergenId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductNutritionFactWhereInput = {
    AND?: Enumerable<ProductNutritionFactWhereInput>
    OR?: Enumerable<ProductNutritionFactWhereInput>
    NOT?: Enumerable<ProductNutritionFactWhereInput>
    id?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    quantity?: IntNullableFilter | number | null
    servingSize?: IntNullableFilter | number | null
    calories?: IntNullableFilter | number | null
    totalFatG?: FloatNullableFilter | number | null
    saturatedFatG?: FloatNullableFilter | number | null
    transFatG?: FloatNullableFilter | number | null
    cholesteroleMg?: FloatNullableFilter | number | null
    sodiumMg?: FloatNullableFilter | number | null
    totalCarbohydrateG?: FloatNullableFilter | number | null
    dietaryFiberG?: FloatNullableFilter | number | null
    totalSugarG?: FloatNullableFilter | number | null
    addedSugarG?: FloatNullableFilter | number | null
    proteinG?: FloatNullableFilter | number | null
    sweet?: IntNullableFilter | number | null
    sour?: IntNullableFilter | number | null
    salty?: IntNullableFilter | number | null
    bitter?: IntNullableFilter | number | null
    spicy?: IntNullableFilter | number | null
    texture?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductNutritionFactOrderByWithRelationInput = {
    id?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    quantity?: SortOrder
    servingSize?: SortOrder
    calories?: SortOrder
    totalFatG?: SortOrder
    saturatedFatG?: SortOrder
    transFatG?: SortOrder
    cholesteroleMg?: SortOrder
    sodiumMg?: SortOrder
    totalCarbohydrateG?: SortOrder
    dietaryFiberG?: SortOrder
    totalSugarG?: SortOrder
    addedSugarG?: SortOrder
    proteinG?: SortOrder
    sweet?: SortOrder
    sour?: SortOrder
    salty?: SortOrder
    bitter?: SortOrder
    spicy?: SortOrder
    texture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductNutritionFactWhereUniqueInput = {
    id?: number
    productId?: number
  }

  export type ProductNutritionFactOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    servingSize?: SortOrder
    calories?: SortOrder
    totalFatG?: SortOrder
    saturatedFatG?: SortOrder
    transFatG?: SortOrder
    cholesteroleMg?: SortOrder
    sodiumMg?: SortOrder
    totalCarbohydrateG?: SortOrder
    dietaryFiberG?: SortOrder
    totalSugarG?: SortOrder
    addedSugarG?: SortOrder
    proteinG?: SortOrder
    sweet?: SortOrder
    sour?: SortOrder
    salty?: SortOrder
    bitter?: SortOrder
    spicy?: SortOrder
    texture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductNutritionFactCountOrderByAggregateInput
    _avg?: ProductNutritionFactAvgOrderByAggregateInput
    _max?: ProductNutritionFactMaxOrderByAggregateInput
    _min?: ProductNutritionFactMinOrderByAggregateInput
    _sum?: ProductNutritionFactSumOrderByAggregateInput
  }

  export type ProductNutritionFactScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductNutritionFactScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductNutritionFactScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductNutritionFactScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    quantity?: IntNullableWithAggregatesFilter | number | null
    servingSize?: IntNullableWithAggregatesFilter | number | null
    calories?: IntNullableWithAggregatesFilter | number | null
    totalFatG?: FloatNullableWithAggregatesFilter | number | null
    saturatedFatG?: FloatNullableWithAggregatesFilter | number | null
    transFatG?: FloatNullableWithAggregatesFilter | number | null
    cholesteroleMg?: FloatNullableWithAggregatesFilter | number | null
    sodiumMg?: FloatNullableWithAggregatesFilter | number | null
    totalCarbohydrateG?: FloatNullableWithAggregatesFilter | number | null
    dietaryFiberG?: FloatNullableWithAggregatesFilter | number | null
    totalSugarG?: FloatNullableWithAggregatesFilter | number | null
    addedSugarG?: FloatNullableWithAggregatesFilter | number | null
    proteinG?: FloatNullableWithAggregatesFilter | number | null
    sweet?: IntNullableWithAggregatesFilter | number | null
    sour?: IntNullableWithAggregatesFilter | number | null
    salty?: IntNullableWithAggregatesFilter | number | null
    bitter?: IntNullableWithAggregatesFilter | number | null
    spicy?: IntNullableWithAggregatesFilter | number | null
    texture?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProductProviderWhereInput = {
    AND?: Enumerable<ProductProviderWhereInput>
    OR?: Enumerable<ProductProviderWhereInput>
    NOT?: Enumerable<ProductProviderWhereInput>
    id?: IntFilter | number
    provider?: StringFilter | string
    products?: ProductListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductProviderOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProviderWhereUniqueInput = {
    id?: number
    provider?: string
  }

  export type ProductProviderOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductProviderCountOrderByAggregateInput
    _avg?: ProductProviderAvgOrderByAggregateInput
    _max?: ProductProviderMaxOrderByAggregateInput
    _min?: ProductProviderMinOrderByAggregateInput
    _sum?: ProductProviderSumOrderByAggregateInput
  }

  export type ProductProviderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductProviderScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductProviderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductProviderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    provider?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SurveyWhereInput = {
    AND?: Enumerable<SurveyWhereInput>
    OR?: Enumerable<SurveyWhereInput>
    NOT?: Enumerable<SurveyWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    label?: StringFilter | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    intermediateSurveyQuestions?: IntermediateSurveyQuestionOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type SurveyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurveyCountOrderByAggregateInput
    _avg?: SurveyAvgOrderByAggregateInput
    _max?: SurveyMaxOrderByAggregateInput
    _min?: SurveyMinOrderByAggregateInput
    _sum?: SurveySumOrderByAggregateInput
  }

  export type SurveyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SurveyScalarWhereWithAggregatesInput>
    OR?: Enumerable<SurveyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SurveyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateSurveyQuestionWhereInput = {
    AND?: Enumerable<IntermediateSurveyQuestionWhereInput>
    OR?: Enumerable<IntermediateSurveyQuestionWhereInput>
    NOT?: Enumerable<IntermediateSurveyQuestionWhereInput>
    survey?: XOR<SurveyRelationFilter, SurveyWhereInput>
    surveyId?: IntFilter | number
    displayOrder?: IntNullableFilter | number | null
    surveyQuestion?: XOR<SurveyQuestionRelationFilter, SurveyQuestionWhereInput>
    surveyQuestionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateSurveyQuestionOrderByWithRelationInput = {
    survey?: SurveyOrderByWithRelationInput
    surveyId?: SortOrder
    displayOrder?: SortOrder
    surveyQuestion?: SurveyQuestionOrderByWithRelationInput
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateSurveyQuestionWhereUniqueInput = {
    surveyId_surveyQuestionId?: IntermediateSurveyQuestionSurveyIdSurveyQuestionIdCompoundUniqueInput
  }

  export type IntermediateSurveyQuestionOrderByWithAggregationInput = {
    surveyId?: SortOrder
    displayOrder?: SortOrder
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateSurveyQuestionCountOrderByAggregateInput
    _avg?: IntermediateSurveyQuestionAvgOrderByAggregateInput
    _max?: IntermediateSurveyQuestionMaxOrderByAggregateInput
    _min?: IntermediateSurveyQuestionMinOrderByAggregateInput
    _sum?: IntermediateSurveyQuestionSumOrderByAggregateInput
  }

  export type IntermediateSurveyQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateSurveyQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateSurveyQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateSurveyQuestionScalarWhereWithAggregatesInput>
    surveyId?: IntWithAggregatesFilter | number
    displayOrder?: IntNullableWithAggregatesFilter | number | null
    surveyQuestionId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SurveyQuestionWhereInput = {
    AND?: Enumerable<SurveyQuestionWhereInput>
    OR?: Enumerable<SurveyQuestionWhereInput>
    NOT?: Enumerable<SurveyQuestionWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    label?: StringFilter | string
    questionCategory?: XOR<QuestionCategoryRelationFilter, QuestionCategoryWhereInput>
    questionCategoryId?: IntFilter | number
    mustBeAnswered?: BoolFilter | boolean
    instruction?: StringNullableFilter | string | null
    placeholder?: StringNullableFilter | string | null
    surveyQuestionAnswerType?: XOR<SurveyQuestionAnswerTypeRelationFilter, SurveyQuestionAnswerTypeWhereInput>
    surveyQuestionAnswerTypeId?: IntFilter | number
    intermediateSurveyQuestions?: IntermediateSurveyQuestionListRelationFilter
    surveyQuestionOptions?: SurveyQuestionOptionListRelationFilter
    surveyQuestionAnswer?: SurveyQuestionAnswerListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyQuestionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    questionCategory?: QuestionCategoryOrderByWithRelationInput
    questionCategoryId?: SortOrder
    mustBeAnswered?: SortOrder
    instruction?: SortOrder
    placeholder?: SortOrder
    surveyQuestionAnswerType?: SurveyQuestionAnswerTypeOrderByWithRelationInput
    surveyQuestionAnswerTypeId?: SortOrder
    intermediateSurveyQuestions?: IntermediateSurveyQuestionOrderByRelationAggregateInput
    surveyQuestionOptions?: SurveyQuestionOptionOrderByRelationAggregateInput
    surveyQuestionAnswer?: SurveyQuestionAnswerOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type SurveyQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    questionCategoryId?: SortOrder
    mustBeAnswered?: SortOrder
    instruction?: SortOrder
    placeholder?: SortOrder
    surveyQuestionAnswerTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurveyQuestionCountOrderByAggregateInput
    _avg?: SurveyQuestionAvgOrderByAggregateInput
    _max?: SurveyQuestionMaxOrderByAggregateInput
    _min?: SurveyQuestionMinOrderByAggregateInput
    _sum?: SurveyQuestionSumOrderByAggregateInput
  }

  export type SurveyQuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SurveyQuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SurveyQuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SurveyQuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    questionCategoryId?: IntWithAggregatesFilter | number
    mustBeAnswered?: BoolWithAggregatesFilter | boolean
    instruction?: StringNullableWithAggregatesFilter | string | null
    placeholder?: StringNullableWithAggregatesFilter | string | null
    surveyQuestionAnswerTypeId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionCategoryWhereInput = {
    AND?: Enumerable<QuestionCategoryWhereInput>
    OR?: Enumerable<QuestionCategoryWhereInput>
    NOT?: Enumerable<QuestionCategoryWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    surveyQuestions?: SurveyQuestionListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QuestionCategoryOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    surveyQuestions?: SurveyQuestionOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type QuestionCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionCategoryCountOrderByAggregateInput
    _avg?: QuestionCategoryAvgOrderByAggregateInput
    _max?: QuestionCategoryMaxOrderByAggregateInput
    _min?: QuestionCategoryMinOrderByAggregateInput
    _sum?: QuestionCategorySumOrderByAggregateInput
  }

  export type QuestionCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SurveyQuestionAnswerTypeWhereInput = {
    AND?: Enumerable<SurveyQuestionAnswerTypeWhereInput>
    OR?: Enumerable<SurveyQuestionAnswerTypeWhereInput>
    NOT?: Enumerable<SurveyQuestionAnswerTypeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    label?: StringFilter | string
    surveyQuestions?: SurveyQuestionListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyQuestionAnswerTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    surveyQuestions?: SurveyQuestionOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAnswerTypeWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type SurveyQuestionAnswerTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurveyQuestionAnswerTypeCountOrderByAggregateInput
    _avg?: SurveyQuestionAnswerTypeAvgOrderByAggregateInput
    _max?: SurveyQuestionAnswerTypeMaxOrderByAggregateInput
    _min?: SurveyQuestionAnswerTypeMinOrderByAggregateInput
    _sum?: SurveyQuestionAnswerTypeSumOrderByAggregateInput
  }

  export type SurveyQuestionAnswerTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SurveyQuestionAnswerTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<SurveyQuestionAnswerTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SurveyQuestionAnswerTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SurveyQuestionOptionWhereInput = {
    AND?: Enumerable<SurveyQuestionOptionWhereInput>
    OR?: Enumerable<SurveyQuestionOptionWhereInput>
    NOT?: Enumerable<SurveyQuestionOptionWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    surveyQuestion?: XOR<SurveyQuestionRelationFilter, SurveyQuestionWhereInput>
    surveyQuestionId?: IntFilter | number
    surveyQuestionAnswer?: SurveyQuestionAnswerListRelationFilter
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyQuestionOptionOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    surveyQuestion?: SurveyQuestionOrderByWithRelationInput
    surveyQuestionId?: SortOrder
    surveyQuestionAnswer?: SurveyQuestionAnswerOrderByRelationAggregateInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionOptionWhereUniqueInput = {
    id?: number
    QuestionOptionIdentifier?: SurveyQuestionOptionQuestionOptionIdentifierCompoundUniqueInput
  }

  export type SurveyQuestionOptionOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurveyQuestionOptionCountOrderByAggregateInput
    _avg?: SurveyQuestionOptionAvgOrderByAggregateInput
    _max?: SurveyQuestionOptionMaxOrderByAggregateInput
    _min?: SurveyQuestionOptionMinOrderByAggregateInput
    _sum?: SurveyQuestionOptionSumOrderByAggregateInput
  }

  export type SurveyQuestionOptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SurveyQuestionOptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SurveyQuestionOptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SurveyQuestionOptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    surveyQuestionId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SurveyQuestionAnswerWhereInput = {
    AND?: Enumerable<SurveyQuestionAnswerWhereInput>
    OR?: Enumerable<SurveyQuestionAnswerWhereInput>
    NOT?: Enumerable<SurveyQuestionAnswerWhereInput>
    id?: IntFilter | number
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductListRelationFilter
    responseId?: StringNullableFilter | string | null
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    surveyQuestion?: XOR<SurveyQuestionRelationFilter, SurveyQuestionWhereInput>
    surveyQuestionId?: IntFilter | number
    answerOption?: XOR<SurveyQuestionOptionRelationFilter, SurveyQuestionOptionWhereInput> | null
    answerSingleOptionId?: IntNullableFilter | number | null
    answerNumeric?: IntNullableFilter | number | null
    answerText?: StringNullableFilter | string | null
    answerBool?: BoolNullableFilter | boolean | null
    reason?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
    answerCount?: IntNullableFilter | number | null
    product?: XOR<ProductRelationFilter, ProductWhereInput> | null
    productId?: IntNullableFilter | number | null
    orderNumber?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyQuestionAnswerOrderByWithRelationInput = {
    id?: SortOrder
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductOrderByRelationAggregateInput
    responseId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    surveyQuestion?: SurveyQuestionOrderByWithRelationInput
    surveyQuestionId?: SortOrder
    answerOption?: SurveyQuestionOptionOrderByWithRelationInput
    answerSingleOptionId?: SortOrder
    answerNumeric?: SortOrder
    answerText?: SortOrder
    answerBool?: SortOrder
    reason?: SortOrder
    title?: SortOrder
    content?: SortOrder
    answerCount?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    orderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAnswerWhereUniqueInput = {
    id?: number
    responseId?: string
  }

  export type SurveyQuestionAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    responseId?: SortOrder
    customerId?: SortOrder
    surveyQuestionId?: SortOrder
    answerSingleOptionId?: SortOrder
    answerNumeric?: SortOrder
    answerText?: SortOrder
    answerBool?: SortOrder
    reason?: SortOrder
    title?: SortOrder
    content?: SortOrder
    answerCount?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SurveyQuestionAnswerCountOrderByAggregateInput
    _avg?: SurveyQuestionAnswerAvgOrderByAggregateInput
    _max?: SurveyQuestionAnswerMaxOrderByAggregateInput
    _min?: SurveyQuestionAnswerMinOrderByAggregateInput
    _sum?: SurveyQuestionAnswerSumOrderByAggregateInput
  }

  export type SurveyQuestionAnswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SurveyQuestionAnswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<SurveyQuestionAnswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SurveyQuestionAnswerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    responseId?: StringNullableWithAggregatesFilter | string | null
    customerId?: IntWithAggregatesFilter | number
    surveyQuestionId?: IntWithAggregatesFilter | number
    answerSingleOptionId?: IntNullableWithAggregatesFilter | number | null
    answerNumeric?: IntNullableWithAggregatesFilter | number | null
    answerText?: StringNullableWithAggregatesFilter | string | null
    answerBool?: BoolNullableWithAggregatesFilter | boolean | null
    reason?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    content?: StringNullableWithAggregatesFilter | string | null
    answerCount?: IntNullableWithAggregatesFilter | number | null
    productId?: IntNullableWithAggregatesFilter | number | null
    orderNumber?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductWhereInput = {
    AND?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereInput>
    OR?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereInput>
    NOT?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereInput>
    surveyQuestionAnswer?: XOR<SurveyQuestionAnswerRelationFilter, SurveyQuestionAnswerWhereInput>
    surveyQuestionAnswerId?: IntFilter | number
    surveyQuestionOption?: XOR<SurveyQuestionOptionRelationFilter, SurveyQuestionOptionWhereInput>
    surveyQuestionOptionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductOrderByWithRelationInput = {
    surveyQuestionAnswer?: SurveyQuestionAnswerOrderByWithRelationInput
    surveyQuestionAnswerId?: SortOrder
    surveyQuestionOption?: SurveyQuestionOptionOrderByWithRelationInput
    surveyQuestionOptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateSurveyQuestionAnswerProductWhereUniqueInput = {
    surveyQuestionAnswerId_surveyQuestionOptionId?: IntermediateSurveyQuestionAnswerProductSurveyQuestionAnswerIdSurveyQuestionOptionIdCompoundUniqueInput
  }

  export type IntermediateSurveyQuestionAnswerProductOrderByWithAggregationInput = {
    surveyQuestionAnswerId?: SortOrder
    surveyQuestionOptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediateSurveyQuestionAnswerProductCountOrderByAggregateInput
    _avg?: IntermediateSurveyQuestionAnswerProductAvgOrderByAggregateInput
    _max?: IntermediateSurveyQuestionAnswerProductMaxOrderByAggregateInput
    _min?: IntermediateSurveyQuestionAnswerProductMinOrderByAggregateInput
    _sum?: IntermediateSurveyQuestionAnswerProductSumOrderByAggregateInput
  }

  export type IntermediateSurveyQuestionAnswerProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereWithAggregatesInput>
    surveyQuestionAnswerId?: IntWithAggregatesFilter | number
    surveyQuestionOptionId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomerProductDistanceWhereInput = {
    AND?: Enumerable<CustomerProductDistanceWhereInput>
    OR?: Enumerable<CustomerProductDistanceWhereInput>
    NOT?: Enumerable<CustomerProductDistanceWhereInput>
    id?: IntFilter | number
    distance?: FloatFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    version?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerProductDistanceOrderByWithRelationInput = {
    id?: SortOrder
    distance?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductDistanceWhereUniqueInput = {
    id?: number
  }

  export type CustomerProductDistanceOrderByWithAggregationInput = {
    id?: SortOrder
    distance?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerProductDistanceCountOrderByAggregateInput
    _avg?: CustomerProductDistanceAvgOrderByAggregateInput
    _max?: CustomerProductDistanceMaxOrderByAggregateInput
    _min?: CustomerProductDistanceMinOrderByAggregateInput
    _sum?: CustomerProductDistanceSumOrderByAggregateInput
  }

  export type CustomerProductDistanceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerProductDistanceScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerProductDistanceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerProductDistanceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    distance?: FloatWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    version?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CustomerBoxItemsWhereInput = {
    AND?: Enumerable<CustomerBoxItemsWhereInput>
    OR?: Enumerable<CustomerBoxItemsWhereInput>
    NOT?: Enumerable<CustomerBoxItemsWhereInput>
    id?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerBoxItemsOrderByWithRelationInput = {
    id?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerBoxItemsWhereUniqueInput = {
    id?: number
  }

  export type CustomerBoxItemsOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerBoxItemsCountOrderByAggregateInput
    _avg?: CustomerBoxItemsAvgOrderByAggregateInput
    _max?: CustomerBoxItemsMaxOrderByAggregateInput
    _min?: CustomerBoxItemsMinOrderByAggregateInput
    _sum?: CustomerBoxItemsSumOrderByAggregateInput
  }

  export type CustomerBoxItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerBoxItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerBoxItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerBoxItemsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QueuedShopifyOrderWhereInput = {
    AND?: Enumerable<QueuedShopifyOrderWhereInput>
    OR?: Enumerable<QueuedShopifyOrderWhereInput>
    NOT?: Enumerable<QueuedShopifyOrderWhereInput>
    id?: IntFilter | number
    customerId?: IntFilter | number
    orderName?: StringFilter | string
    status?: EnumQueueStatusFilter | QueueStatus
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    scheduledAt?: StringFilter | string
    orderedAt?: StringNullableFilter | string | null
    fulfilledAt?: StringNullableFilter | string | null
  }

  export type QueuedShopifyOrderOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    orderName?: SortOrder
    status?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    scheduledAt?: SortOrder
    orderedAt?: SortOrder
    fulfilledAt?: SortOrder
  }

  export type QueuedShopifyOrderWhereUniqueInput = {
    id?: number
    orderName?: string
  }

  export type QueuedShopifyOrderOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    orderName?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    orderedAt?: SortOrder
    fulfilledAt?: SortOrder
    _count?: QueuedShopifyOrderCountOrderByAggregateInput
    _avg?: QueuedShopifyOrderAvgOrderByAggregateInput
    _max?: QueuedShopifyOrderMaxOrderByAggregateInput
    _min?: QueuedShopifyOrderMinOrderByAggregateInput
    _sum?: QueuedShopifyOrderSumOrderByAggregateInput
  }

  export type QueuedShopifyOrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QueuedShopifyOrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<QueuedShopifyOrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QueuedShopifyOrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    orderName?: StringWithAggregatesFilter | string
    status?: EnumQueueStatusWithAggregatesFilter | QueueStatus
    scheduledAt?: StringWithAggregatesFilter | string
    orderedAt?: StringNullableWithAggregatesFilter | string | null
    fulfilledAt?: StringNullableWithAggregatesFilter | string | null
  }

  export type PractitionerWhereInput = {
    AND?: Enumerable<PractitionerWhereInput>
    OR?: Enumerable<PractitionerWhereInput>
    NOT?: Enumerable<PractitionerWhereInput>
    id?: IntFilter | number
    uuid?: StringFilter | string
    email?: StringFilter | string
    phoneNumber?: StringNullableFilter | string | null
    firstName?: StringFilter | string
    lastName?: StringNullableFilter | string | null
    practitionerBox?: PractitionerBoxListRelationFilter
    practitionerSocialMedia?: XOR<PractitionerSocialMediaRelationFilter, PractitionerSocialMediaWhereInput> | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PractitionerOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    practitionerBox?: PractitionerBoxOrderByRelationAggregateInput
    practitionerSocialMedia?: PractitionerSocialMediaOrderByWithRelationInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerWhereUniqueInput = {
    id?: number
    uuid?: string
    email?: string
  }

  export type PractitionerOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PractitionerCountOrderByAggregateInput
    _avg?: PractitionerAvgOrderByAggregateInput
    _max?: PractitionerMaxOrderByAggregateInput
    _min?: PractitionerMinOrderByAggregateInput
    _sum?: PractitionerSumOrderByAggregateInput
  }

  export type PractitionerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PractitionerScalarWhereWithAggregatesInput>
    OR?: Enumerable<PractitionerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PractitionerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uuid?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PractitionerSocialMediaWhereInput = {
    AND?: Enumerable<PractitionerSocialMediaWhereInput>
    OR?: Enumerable<PractitionerSocialMediaWhereInput>
    NOT?: Enumerable<PractitionerSocialMediaWhereInput>
    id?: IntFilter | number
    practitioner?: XOR<PractitionerRelationFilter, PractitionerWhereInput>
    practitionerId?: IntFilter | number
    instagram?: StringNullableFilter | string | null
    facebook?: StringNullableFilter | string | null
    twitter?: StringNullableFilter | string | null
    website?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PractitionerSocialMediaOrderByWithRelationInput = {
    id?: SortOrder
    practitioner?: PractitionerOrderByWithRelationInput
    practitionerId?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerSocialMediaWhereUniqueInput = {
    id?: number
    practitionerId?: number
  }

  export type PractitionerSocialMediaOrderByWithAggregationInput = {
    id?: SortOrder
    practitionerId?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PractitionerSocialMediaCountOrderByAggregateInput
    _avg?: PractitionerSocialMediaAvgOrderByAggregateInput
    _max?: PractitionerSocialMediaMaxOrderByAggregateInput
    _min?: PractitionerSocialMediaMinOrderByAggregateInput
    _sum?: PractitionerSocialMediaSumOrderByAggregateInput
  }

  export type PractitionerSocialMediaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PractitionerSocialMediaScalarWhereWithAggregatesInput>
    OR?: Enumerable<PractitionerSocialMediaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PractitionerSocialMediaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    practitionerId?: IntWithAggregatesFilter | number
    instagram?: StringNullableWithAggregatesFilter | string | null
    facebook?: StringNullableWithAggregatesFilter | string | null
    twitter?: StringNullableWithAggregatesFilter | string | null
    website?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PractitionerBoxWhereInput = {
    AND?: Enumerable<PractitionerBoxWhereInput>
    OR?: Enumerable<PractitionerBoxWhereInput>
    NOT?: Enumerable<PractitionerBoxWhereInput>
    id?: IntFilter | number
    practitioner?: XOR<PractitionerRelationFilter, PractitionerWhereInput>
    practitionerId?: IntFilter | number
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryListRelationFilter
    label?: StringFilter | string
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PractitionerBoxOrderByWithRelationInput = {
    id?: SortOrder
    practitioner?: PractitionerOrderByWithRelationInput
    practitionerId?: SortOrder
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryOrderByRelationAggregateInput
    label?: SortOrder
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductOrderByRelationAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerBoxWhereUniqueInput = {
    id?: number
  }

  export type PractitionerBoxOrderByWithAggregationInput = {
    id?: SortOrder
    practitionerId?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PractitionerBoxCountOrderByAggregateInput
    _avg?: PractitionerBoxAvgOrderByAggregateInput
    _max?: PractitionerBoxMaxOrderByAggregateInput
    _min?: PractitionerBoxMinOrderByAggregateInput
    _sum?: PractitionerBoxSumOrderByAggregateInput
  }

  export type PractitionerBoxScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PractitionerBoxScalarWhereWithAggregatesInput>
    OR?: Enumerable<PractitionerBoxScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PractitionerBoxScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    practitionerId?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IntermediatePractitionerBoxProductWhereInput = {
    AND?: Enumerable<IntermediatePractitionerBoxProductWhereInput>
    OR?: Enumerable<IntermediatePractitionerBoxProductWhereInput>
    NOT?: Enumerable<IntermediatePractitionerBoxProductWhereInput>
    practitionerBox?: XOR<PractitionerBoxRelationFilter, PractitionerBoxWhereInput>
    practitionerBoxId?: IntFilter | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediatePractitionerBoxProductOrderByWithRelationInput = {
    practitionerBox?: PractitionerBoxOrderByWithRelationInput
    practitionerBoxId?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediatePractitionerBoxProductWhereUniqueInput = {
    practitionerBoxId_productId?: IntermediatePractitionerBoxProductPractitionerBoxIdProductIdCompoundUniqueInput
  }

  export type IntermediatePractitionerBoxProductOrderByWithAggregationInput = {
    practitionerBoxId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntermediatePractitionerBoxProductCountOrderByAggregateInput
    _avg?: IntermediatePractitionerBoxProductAvgOrderByAggregateInput
    _max?: IntermediatePractitionerBoxProductMaxOrderByAggregateInput
    _min?: IntermediatePractitionerBoxProductMinOrderByAggregateInput
    _sum?: IntermediatePractitionerBoxProductSumOrderByAggregateInput
  }

  export type IntermediatePractitionerBoxProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IntermediatePractitionerBoxProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<IntermediatePractitionerBoxProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IntermediatePractitionerBoxProductScalarWhereWithAggregatesInput>
    practitionerBoxId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PractitionerCustomerOrderHistoryWhereInput = {
    AND?: Enumerable<PractitionerCustomerOrderHistoryWhereInput>
    OR?: Enumerable<PractitionerCustomerOrderHistoryWhereInput>
    NOT?: Enumerable<PractitionerCustomerOrderHistoryWhereInput>
    id?: IntFilter | number
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    customerId?: IntFilter | number
    practitionerBox?: XOR<PractitionerBoxRelationFilter, PractitionerBoxWhereInput>
    practitionerBoxId?: IntFilter | number
    orderNumber?: StringFilter | string
    purchasePrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PractitionerCustomerOrderHistoryOrderByWithRelationInput = {
    id?: SortOrder
    customer?: CustomersOrderByWithRelationInput
    customerId?: SortOrder
    practitionerBox?: PractitionerBoxOrderByWithRelationInput
    practitionerBoxId?: SortOrder
    orderNumber?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerCustomerOrderHistoryWhereUniqueInput = {
    id?: number
  }

  export type PractitionerCustomerOrderHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    practitionerBoxId?: SortOrder
    orderNumber?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PractitionerCustomerOrderHistoryCountOrderByAggregateInput
    _avg?: PractitionerCustomerOrderHistoryAvgOrderByAggregateInput
    _max?: PractitionerCustomerOrderHistoryMaxOrderByAggregateInput
    _min?: PractitionerCustomerOrderHistoryMinOrderByAggregateInput
    _sum?: PractitionerCustomerOrderHistorySumOrderByAggregateInput
  }

  export type PractitionerCustomerOrderHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    practitionerBoxId?: IntWithAggregatesFilter | number
    orderNumber?: StringWithAggregatesFilter | string
    purchasePrice?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DiscoveriesCreateInput = {
    email: string
    typeform_id: string
    BMR: number
    carbs_macronutrients: number
    protein_macronutrients: number
    fat_macronutrients: number
    carbs_per_meal: number
    protein_per_meal: number
    fat_per_meal: number
    calorie_per_meal: number
  }

  export type DiscoveriesUncheckedCreateInput = {
    id?: number
    email: string
    typeform_id: string
    BMR: number
    carbs_macronutrients: number
    protein_macronutrients: number
    fat_macronutrients: number
    carbs_per_meal: number
    protein_per_meal: number
    fat_per_meal: number
    calorie_per_meal: number
  }

  export type DiscoveriesUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    typeform_id?: StringFieldUpdateOperationsInput | string
    BMR?: IntFieldUpdateOperationsInput | number
    carbs_macronutrients?: IntFieldUpdateOperationsInput | number
    protein_macronutrients?: IntFieldUpdateOperationsInput | number
    fat_macronutrients?: IntFieldUpdateOperationsInput | number
    carbs_per_meal?: IntFieldUpdateOperationsInput | number
    protein_per_meal?: IntFieldUpdateOperationsInput | number
    fat_per_meal?: IntFieldUpdateOperationsInput | number
    calorie_per_meal?: IntFieldUpdateOperationsInput | number
  }

  export type DiscoveriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    typeform_id?: StringFieldUpdateOperationsInput | string
    BMR?: IntFieldUpdateOperationsInput | number
    carbs_macronutrients?: IntFieldUpdateOperationsInput | number
    protein_macronutrients?: IntFieldUpdateOperationsInput | number
    fat_macronutrients?: IntFieldUpdateOperationsInput | number
    carbs_per_meal?: IntFieldUpdateOperationsInput | number
    protein_per_meal?: IntFieldUpdateOperationsInput | number
    fat_per_meal?: IntFieldUpdateOperationsInput | number
    calorie_per_meal?: IntFieldUpdateOperationsInput | number
  }

  export type DiscoveriesCreateManyInput = {
    id?: number
    email: string
    typeform_id: string
    BMR: number
    carbs_macronutrients: number
    protein_macronutrients: number
    fat_macronutrients: number
    carbs_per_meal: number
    protein_per_meal: number
    fat_per_meal: number
    calorie_per_meal: number
  }

  export type DiscoveriesUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    typeform_id?: StringFieldUpdateOperationsInput | string
    BMR?: IntFieldUpdateOperationsInput | number
    carbs_macronutrients?: IntFieldUpdateOperationsInput | number
    protein_macronutrients?: IntFieldUpdateOperationsInput | number
    fat_macronutrients?: IntFieldUpdateOperationsInput | number
    carbs_per_meal?: IntFieldUpdateOperationsInput | number
    protein_per_meal?: IntFieldUpdateOperationsInput | number
    fat_per_meal?: IntFieldUpdateOperationsInput | number
    calorie_per_meal?: IntFieldUpdateOperationsInput | number
  }

  export type DiscoveriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    typeform_id?: StringFieldUpdateOperationsInput | string
    BMR?: IntFieldUpdateOperationsInput | number
    carbs_macronutrients?: IntFieldUpdateOperationsInput | number
    protein_macronutrients?: IntFieldUpdateOperationsInput | number
    fat_macronutrients?: IntFieldUpdateOperationsInput | number
    carbs_per_meal?: IntFieldUpdateOperationsInput | number
    protein_per_meal?: IntFieldUpdateOperationsInput | number
    fat_per_meal?: IntFieldUpdateOperationsInput | number
    calorie_per_meal?: IntFieldUpdateOperationsInput | number
  }

  export type CustomersCreateInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUpdateInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type CustomersCreateManyInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomersUpdateManyMutationInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerNutritionNeedCreateInput = {
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerNutritionNeed: CustomerNutritionNeedCreateNestedOneWithoutIntermediateCustomerNutritionNeedInput
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerNutritionNeedsInput
  }

  export type IntermediateCustomerNutritionNeedUncheckedCreateInput = {
    customerNutritionNeedId: number
    customerId: number
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerNutritionNeedUpdateInput = {
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerNutritionNeed?: CustomerNutritionNeedUpdateOneRequiredWithoutIntermediateCustomerNutritionNeedInput
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerNutritionNeedsInput
  }

  export type IntermediateCustomerNutritionNeedUncheckedUpdateInput = {
    customerNutritionNeedId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerNutritionNeedCreateManyInput = {
    customerNutritionNeedId: number
    customerId: number
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerNutritionNeedUpdateManyMutationInput = {
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerNutritionNeedUncheckedUpdateManyInput = {
    customerNutritionNeedId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNutritionNeedCreateInput = {
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeed?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerNutritionNeedInput
  }

  export type CustomerNutritionNeedUncheckedCreateInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeed?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerNutritionNeedInput
  }

  export type CustomerNutritionNeedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeed?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerNutritionNeedInput
  }

  export type CustomerNutritionNeedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeed?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerNutritionNeedInput
  }

  export type CustomerNutritionNeedCreateManyInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNutritionNeedUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNutritionNeedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerMedicalConditionCreateInput = {
    medicalConditionValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerMedicalCondition: CustomerMedicalConditionCreateNestedOneWithoutIntermediateCustomerMedicalConditionsInput
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerMedicalConditionsInput
  }

  export type IntermediateCustomerMedicalConditionUncheckedCreateInput = {
    medicalConditionValue: string
    customerMedicalConditionId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerMedicalConditionUpdateInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerMedicalCondition?: CustomerMedicalConditionUpdateOneRequiredWithoutIntermediateCustomerMedicalConditionsInput
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerMedicalConditionsInput
  }

  export type IntermediateCustomerMedicalConditionUncheckedUpdateInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    customerMedicalConditionId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerMedicalConditionCreateManyInput = {
    medicalConditionValue: string
    customerMedicalConditionId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerMedicalConditionUpdateManyMutationInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerMedicalConditionUncheckedUpdateManyInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    customerMedicalConditionId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerMedicalConditionCreateInput = {
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerMedicalConditionInput
  }

  export type CustomerMedicalConditionUncheckedCreateInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerMedicalConditionInput
  }

  export type CustomerMedicalConditionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerMedicalConditionInput
  }

  export type CustomerMedicalConditionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerMedicalConditionInput
  }

  export type CustomerMedicalConditionCreateManyInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerMedicalConditionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerMedicalConditionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFoodTypeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productFoodType: ProductFoodTypeCreateNestedOneWithoutIntermediateCustomerFoodTypesInput
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerFoodTypesInput
  }

  export type IntermediateCustomerFoodTypeUncheckedCreateInput = {
    productFoodTypeId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFoodTypeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFoodType?: ProductFoodTypeUpdateOneRequiredWithoutIntermediateCustomerFoodTypesInput
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerFoodTypesInput
  }

  export type IntermediateCustomerFoodTypeUncheckedUpdateInput = {
    productFoodTypeId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFoodTypeCreateManyInput = {
    productFoodTypeId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFoodTypeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFoodTypeUncheckedUpdateManyInput = {
    productFoodTypeId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFoodTypeCreateInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutProductFoodTypeInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutProductFoodTypeInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutProductFoodTypeInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutProductFoodTypeInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeCreateManyInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductFoodTypeUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFoodTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductFoodTypeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productFoodType: ProductFoodTypeCreateNestedOneWithoutIntermediateProductFoodTypesInput
    product: ProductCreateNestedOneWithoutIntermediateProductFoodTypesInput
  }

  export type IntermediateProductFoodTypeUncheckedCreateInput = {
    productFoodTypeId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductFoodTypeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFoodType?: ProductFoodTypeUpdateOneRequiredWithoutIntermediateProductFoodTypesInput
    product?: ProductUpdateOneRequiredWithoutIntermediateProductFoodTypesInput
  }

  export type IntermediateProductFoodTypeUncheckedUpdateInput = {
    productFoodTypeId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductFoodTypeCreateManyInput = {
    productFoodTypeId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductFoodTypeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductFoodTypeUncheckedUpdateManyInput = {
    productFoodTypeId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateManyInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateInput = {
    src: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductImagesInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: number
    productId: number
    src: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUpdateInput = {
    src?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductImagesInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    src?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateManyInput = {
    id?: number
    productId: number
    src: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUpdateManyMutationInput = {
    src?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    src?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductCookingMethodCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntermediateProductCookingMethodsInput
    productCookingMethod: ProductCookingMethodCreateNestedOneWithoutIntermediateProductCookingMethodsInput
  }

  export type IntermediateProductCookingMethodUncheckedCreateInput = {
    productId: number
    productCookingMethodId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductCookingMethodUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntermediateProductCookingMethodsInput
    productCookingMethod?: ProductCookingMethodUpdateOneRequiredWithoutIntermediateProductCookingMethodsInput
  }

  export type IntermediateProductCookingMethodUncheckedUpdateInput = {
    productId?: IntFieldUpdateOperationsInput | number
    productCookingMethodId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductCookingMethodCreateManyInput = {
    productId: number
    productCookingMethodId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductCookingMethodUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductCookingMethodUncheckedUpdateManyInput = {
    productId?: IntFieldUpdateOperationsInput | number
    productCookingMethodId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerUnavailableCookingMethodsInput
    productCookingMethod: ProductCookingMethodCreateNestedOneWithoutIntermediateCustomerUnavailableCookingMethodsInput
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedCreateInput = {
    customerId: number
    productCookingMethodId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerUnavailableCookingMethodsInput
    productCookingMethod?: ProductCookingMethodUpdateOneRequiredWithoutIntermediateCustomerUnavailableCookingMethodsInput
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedUpdateInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    productCookingMethodId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateManyInput = {
    customerId: number
    productCookingMethodId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    productCookingMethodId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCookingMethodCreateInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductCookingMethodInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductCookingMethodInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductCookingMethodInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductCookingMethodInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodCreateManyInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCookingMethodUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCookingMethodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFlavorCreateInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutProductFlavorInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutProductFlavorInput
  }

  export type ProductFlavorUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductFlavorInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutProductFlavorInput
  }

  export type ProductFlavorUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutProductFlavorInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutProductFlavorInput
  }

  export type ProductFlavorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductFlavorInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutProductFlavorInput
  }

  export type ProductFlavorCreateManyInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductFlavorUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFlavorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVendorCreateInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutProductVendorInput
  }

  export type ProductVendorUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductVendorInput
  }

  export type ProductVendorUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutProductVendorInput
  }

  export type ProductVendorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductVendorInput
  }

  export type ProductVendorCreateManyInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVendorUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVendorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFlavorDislikeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productFlavor: ProductFlavorCreateNestedOneWithoutIntermediateCustomerFlavorDislikesInput
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerFlavorDislikesInput
  }

  export type IntermediateCustomerFlavorDislikeUncheckedCreateInput = {
    productFlavorId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFlavorDislikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFlavor?: ProductFlavorUpdateOneRequiredWithoutIntermediateCustomerFlavorDislikesInput
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerFlavorDislikesInput
  }

  export type IntermediateCustomerFlavorDislikeUncheckedUpdateInput = {
    productFlavorId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFlavorDislikeCreateManyInput = {
    productFlavorId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFlavorDislikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFlavorDislikeUncheckedUpdateManyInput = {
    productFlavorId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    label: string
    name: string
    src?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutProductCategoryInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    src?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutProductCategoryInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductCategoryInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    label: string
    name: string
    src?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerCategoryPreferenceCreateInput = {
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productCategory: ProductCategoryCreateNestedOneWithoutIntermediateCustomerCategoryPreferencesInput
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerCategoryPreferencesInput
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedCreateInput = {
    productCategoryId: number
    customerId: number
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerCategoryPreferenceUpdateInput = {
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productCategory?: ProductCategoryUpdateOneRequiredWithoutIntermediateCustomerCategoryPreferencesInput
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerCategoryPreferencesInput
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedUpdateInput = {
    productCategoryId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerCategoryPreferenceCreateManyInput = {
    productCategoryId: number
    customerId: number
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerCategoryPreferenceUpdateManyMutationInput = {
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedUpdateManyInput = {
    productCategoryId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductIngredientCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntermediateProductIngredientsInput
    productIngredient: ProductIngredientCreateNestedOneWithoutIntermediateProductIngredientsInput
  }

  export type IntermediateProductIngredientUncheckedCreateInput = {
    productId: number
    productIngredientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductIngredientUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntermediateProductIngredientsInput
    productIngredient?: ProductIngredientUpdateOneRequiredWithoutIntermediateProductIngredientsInput
  }

  export type IntermediateProductIngredientUncheckedUpdateInput = {
    productId?: IntFieldUpdateOperationsInput | number
    productIngredientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductIngredientCreateManyInput = {
    productId: number
    productIngredientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductIngredientUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductIngredientUncheckedUpdateManyInput = {
    productId?: IntFieldUpdateOperationsInput | number
    productIngredientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIngredientCreateInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductIngredientInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutProductIngredientInput
  }

  export type ProductIngredientUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductIngredientInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutProductIngredientInput
  }

  export type ProductIngredientUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductIngredientInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutProductIngredientInput
  }

  export type ProductIngredientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductIngredientInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutProductIngredientInput
  }

  export type ProductIngredientCreateManyInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductIngredientUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIngredientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerIngredientDislikeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productIngredient: ProductIngredientCreateNestedOneWithoutIntermediateCustomerIngredientDislikesInput
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerIngredientDislikesInput
  }

  export type IntermediateCustomerIngredientDislikeUncheckedCreateInput = {
    productIngredientId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerIngredientDislikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productIngredient?: ProductIngredientUpdateOneRequiredWithoutIntermediateCustomerIngredientDislikesInput
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerIngredientDislikesInput
  }

  export type IntermediateCustomerIngredientDislikeUncheckedUpdateInput = {
    productIngredientId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerIngredientDislikeCreateManyInput = {
    productIngredientId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerIngredientDislikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerIngredientDislikeUncheckedUpdateManyInput = {
    productIngredientId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductAllergenCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntermediateProductAllergensInput
    productAllergen: ProductAllergenCreateNestedOneWithoutIntermediateProductAllergensInput
  }

  export type IntermediateProductAllergenUncheckedCreateInput = {
    productId: number
    productAllergenId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductAllergenUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntermediateProductAllergensInput
    productAllergen?: ProductAllergenUpdateOneRequiredWithoutIntermediateProductAllergensInput
  }

  export type IntermediateProductAllergenUncheckedUpdateInput = {
    productId?: IntFieldUpdateOperationsInput | number
    productAllergenId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductAllergenCreateManyInput = {
    productId: number
    productAllergenId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductAllergenUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductAllergenUncheckedUpdateManyInput = {
    productId?: IntFieldUpdateOperationsInput | number
    productAllergenId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAllergenCreateInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductAllergenInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutProductAllergenInput
  }

  export type ProductAllergenUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductAllergenInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutProductAllergenInput
  }

  export type ProductAllergenUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductAllergenInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutProductAllergenInput
  }

  export type ProductAllergenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductAllergenInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutProductAllergenInput
  }

  export type ProductAllergenCreateManyInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductAllergenUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductAllergenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerAllergenCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerAllergensInput
    productAllergen: ProductAllergenCreateNestedOneWithoutIntermediateCustomerAllergensInput
  }

  export type IntermediateCustomerAllergenUncheckedCreateInput = {
    customerId: number
    productAllergenId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerAllergenUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerAllergensInput
    productAllergen?: ProductAllergenUpdateOneRequiredWithoutIntermediateCustomerAllergensInput
  }

  export type IntermediateCustomerAllergenUncheckedUpdateInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    productAllergenId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerAllergenCreateManyInput = {
    customerId: number
    productAllergenId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerAllergenUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerAllergenUncheckedUpdateManyInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    productAllergenId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductNutritionFactCreateInput = {
    quantity?: number | null
    servingSize?: number | null
    calories?: number | null
    totalFatG?: number | null
    saturatedFatG?: number | null
    transFatG?: number | null
    cholesteroleMg?: number | null
    sodiumMg?: number | null
    totalCarbohydrateG?: number | null
    dietaryFiberG?: number | null
    totalSugarG?: number | null
    addedSugarG?: number | null
    proteinG?: number | null
    sweet?: number | null
    sour?: number | null
    salty?: number | null
    bitter?: number | null
    spicy?: number | null
    texture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutProductNutritionFactInput
  }

  export type ProductNutritionFactUncheckedCreateInput = {
    id?: number
    productId: number
    quantity?: number | null
    servingSize?: number | null
    calories?: number | null
    totalFatG?: number | null
    saturatedFatG?: number | null
    transFatG?: number | null
    cholesteroleMg?: number | null
    sodiumMg?: number | null
    totalCarbohydrateG?: number | null
    dietaryFiberG?: number | null
    totalSugarG?: number | null
    addedSugarG?: number | null
    proteinG?: number | null
    sweet?: number | null
    sour?: number | null
    salty?: number | null
    bitter?: number | null
    spicy?: number | null
    texture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductNutritionFactUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    servingSize?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    totalFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    saturatedFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    transFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesteroleMg?: NullableFloatFieldUpdateOperationsInput | number | null
    sodiumMg?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCarbohydrateG?: NullableFloatFieldUpdateOperationsInput | number | null
    dietaryFiberG?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    addedSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    proteinG?: NullableFloatFieldUpdateOperationsInput | number | null
    sweet?: NullableIntFieldUpdateOperationsInput | number | null
    sour?: NullableIntFieldUpdateOperationsInput | number | null
    salty?: NullableIntFieldUpdateOperationsInput | number | null
    bitter?: NullableIntFieldUpdateOperationsInput | number | null
    spicy?: NullableIntFieldUpdateOperationsInput | number | null
    texture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductNutritionFactInput
  }

  export type ProductNutritionFactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    servingSize?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    totalFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    saturatedFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    transFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesteroleMg?: NullableFloatFieldUpdateOperationsInput | number | null
    sodiumMg?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCarbohydrateG?: NullableFloatFieldUpdateOperationsInput | number | null
    dietaryFiberG?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    addedSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    proteinG?: NullableFloatFieldUpdateOperationsInput | number | null
    sweet?: NullableIntFieldUpdateOperationsInput | number | null
    sour?: NullableIntFieldUpdateOperationsInput | number | null
    salty?: NullableIntFieldUpdateOperationsInput | number | null
    bitter?: NullableIntFieldUpdateOperationsInput | number | null
    spicy?: NullableIntFieldUpdateOperationsInput | number | null
    texture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductNutritionFactCreateManyInput = {
    id?: number
    productId: number
    quantity?: number | null
    servingSize?: number | null
    calories?: number | null
    totalFatG?: number | null
    saturatedFatG?: number | null
    transFatG?: number | null
    cholesteroleMg?: number | null
    sodiumMg?: number | null
    totalCarbohydrateG?: number | null
    dietaryFiberG?: number | null
    totalSugarG?: number | null
    addedSugarG?: number | null
    proteinG?: number | null
    sweet?: number | null
    sour?: number | null
    salty?: number | null
    bitter?: number | null
    spicy?: number | null
    texture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductNutritionFactUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    servingSize?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    totalFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    saturatedFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    transFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesteroleMg?: NullableFloatFieldUpdateOperationsInput | number | null
    sodiumMg?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCarbohydrateG?: NullableFloatFieldUpdateOperationsInput | number | null
    dietaryFiberG?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    addedSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    proteinG?: NullableFloatFieldUpdateOperationsInput | number | null
    sweet?: NullableIntFieldUpdateOperationsInput | number | null
    sour?: NullableIntFieldUpdateOperationsInput | number | null
    salty?: NullableIntFieldUpdateOperationsInput | number | null
    bitter?: NullableIntFieldUpdateOperationsInput | number | null
    spicy?: NullableIntFieldUpdateOperationsInput | number | null
    texture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductNutritionFactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    servingSize?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    totalFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    saturatedFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    transFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesteroleMg?: NullableFloatFieldUpdateOperationsInput | number | null
    sodiumMg?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCarbohydrateG?: NullableFloatFieldUpdateOperationsInput | number | null
    dietaryFiberG?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    addedSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    proteinG?: NullableFloatFieldUpdateOperationsInput | number | null
    sweet?: NullableIntFieldUpdateOperationsInput | number | null
    sour?: NullableIntFieldUpdateOperationsInput | number | null
    salty?: NullableIntFieldUpdateOperationsInput | number | null
    bitter?: NullableIntFieldUpdateOperationsInput | number | null
    spicy?: NullableIntFieldUpdateOperationsInput | number | null
    texture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProviderCreateInput = {
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutProductProviderInput
  }

  export type ProductProviderUncheckedCreateInput = {
    id?: number
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductProviderInput
  }

  export type ProductProviderUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutProductProviderInput
  }

  export type ProductProviderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductProviderInput
  }

  export type ProductProviderCreateManyInput = {
    id?: number
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProviderUpdateManyMutationInput = {
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProviderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyCreateInput = {
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUpdateManyWithoutSurveyInput
  }

  export type SurveyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedUpdateManyWithoutSurveyInput
  }

  export type SurveyCreateManyInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionCreateInput = {
    displayOrder?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    survey: SurveyCreateNestedOneWithoutIntermediateSurveyQuestionsInput
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutIntermediateSurveyQuestionsInput
  }

  export type IntermediateSurveyQuestionUncheckedCreateInput = {
    surveyId: number
    displayOrder?: number | null
    surveyQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionUpdateInput = {
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutIntermediateSurveyQuestionsInput
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutIntermediateSurveyQuestionsInput
  }

  export type IntermediateSurveyQuestionUncheckedUpdateInput = {
    surveyId?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionCreateManyInput = {
    surveyId: number
    displayOrder?: number | null
    surveyQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionUpdateManyMutationInput = {
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionUncheckedUpdateManyInput = {
    surveyId?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionCreateInput = {
    name: string
    label: string
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionCategory: QuestionCategoryCreateNestedOneWithoutSurveyQuestionsInput
    surveyQuestionAnswerType: SurveyQuestionAnswerTypeCreateNestedOneWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedCreateInput = {
    id?: number
    name: string
    label: string
    questionCategoryId: number
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    surveyQuestionAnswerTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionCategory?: QuestionCategoryUpdateOneRequiredWithoutSurveyQuestionsInput
    surveyQuestionAnswerType?: SurveyQuestionAnswerTypeUpdateOneRequiredWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    questionCategoryId?: IntFieldUpdateOperationsInput | number
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionAnswerTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionCreateManyInput = {
    id?: number
    name: string
    label: string
    questionCategoryId: number
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    surveyQuestionAnswerTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    questionCategoryId?: IntFieldUpdateOperationsInput | number
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionAnswerTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCategoryCreateInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestions?: SurveyQuestionCreateNestedManyWithoutQuestionCategoryInput
  }

  export type QuestionCategoryUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestions?: SurveyQuestionUncheckedCreateNestedManyWithoutQuestionCategoryInput
  }

  export type QuestionCategoryUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: SurveyQuestionUpdateManyWithoutQuestionCategoryInput
  }

  export type QuestionCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: SurveyQuestionUncheckedUpdateManyWithoutQuestionCategoryInput
  }

  export type QuestionCategoryCreateManyInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCategoryUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerTypeCreateInput = {
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestions?: SurveyQuestionCreateNestedManyWithoutSurveyQuestionAnswerTypeInput
  }

  export type SurveyQuestionAnswerTypeUncheckedCreateInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestions?: SurveyQuestionUncheckedCreateNestedManyWithoutSurveyQuestionAnswerTypeInput
  }

  export type SurveyQuestionAnswerTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: SurveyQuestionUpdateManyWithoutSurveyQuestionAnswerTypeInput
  }

  export type SurveyQuestionAnswerTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: SurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionAnswerTypeInput
  }

  export type SurveyQuestionAnswerTypeCreateManyInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionOptionCreateInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyQuestionOptionsInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutAnswerOptionInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionUncheckedCreateInput = {
    id?: number
    label: string
    name: string
    surveyQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutAnswerOptionInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionOptionsInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutAnswerOptionInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutAnswerOptionInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionCreateManyInput = {
    id?: number
    label: string
    name: string
    surveyQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionOptionUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerCreateInput = {
    responseId?: string | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionAnswerInput
    customer: CustomersCreateNestedOneWithoutSurveyQuestionAnswerInput
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionCreateNestedOneWithoutSurveyQuestionAnswerInput
    product?: ProductCreateNestedOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedCreateInput = {
    id?: number
    responseId?: string | null
    customerId: number
    surveyQuestionId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUpdateInput = {
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionAnswerInput
    customer?: CustomersUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionUpdateOneWithoutSurveyQuestionAnswerInput
    product?: ProductUpdateOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    answerSingleOptionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerCreateManyInput = {
    id?: number
    responseId?: string | null
    customerId: number
    surveyQuestionId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerUpdateManyMutationInput = {
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    answerSingleOptionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionAnswer: SurveyQuestionAnswerCreateNestedOneWithoutIntermediateSurveyQuestionAnswerProductInput
    surveyQuestionOption: SurveyQuestionOptionCreateNestedOneWithoutIntermediateSurveyQuestionAnswerProductInput
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedCreateInput = {
    surveyQuestionAnswerId: number
    surveyQuestionOptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateOneRequiredWithoutIntermediateSurveyQuestionAnswerProductInput
    surveyQuestionOption?: SurveyQuestionOptionUpdateOneRequiredWithoutIntermediateSurveyQuestionAnswerProductInput
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedUpdateInput = {
    surveyQuestionAnswerId?: IntFieldUpdateOperationsInput | number
    surveyQuestionOptionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductCreateManyInput = {
    surveyQuestionAnswerId: number
    surveyQuestionOptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyInput = {
    surveyQuestionAnswerId?: IntFieldUpdateOperationsInput | number
    surveyQuestionOptionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductDistanceCreateInput = {
    distance: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCustomerProductDistancesInput
    customer: CustomersCreateNestedOneWithoutCustomerProductDistancesInput
  }

  export type CustomerProductDistanceUncheckedCreateInput = {
    id?: number
    distance: number
    productId: number
    customerId: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductDistanceUpdateInput = {
    distance?: FloatFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCustomerProductDistancesInput
    customer?: CustomersUpdateOneRequiredWithoutCustomerProductDistancesInput
  }

  export type CustomerProductDistanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductDistanceCreateManyInput = {
    id?: number
    distance: number
    productId: number
    customerId: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductDistanceUpdateManyMutationInput = {
    distance?: FloatFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductDistanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBoxItemsCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCustomerBoxItemsInput
    customer: CustomersCreateNestedOneWithoutCustomerBoxItemsInput
  }

  export type CustomerBoxItemsUncheckedCreateInput = {
    id?: number
    productId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerBoxItemsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCustomerBoxItemsInput
    customer?: CustomersUpdateOneRequiredWithoutCustomerBoxItemsInput
  }

  export type CustomerBoxItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBoxItemsCreateManyInput = {
    id?: number
    productId: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerBoxItemsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBoxItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueuedShopifyOrderCreateInput = {
    orderName: string
    status?: QueueStatus
    scheduledAt: string
    orderedAt?: string | null
    fulfilledAt?: string | null
    customer: CustomersCreateNestedOneWithoutQueuedShopifyOrderInput
  }

  export type QueuedShopifyOrderUncheckedCreateInput = {
    id?: number
    customerId: number
    orderName: string
    status?: QueueStatus
    scheduledAt: string
    orderedAt?: string | null
    fulfilledAt?: string | null
  }

  export type QueuedShopifyOrderUpdateInput = {
    orderName?: StringFieldUpdateOperationsInput | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | QueueStatus
    scheduledAt?: StringFieldUpdateOperationsInput | string
    orderedAt?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomersUpdateOneRequiredWithoutQueuedShopifyOrderInput
  }

  export type QueuedShopifyOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    orderName?: StringFieldUpdateOperationsInput | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | QueueStatus
    scheduledAt?: StringFieldUpdateOperationsInput | string
    orderedAt?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QueuedShopifyOrderCreateManyInput = {
    id?: number
    customerId: number
    orderName: string
    status?: QueueStatus
    scheduledAt: string
    orderedAt?: string | null
    fulfilledAt?: string | null
  }

  export type QueuedShopifyOrderUpdateManyMutationInput = {
    orderName?: StringFieldUpdateOperationsInput | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | QueueStatus
    scheduledAt?: StringFieldUpdateOperationsInput | string
    orderedAt?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QueuedShopifyOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    orderName?: StringFieldUpdateOperationsInput | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | QueueStatus
    scheduledAt?: StringFieldUpdateOperationsInput | string
    orderedAt?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PractitionerCreateInput = {
    uuid: string
    email: string
    phoneNumber?: string | null
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerBox?: PractitionerBoxCreateNestedManyWithoutPractitionerInput
    practitionerSocialMedia?: PractitionerSocialMediaCreateNestedOneWithoutPractitionerInput
  }

  export type PractitionerUncheckedCreateInput = {
    id?: number
    uuid: string
    email: string
    phoneNumber?: string | null
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerBox?: PractitionerBoxUncheckedCreateNestedManyWithoutPractitionerInput
    practitionerSocialMedia?: PractitionerSocialMediaUncheckedCreateNestedOneWithoutPractitionerInput
  }

  export type PractitionerUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerBox?: PractitionerBoxUpdateManyWithoutPractitionerInput
    practitionerSocialMedia?: PractitionerSocialMediaUpdateOneWithoutPractitionerInput
  }

  export type PractitionerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerBox?: PractitionerBoxUncheckedUpdateManyWithoutPractitionerInput
    practitionerSocialMedia?: PractitionerSocialMediaUncheckedUpdateOneWithoutPractitionerInput
  }

  export type PractitionerCreateManyInput = {
    id?: number
    uuid: string
    email: string
    phoneNumber?: string | null
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerSocialMediaCreateInput = {
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practitioner: PractitionerCreateNestedOneWithoutPractitionerSocialMediaInput
  }

  export type PractitionerSocialMediaUncheckedCreateInput = {
    id?: number
    practitionerId: number
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerSocialMediaUpdateInput = {
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitioner?: PractitionerUpdateOneRequiredWithoutPractitionerSocialMediaInput
  }

  export type PractitionerSocialMediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    practitionerId?: IntFieldUpdateOperationsInput | number
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerSocialMediaCreateManyInput = {
    id?: number
    practitionerId: number
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerSocialMediaUpdateManyMutationInput = {
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerSocialMediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    practitionerId?: IntFieldUpdateOperationsInput | number
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerBoxCreateInput = {
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    practitioner: PractitionerCreateNestedOneWithoutPractitionerBoxInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedCreateInput = {
    id?: number
    practitionerId: number
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitioner?: PractitionerUpdateOneRequiredWithoutPractitionerBoxInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    practitionerId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxCreateManyInput = {
    id?: number
    practitionerId: number
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerBoxUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerBoxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    practitionerId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediatePractitionerBoxProductCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerBox: PractitionerBoxCreateNestedOneWithoutIntermediatePractitionerBoxProductInput
    product: ProductCreateNestedOneWithoutIntermediatePractitionerBoxProductInput
  }

  export type IntermediatePractitionerBoxProductUncheckedCreateInput = {
    practitionerBoxId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediatePractitionerBoxProductUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerBox?: PractitionerBoxUpdateOneRequiredWithoutIntermediatePractitionerBoxProductInput
    product?: ProductUpdateOneRequiredWithoutIntermediatePractitionerBoxProductInput
  }

  export type IntermediatePractitionerBoxProductUncheckedUpdateInput = {
    practitionerBoxId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediatePractitionerBoxProductCreateManyInput = {
    practitionerBoxId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediatePractitionerBoxProductUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediatePractitionerBoxProductUncheckedUpdateManyInput = {
    practitionerBoxId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerCustomerOrderHistoryCreateInput = {
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutPractitionerCustomerOrderHistoryInput
    practitionerBox: PractitionerBoxCreateNestedOneWithoutPractitionerCustomerOrderHistoryInput
  }

  export type PractitionerCustomerOrderHistoryUncheckedCreateInput = {
    id?: number
    customerId: number
    practitionerBoxId: number
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerCustomerOrderHistoryUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutPractitionerCustomerOrderHistoryInput
    practitionerBox?: PractitionerBoxUpdateOneRequiredWithoutPractitionerCustomerOrderHistoryInput
  }

  export type PractitionerCustomerOrderHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    practitionerBoxId?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerCustomerOrderHistoryCreateManyInput = {
    id?: number
    customerId: number
    practitionerBoxId: number
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerCustomerOrderHistoryUpdateManyMutationInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerCustomerOrderHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    practitionerBoxId?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DiscoveriesCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    typeform_id?: SortOrder
    BMR?: SortOrder
    carbs_macronutrients?: SortOrder
    protein_macronutrients?: SortOrder
    fat_macronutrients?: SortOrder
    carbs_per_meal?: SortOrder
    protein_per_meal?: SortOrder
    fat_per_meal?: SortOrder
    calorie_per_meal?: SortOrder
  }

  export type DiscoveriesAvgOrderByAggregateInput = {
    id?: SortOrder
    BMR?: SortOrder
    carbs_macronutrients?: SortOrder
    protein_macronutrients?: SortOrder
    fat_macronutrients?: SortOrder
    carbs_per_meal?: SortOrder
    protein_per_meal?: SortOrder
    fat_per_meal?: SortOrder
    calorie_per_meal?: SortOrder
  }

  export type DiscoveriesMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    typeform_id?: SortOrder
    BMR?: SortOrder
    carbs_macronutrients?: SortOrder
    protein_macronutrients?: SortOrder
    fat_macronutrients?: SortOrder
    carbs_per_meal?: SortOrder
    protein_per_meal?: SortOrder
    fat_per_meal?: SortOrder
    calorie_per_meal?: SortOrder
  }

  export type DiscoveriesMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    typeform_id?: SortOrder
    BMR?: SortOrder
    carbs_macronutrients?: SortOrder
    protein_macronutrients?: SortOrder
    fat_macronutrients?: SortOrder
    carbs_per_meal?: SortOrder
    protein_per_meal?: SortOrder
    fat_per_meal?: SortOrder
    calorie_per_meal?: SortOrder
  }

  export type DiscoveriesSumOrderByAggregateInput = {
    id?: SortOrder
    BMR?: SortOrder
    carbs_macronutrients?: SortOrder
    protein_macronutrients?: SortOrder
    fat_macronutrients?: SortOrder
    carbs_per_meal?: SortOrder
    protein_per_meal?: SortOrder
    fat_per_meal?: SortOrder
    calorie_per_meal?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type IntermediateCustomerNutritionNeedListRelationFilter = {
    every?: IntermediateCustomerNutritionNeedWhereInput
    some?: IntermediateCustomerNutritionNeedWhereInput
    none?: IntermediateCustomerNutritionNeedWhereInput
  }

  export type IntermediateCustomerMedicalConditionListRelationFilter = {
    every?: IntermediateCustomerMedicalConditionWhereInput
    some?: IntermediateCustomerMedicalConditionWhereInput
    none?: IntermediateCustomerMedicalConditionWhereInput
  }

  export type IntermediateCustomerAllergenListRelationFilter = {
    every?: IntermediateCustomerAllergenWhereInput
    some?: IntermediateCustomerAllergenWhereInput
    none?: IntermediateCustomerAllergenWhereInput
  }

  export type SurveyQuestionAnswerListRelationFilter = {
    every?: SurveyQuestionAnswerWhereInput
    some?: SurveyQuestionAnswerWhereInput
    none?: SurveyQuestionAnswerWhereInput
  }

  export type CustomerProductDistanceListRelationFilter = {
    every?: CustomerProductDistanceWhereInput
    some?: CustomerProductDistanceWhereInput
    none?: CustomerProductDistanceWhereInput
  }

  export type CustomerBoxItemsListRelationFilter = {
    every?: CustomerBoxItemsWhereInput
    some?: CustomerBoxItemsWhereInput
    none?: CustomerBoxItemsWhereInput
  }

  export type QueuedShopifyOrderListRelationFilter = {
    every?: QueuedShopifyOrderWhereInput
    some?: QueuedShopifyOrderWhereInput
    none?: QueuedShopifyOrderWhereInput
  }

  export type IntermediateCustomerFlavorDislikeListRelationFilter = {
    every?: IntermediateCustomerFlavorDislikeWhereInput
    some?: IntermediateCustomerFlavorDislikeWhereInput
    none?: IntermediateCustomerFlavorDislikeWhereInput
  }

  export type IntermediateCustomerCategoryPreferenceListRelationFilter = {
    every?: IntermediateCustomerCategoryPreferenceWhereInput
    some?: IntermediateCustomerCategoryPreferenceWhereInput
    none?: IntermediateCustomerCategoryPreferenceWhereInput
  }

  export type IntermediateCustomerIngredientDislikeListRelationFilter = {
    every?: IntermediateCustomerIngredientDislikeWhereInput
    some?: IntermediateCustomerIngredientDislikeWhereInput
    none?: IntermediateCustomerIngredientDislikeWhereInput
  }

  export type IntermediateCustomerFoodTypeListRelationFilter = {
    every?: IntermediateCustomerFoodTypeWhereInput
    some?: IntermediateCustomerFoodTypeWhereInput
    none?: IntermediateCustomerFoodTypeWhereInput
  }

  export type IntermediateCustomerUnavailableCookingMethodListRelationFilter = {
    every?: IntermediateCustomerUnavailableCookingMethodWhereInput
    some?: IntermediateCustomerUnavailableCookingMethodWhereInput
    none?: IntermediateCustomerUnavailableCookingMethodWhereInput
  }

  export type PractitionerCustomerOrderHistoryListRelationFilter = {
    every?: PractitionerCustomerOrderHistoryWhereInput
    some?: PractitionerCustomerOrderHistoryWhereInput
    none?: PractitionerCustomerOrderHistoryWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntermediateCustomerNutritionNeedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateCustomerMedicalConditionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateCustomerAllergenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyQuestionAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerProductDistanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerBoxItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueuedShopifyOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateCustomerFlavorDislikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateCustomerCategoryPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateCustomerIngredientDislikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateCustomerFoodTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateCustomerUnavailableCookingMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PractitionerCustomerOrderHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    gender?: SortOrder
    activeLevel?: SortOrder
    mealsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    mealsPerDay?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    gender?: SortOrder
    activeLevel?: SortOrder
    mealsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    gender?: SortOrder
    activeLevel?: SortOrder
    mealsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    mealsPerDay?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type CustomerNutritionNeedRelationFilter = {
    is?: CustomerNutritionNeedWhereInput
    isNot?: CustomerNutritionNeedWhereInput
  }

  export type CustomersRelationFilter = {
    is?: CustomersWhereInput
    isNot?: CustomersWhereInput
  }

  export type IntermediateCustomerNutritionNeedCustomerNutritionNeedIdCustomerIdCompoundUniqueInput = {
    customerNutritionNeedId: number
    customerId: number
  }

  export type IntermediateCustomerNutritionNeedCountOrderByAggregateInput = {
    customerNutritionNeedId?: SortOrder
    customerId?: SortOrder
    nutritionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerNutritionNeedAvgOrderByAggregateInput = {
    customerNutritionNeedId?: SortOrder
    customerId?: SortOrder
    nutritionValue?: SortOrder
  }

  export type IntermediateCustomerNutritionNeedMaxOrderByAggregateInput = {
    customerNutritionNeedId?: SortOrder
    customerId?: SortOrder
    nutritionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerNutritionNeedMinOrderByAggregateInput = {
    customerNutritionNeedId?: SortOrder
    customerId?: SortOrder
    nutritionValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerNutritionNeedSumOrderByAggregateInput = {
    customerNutritionNeedId?: SortOrder
    customerId?: SortOrder
    nutritionValue?: SortOrder
  }

  export type CustomerNutritionNeedCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerNutritionNeedAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerNutritionNeedMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerNutritionNeedMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerNutritionNeedSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMedicalConditionRelationFilter = {
    is?: CustomerMedicalConditionWhereInput
    isNot?: CustomerMedicalConditionWhereInput
  }

  export type IntermediateCustomerMedicalConditionCustomerMedicalConditionIdCustomerIdCompoundUniqueInput = {
    customerMedicalConditionId: number
    customerId: number
  }

  export type IntermediateCustomerMedicalConditionCountOrderByAggregateInput = {
    medicalConditionValue?: SortOrder
    customerMedicalConditionId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerMedicalConditionAvgOrderByAggregateInput = {
    customerMedicalConditionId?: SortOrder
    customerId?: SortOrder
  }

  export type IntermediateCustomerMedicalConditionMaxOrderByAggregateInput = {
    medicalConditionValue?: SortOrder
    customerMedicalConditionId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerMedicalConditionMinOrderByAggregateInput = {
    medicalConditionValue?: SortOrder
    customerMedicalConditionId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerMedicalConditionSumOrderByAggregateInput = {
    customerMedicalConditionId?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerMedicalConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMedicalConditionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMedicalConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMedicalConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMedicalConditionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductFoodTypeRelationFilter = {
    is?: ProductFoodTypeWhereInput
    isNot?: ProductFoodTypeWhereInput
  }

  export type IntermediateCustomerFoodTypeProductFoodTypeIdCustomerIdCompoundUniqueInput = {
    productFoodTypeId: number
    customerId: number
  }

  export type IntermediateCustomerFoodTypeCountOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerFoodTypeAvgOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    customerId?: SortOrder
  }

  export type IntermediateCustomerFoodTypeMaxOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerFoodTypeMinOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerFoodTypeSumOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    customerId?: SortOrder
  }

  export type IntermediateProductFoodTypeListRelationFilter = {
    every?: IntermediateProductFoodTypeWhereInput
    some?: IntermediateProductFoodTypeWhereInput
    none?: IntermediateProductFoodTypeWhereInput
  }

  export type IntermediateProductFoodTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductFoodTypeCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFoodTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductFoodTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFoodTypeMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFoodTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type IntermediateProductFoodTypeProductFoodTypeIdProductIdCompoundUniqueInput = {
    productFoodTypeId: number
    productId: number
  }

  export type IntermediateProductFoodTypeCountOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductFoodTypeAvgOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    productId?: SortOrder
  }

  export type IntermediateProductFoodTypeMaxOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductFoodTypeMinOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductFoodTypeSumOrderByAggregateInput = {
    productFoodTypeId?: SortOrder
    productId?: SortOrder
  }

  export type EnumActiveStatusNullableFilter = {
    equals?: ActiveStatus | null
    in?: Enumerable<ActiveStatus> | null
    notIn?: Enumerable<ActiveStatus> | null
    not?: NestedEnumActiveStatusNullableFilter | ActiveStatus | null
  }

  export type ProductProviderRelationFilter = {
    is?: ProductProviderWhereInput
    isNot?: ProductProviderWhereInput
  }

  export type ProductCategoryRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type ProductFlavorRelationFilter = {
    is?: ProductFlavorWhereInput
    isNot?: ProductFlavorWhereInput
  }

  export type ProductVendorRelationFilter = {
    is?: ProductVendorWhereInput | null
    isNot?: ProductVendorWhereInput | null
  }

  export type IntermediateProductIngredientListRelationFilter = {
    every?: IntermediateProductIngredientWhereInput
    some?: IntermediateProductIngredientWhereInput
    none?: IntermediateProductIngredientWhereInput
  }

  export type IntermediateProductAllergenListRelationFilter = {
    every?: IntermediateProductAllergenWhereInput
    some?: IntermediateProductAllergenWhereInput
    none?: IntermediateProductAllergenWhereInput
  }

  export type IntermediateProductCookingMethodListRelationFilter = {
    every?: IntermediateProductCookingMethodWhereInput
    some?: IntermediateProductCookingMethodWhereInput
    none?: IntermediateProductCookingMethodWhereInput
  }

  export type IntermediatePractitionerBoxProductListRelationFilter = {
    every?: IntermediatePractitionerBoxProductWhereInput
    some?: IntermediatePractitionerBoxProductWhereInput
    none?: IntermediatePractitionerBoxProductWhereInput
  }

  export type ProductNutritionFactRelationFilter = {
    is?: ProductNutritionFactWhereInput | null
    isNot?: ProductNutritionFactWhereInput | null
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type IntermediateProductIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateProductAllergenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediateProductCookingMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntermediatePractitionerBoxProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    activeStatus?: SortOrder
    name?: SortOrder
    label?: SortOrder
    ingredientLabel?: SortOrder
    allergenLabel?: SortOrder
    expertComment?: SortOrder
    productProviderId?: SortOrder
    productCategoryId?: SortOrder
    productFlavorId?: SortOrder
    productVendorId?: SortOrder
    externalSku?: SortOrder
    upcCode?: SortOrder
    MSP?: SortOrder
    WSP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    productProviderId?: SortOrder
    productCategoryId?: SortOrder
    productFlavorId?: SortOrder
    productVendorId?: SortOrder
    MSP?: SortOrder
    WSP?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    activeStatus?: SortOrder
    name?: SortOrder
    label?: SortOrder
    ingredientLabel?: SortOrder
    allergenLabel?: SortOrder
    expertComment?: SortOrder
    productProviderId?: SortOrder
    productCategoryId?: SortOrder
    productFlavorId?: SortOrder
    productVendorId?: SortOrder
    externalSku?: SortOrder
    upcCode?: SortOrder
    MSP?: SortOrder
    WSP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    activeStatus?: SortOrder
    name?: SortOrder
    label?: SortOrder
    ingredientLabel?: SortOrder
    allergenLabel?: SortOrder
    expertComment?: SortOrder
    productProviderId?: SortOrder
    productCategoryId?: SortOrder
    productFlavorId?: SortOrder
    productVendorId?: SortOrder
    externalSku?: SortOrder
    upcCode?: SortOrder
    MSP?: SortOrder
    WSP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    productProviderId?: SortOrder
    productCategoryId?: SortOrder
    productFlavorId?: SortOrder
    productVendorId?: SortOrder
    MSP?: SortOrder
    WSP?: SortOrder
  }

  export type EnumActiveStatusNullableWithAggregatesFilter = {
    equals?: ActiveStatus | null
    in?: Enumerable<ActiveStatus> | null
    notIn?: Enumerable<ActiveStatus> | null
    not?: NestedEnumActiveStatusNullableWithAggregatesFilter | ActiveStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumActiveStatusNullableFilter
    _max?: NestedEnumActiveStatusNullableFilter
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    src?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    position?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    src?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    src?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    position?: SortOrder
  }

  export type ProductCookingMethodRelationFilter = {
    is?: ProductCookingMethodWhereInput
    isNot?: ProductCookingMethodWhereInput
  }

  export type IntermediateProductCookingMethodProductIdProductCookingMethodIdCompoundUniqueInput = {
    productId: number
    productCookingMethodId: number
  }

  export type IntermediateProductCookingMethodCountOrderByAggregateInput = {
    productId?: SortOrder
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductCookingMethodAvgOrderByAggregateInput = {
    productId?: SortOrder
    productCookingMethodId?: SortOrder
  }

  export type IntermediateProductCookingMethodMaxOrderByAggregateInput = {
    productId?: SortOrder
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductCookingMethodMinOrderByAggregateInput = {
    productId?: SortOrder
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductCookingMethodSumOrderByAggregateInput = {
    productId?: SortOrder
    productCookingMethodId?: SortOrder
  }

  export type IntermediateCustomerUnavailableCookingMethodCustomerIdProductCookingMethodIdCompoundUniqueInput = {
    customerId: number
    productCookingMethodId: number
  }

  export type IntermediateCustomerUnavailableCookingMethodCountOrderByAggregateInput = {
    customerId?: SortOrder
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerUnavailableCookingMethodAvgOrderByAggregateInput = {
    customerId?: SortOrder
    productCookingMethodId?: SortOrder
  }

  export type IntermediateCustomerUnavailableCookingMethodMaxOrderByAggregateInput = {
    customerId?: SortOrder
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerUnavailableCookingMethodMinOrderByAggregateInput = {
    customerId?: SortOrder
    productCookingMethodId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerUnavailableCookingMethodSumOrderByAggregateInput = {
    customerId?: SortOrder
    productCookingMethodId?: SortOrder
  }

  export type ProductCookingMethodCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCookingMethodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCookingMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCookingMethodMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCookingMethodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductFlavorCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFlavorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductFlavorMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFlavorMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductFlavorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductVendorCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVendorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductVendorMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVendorMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVendorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntermediateCustomerFlavorDislikeProductFlavorIdCustomerIdCompoundUniqueInput = {
    productFlavorId: number
    customerId: number
  }

  export type IntermediateCustomerFlavorDislikeCountOrderByAggregateInput = {
    productFlavorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerFlavorDislikeAvgOrderByAggregateInput = {
    productFlavorId?: SortOrder
    customerId?: SortOrder
  }

  export type IntermediateCustomerFlavorDislikeMaxOrderByAggregateInput = {
    productFlavorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerFlavorDislikeMinOrderByAggregateInput = {
    productFlavorId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerFlavorDislikeSumOrderByAggregateInput = {
    productFlavorId?: SortOrder
    customerId?: SortOrder
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    src?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    src?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    src?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntermediateCustomerCategoryPreferenceProductCategoryIdCustomerIdCompoundUniqueInput = {
    productCategoryId: number
    customerId: number
  }

  export type IntermediateCustomerCategoryPreferenceCountOrderByAggregateInput = {
    productCategoryId?: SortOrder
    customerId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerCategoryPreferenceAvgOrderByAggregateInput = {
    productCategoryId?: SortOrder
    customerId?: SortOrder
    rank?: SortOrder
  }

  export type IntermediateCustomerCategoryPreferenceMaxOrderByAggregateInput = {
    productCategoryId?: SortOrder
    customerId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerCategoryPreferenceMinOrderByAggregateInput = {
    productCategoryId?: SortOrder
    customerId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerCategoryPreferenceSumOrderByAggregateInput = {
    productCategoryId?: SortOrder
    customerId?: SortOrder
    rank?: SortOrder
  }

  export type ProductIngredientRelationFilter = {
    is?: ProductIngredientWhereInput
    isNot?: ProductIngredientWhereInput
  }

  export type IntermediateProductIngredientProductIdProductIngredientIdCompoundUniqueInput = {
    productId: number
    productIngredientId: number
  }

  export type IntermediateProductIngredientCountOrderByAggregateInput = {
    productId?: SortOrder
    productIngredientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductIngredientAvgOrderByAggregateInput = {
    productId?: SortOrder
    productIngredientId?: SortOrder
  }

  export type IntermediateProductIngredientMaxOrderByAggregateInput = {
    productId?: SortOrder
    productIngredientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductIngredientMinOrderByAggregateInput = {
    productId?: SortOrder
    productIngredientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductIngredientSumOrderByAggregateInput = {
    productId?: SortOrder
    productIngredientId?: SortOrder
  }

  export type ProductIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductIngredientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductIngredientSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntermediateCustomerIngredientDislikeProductIngredientIdCustomerIdCompoundUniqueInput = {
    productIngredientId: number
    customerId: number
  }

  export type IntermediateCustomerIngredientDislikeCountOrderByAggregateInput = {
    productIngredientId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerIngredientDislikeAvgOrderByAggregateInput = {
    productIngredientId?: SortOrder
    customerId?: SortOrder
  }

  export type IntermediateCustomerIngredientDislikeMaxOrderByAggregateInput = {
    productIngredientId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerIngredientDislikeMinOrderByAggregateInput = {
    productIngredientId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerIngredientDislikeSumOrderByAggregateInput = {
    productIngredientId?: SortOrder
    customerId?: SortOrder
  }

  export type ProductAllergenRelationFilter = {
    is?: ProductAllergenWhereInput
    isNot?: ProductAllergenWhereInput
  }

  export type IntermediateProductAllergenProductIdProductAllergenIdCompoundUniqueInput = {
    productId: number
    productAllergenId: number
  }

  export type IntermediateProductAllergenCountOrderByAggregateInput = {
    productId?: SortOrder
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductAllergenAvgOrderByAggregateInput = {
    productId?: SortOrder
    productAllergenId?: SortOrder
  }

  export type IntermediateProductAllergenMaxOrderByAggregateInput = {
    productId?: SortOrder
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductAllergenMinOrderByAggregateInput = {
    productId?: SortOrder
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateProductAllergenSumOrderByAggregateInput = {
    productId?: SortOrder
    productAllergenId?: SortOrder
  }

  export type ProductAllergenCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAllergenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductAllergenMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAllergenMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAllergenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntermediateCustomerAllergenCustomerIdProductAllergenIdCompoundUniqueInput = {
    customerId: number
    productAllergenId: number
  }

  export type IntermediateCustomerAllergenCountOrderByAggregateInput = {
    customerId?: SortOrder
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerAllergenAvgOrderByAggregateInput = {
    customerId?: SortOrder
    productAllergenId?: SortOrder
  }

  export type IntermediateCustomerAllergenMaxOrderByAggregateInput = {
    customerId?: SortOrder
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerAllergenMinOrderByAggregateInput = {
    customerId?: SortOrder
    productAllergenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateCustomerAllergenSumOrderByAggregateInput = {
    customerId?: SortOrder
    productAllergenId?: SortOrder
  }

  export type ProductNutritionFactCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    servingSize?: SortOrder
    calories?: SortOrder
    totalFatG?: SortOrder
    saturatedFatG?: SortOrder
    transFatG?: SortOrder
    cholesteroleMg?: SortOrder
    sodiumMg?: SortOrder
    totalCarbohydrateG?: SortOrder
    dietaryFiberG?: SortOrder
    totalSugarG?: SortOrder
    addedSugarG?: SortOrder
    proteinG?: SortOrder
    sweet?: SortOrder
    sour?: SortOrder
    salty?: SortOrder
    bitter?: SortOrder
    spicy?: SortOrder
    texture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductNutritionFactAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    servingSize?: SortOrder
    calories?: SortOrder
    totalFatG?: SortOrder
    saturatedFatG?: SortOrder
    transFatG?: SortOrder
    cholesteroleMg?: SortOrder
    sodiumMg?: SortOrder
    totalCarbohydrateG?: SortOrder
    dietaryFiberG?: SortOrder
    totalSugarG?: SortOrder
    addedSugarG?: SortOrder
    proteinG?: SortOrder
    sweet?: SortOrder
    sour?: SortOrder
    salty?: SortOrder
    bitter?: SortOrder
    spicy?: SortOrder
  }

  export type ProductNutritionFactMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    servingSize?: SortOrder
    calories?: SortOrder
    totalFatG?: SortOrder
    saturatedFatG?: SortOrder
    transFatG?: SortOrder
    cholesteroleMg?: SortOrder
    sodiumMg?: SortOrder
    totalCarbohydrateG?: SortOrder
    dietaryFiberG?: SortOrder
    totalSugarG?: SortOrder
    addedSugarG?: SortOrder
    proteinG?: SortOrder
    sweet?: SortOrder
    sour?: SortOrder
    salty?: SortOrder
    bitter?: SortOrder
    spicy?: SortOrder
    texture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductNutritionFactMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    servingSize?: SortOrder
    calories?: SortOrder
    totalFatG?: SortOrder
    saturatedFatG?: SortOrder
    transFatG?: SortOrder
    cholesteroleMg?: SortOrder
    sodiumMg?: SortOrder
    totalCarbohydrateG?: SortOrder
    dietaryFiberG?: SortOrder
    totalSugarG?: SortOrder
    addedSugarG?: SortOrder
    proteinG?: SortOrder
    sweet?: SortOrder
    sour?: SortOrder
    salty?: SortOrder
    bitter?: SortOrder
    spicy?: SortOrder
    texture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductNutritionFactSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    servingSize?: SortOrder
    calories?: SortOrder
    totalFatG?: SortOrder
    saturatedFatG?: SortOrder
    transFatG?: SortOrder
    cholesteroleMg?: SortOrder
    sodiumMg?: SortOrder
    totalCarbohydrateG?: SortOrder
    dietaryFiberG?: SortOrder
    totalSugarG?: SortOrder
    addedSugarG?: SortOrder
    proteinG?: SortOrder
    sweet?: SortOrder
    sour?: SortOrder
    salty?: SortOrder
    bitter?: SortOrder
    spicy?: SortOrder
  }

  export type ProductProviderCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProviderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProviderMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductProviderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntermediateSurveyQuestionListRelationFilter = {
    every?: IntermediateSurveyQuestionWhereInput
    some?: IntermediateSurveyQuestionWhereInput
    none?: IntermediateSurveyQuestionWhereInput
  }

  export type IntermediateSurveyQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SurveyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SurveyRelationFilter = {
    is?: SurveyWhereInput
    isNot?: SurveyWhereInput
  }

  export type SurveyQuestionRelationFilter = {
    is?: SurveyQuestionWhereInput
    isNot?: SurveyQuestionWhereInput
  }

  export type IntermediateSurveyQuestionSurveyIdSurveyQuestionIdCompoundUniqueInput = {
    surveyId: number
    surveyQuestionId: number
  }

  export type IntermediateSurveyQuestionCountOrderByAggregateInput = {
    surveyId?: SortOrder
    displayOrder?: SortOrder
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateSurveyQuestionAvgOrderByAggregateInput = {
    surveyId?: SortOrder
    displayOrder?: SortOrder
    surveyQuestionId?: SortOrder
  }

  export type IntermediateSurveyQuestionMaxOrderByAggregateInput = {
    surveyId?: SortOrder
    displayOrder?: SortOrder
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateSurveyQuestionMinOrderByAggregateInput = {
    surveyId?: SortOrder
    displayOrder?: SortOrder
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateSurveyQuestionSumOrderByAggregateInput = {
    surveyId?: SortOrder
    displayOrder?: SortOrder
    surveyQuestionId?: SortOrder
  }

  export type QuestionCategoryRelationFilter = {
    is?: QuestionCategoryWhereInput
    isNot?: QuestionCategoryWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type SurveyQuestionAnswerTypeRelationFilter = {
    is?: SurveyQuestionAnswerTypeWhereInput
    isNot?: SurveyQuestionAnswerTypeWhereInput
  }

  export type SurveyQuestionOptionListRelationFilter = {
    every?: SurveyQuestionOptionWhereInput
    some?: SurveyQuestionOptionWhereInput
    none?: SurveyQuestionOptionWhereInput
  }

  export type SurveyQuestionOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    questionCategoryId?: SortOrder
    mustBeAnswered?: SortOrder
    instruction?: SortOrder
    placeholder?: SortOrder
    surveyQuestionAnswerTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    questionCategoryId?: SortOrder
    surveyQuestionAnswerTypeId?: SortOrder
  }

  export type SurveyQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    questionCategoryId?: SortOrder
    mustBeAnswered?: SortOrder
    instruction?: SortOrder
    placeholder?: SortOrder
    surveyQuestionAnswerTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    questionCategoryId?: SortOrder
    mustBeAnswered?: SortOrder
    instruction?: SortOrder
    placeholder?: SortOrder
    surveyQuestionAnswerTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    questionCategoryId?: SortOrder
    surveyQuestionAnswerTypeId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type SurveyQuestionListRelationFilter = {
    every?: SurveyQuestionWhereInput
    some?: SurveyQuestionWhereInput
    none?: SurveyQuestionWhereInput
  }

  export type SurveyQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuestionCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SurveyQuestionAnswerTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAnswerTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SurveyQuestionAnswerTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAnswerTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAnswerTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntermediateSurveyQuestionAnswerProductListRelationFilter = {
    every?: IntermediateSurveyQuestionAnswerProductWhereInput
    some?: IntermediateSurveyQuestionAnswerProductWhereInput
    none?: IntermediateSurveyQuestionAnswerProductWhereInput
  }

  export type IntermediateSurveyQuestionAnswerProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyQuestionOptionQuestionOptionIdentifierCompoundUniqueInput = {
    name: string
    surveyQuestionId: number
  }

  export type SurveyQuestionOptionCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    surveyQuestionId?: SortOrder
  }

  export type SurveyQuestionOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionOptionMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    name?: SortOrder
    surveyQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionOptionSumOrderByAggregateInput = {
    id?: SortOrder
    surveyQuestionId?: SortOrder
  }

  export type SurveyQuestionOptionRelationFilter = {
    is?: SurveyQuestionOptionWhereInput
    isNot?: SurveyQuestionOptionWhereInput
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type SurveyQuestionAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    customerId?: SortOrder
    surveyQuestionId?: SortOrder
    answerSingleOptionId?: SortOrder
    answerNumeric?: SortOrder
    answerText?: SortOrder
    answerBool?: SortOrder
    reason?: SortOrder
    title?: SortOrder
    content?: SortOrder
    answerCount?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    surveyQuestionId?: SortOrder
    answerSingleOptionId?: SortOrder
    answerNumeric?: SortOrder
    answerCount?: SortOrder
    productId?: SortOrder
  }

  export type SurveyQuestionAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    customerId?: SortOrder
    surveyQuestionId?: SortOrder
    answerSingleOptionId?: SortOrder
    answerNumeric?: SortOrder
    answerText?: SortOrder
    answerBool?: SortOrder
    reason?: SortOrder
    title?: SortOrder
    content?: SortOrder
    answerCount?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    customerId?: SortOrder
    surveyQuestionId?: SortOrder
    answerSingleOptionId?: SortOrder
    answerNumeric?: SortOrder
    answerText?: SortOrder
    answerBool?: SortOrder
    reason?: SortOrder
    title?: SortOrder
    content?: SortOrder
    answerCount?: SortOrder
    productId?: SortOrder
    orderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SurveyQuestionAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    surveyQuestionId?: SortOrder
    answerSingleOptionId?: SortOrder
    answerNumeric?: SortOrder
    answerCount?: SortOrder
    productId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type SurveyQuestionAnswerRelationFilter = {
    is?: SurveyQuestionAnswerWhereInput
    isNot?: SurveyQuestionAnswerWhereInput
  }

  export type IntermediateSurveyQuestionAnswerProductSurveyQuestionAnswerIdSurveyQuestionOptionIdCompoundUniqueInput = {
    surveyQuestionAnswerId: number
    surveyQuestionOptionId: number
  }

  export type IntermediateSurveyQuestionAnswerProductCountOrderByAggregateInput = {
    surveyQuestionAnswerId?: SortOrder
    surveyQuestionOptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateSurveyQuestionAnswerProductAvgOrderByAggregateInput = {
    surveyQuestionAnswerId?: SortOrder
    surveyQuestionOptionId?: SortOrder
  }

  export type IntermediateSurveyQuestionAnswerProductMaxOrderByAggregateInput = {
    surveyQuestionAnswerId?: SortOrder
    surveyQuestionOptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateSurveyQuestionAnswerProductMinOrderByAggregateInput = {
    surveyQuestionAnswerId?: SortOrder
    surveyQuestionOptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediateSurveyQuestionAnswerProductSumOrderByAggregateInput = {
    surveyQuestionAnswerId?: SortOrder
    surveyQuestionOptionId?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type CustomerProductDistanceCountOrderByAggregateInput = {
    id?: SortOrder
    distance?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductDistanceAvgOrderByAggregateInput = {
    id?: SortOrder
    distance?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerProductDistanceMaxOrderByAggregateInput = {
    id?: SortOrder
    distance?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductDistanceMinOrderByAggregateInput = {
    id?: SortOrder
    distance?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductDistanceSumOrderByAggregateInput = {
    id?: SortOrder
    distance?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type CustomerBoxItemsCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerBoxItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerBoxItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerBoxItemsMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerBoxItemsSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    customerId?: SortOrder
  }

  export type EnumQueueStatusFilter = {
    equals?: QueueStatus
    in?: Enumerable<QueueStatus>
    notIn?: Enumerable<QueueStatus>
    not?: NestedEnumQueueStatusFilter | QueueStatus
  }

  export type QueuedShopifyOrderCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    orderName?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    orderedAt?: SortOrder
    fulfilledAt?: SortOrder
  }

  export type QueuedShopifyOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type QueuedShopifyOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    orderName?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    orderedAt?: SortOrder
    fulfilledAt?: SortOrder
  }

  export type QueuedShopifyOrderMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    orderName?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    orderedAt?: SortOrder
    fulfilledAt?: SortOrder
  }

  export type QueuedShopifyOrderSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type EnumQueueStatusWithAggregatesFilter = {
    equals?: QueueStatus
    in?: Enumerable<QueueStatus>
    notIn?: Enumerable<QueueStatus>
    not?: NestedEnumQueueStatusWithAggregatesFilter | QueueStatus
    _count?: NestedIntFilter
    _min?: NestedEnumQueueStatusFilter
    _max?: NestedEnumQueueStatusFilter
  }

  export type PractitionerBoxListRelationFilter = {
    every?: PractitionerBoxWhereInput
    some?: PractitionerBoxWhereInput
    none?: PractitionerBoxWhereInput
  }

  export type PractitionerSocialMediaRelationFilter = {
    is?: PractitionerSocialMediaWhereInput | null
    isNot?: PractitionerSocialMediaWhereInput | null
  }

  export type PractitionerBoxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PractitionerCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PractitionerMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PractitionerRelationFilter = {
    is?: PractitionerWhereInput
    isNot?: PractitionerWhereInput
  }

  export type PractitionerSocialMediaCountOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerSocialMediaAvgOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
  }

  export type PractitionerSocialMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerSocialMediaMinOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    twitter?: SortOrder
    website?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerSocialMediaSumOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
  }

  export type PractitionerBoxCountOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerBoxAvgOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
  }

  export type PractitionerBoxMaxOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerBoxMinOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerBoxSumOrderByAggregateInput = {
    id?: SortOrder
    practitionerId?: SortOrder
  }

  export type PractitionerBoxRelationFilter = {
    is?: PractitionerBoxWhereInput
    isNot?: PractitionerBoxWhereInput
  }

  export type IntermediatePractitionerBoxProductPractitionerBoxIdProductIdCompoundUniqueInput = {
    practitionerBoxId: number
    productId: number
  }

  export type IntermediatePractitionerBoxProductCountOrderByAggregateInput = {
    practitionerBoxId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediatePractitionerBoxProductAvgOrderByAggregateInput = {
    practitionerBoxId?: SortOrder
    productId?: SortOrder
  }

  export type IntermediatePractitionerBoxProductMaxOrderByAggregateInput = {
    practitionerBoxId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediatePractitionerBoxProductMinOrderByAggregateInput = {
    practitionerBoxId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntermediatePractitionerBoxProductSumOrderByAggregateInput = {
    practitionerBoxId?: SortOrder
    productId?: SortOrder
  }

  export type PractitionerCustomerOrderHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    practitionerBoxId?: SortOrder
    orderNumber?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerCustomerOrderHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    practitionerBoxId?: SortOrder
    purchasePrice?: SortOrder
  }

  export type PractitionerCustomerOrderHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    practitionerBoxId?: SortOrder
    orderNumber?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerCustomerOrderHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    practitionerBoxId?: SortOrder
    orderNumber?: SortOrder
    purchasePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PractitionerCustomerOrderHistorySumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    practitionerBoxId?: SortOrder
    purchasePrice?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerNutritionNeedCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerNutritionNeedCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
  }

  export type IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerMedicalConditionCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerMedicalConditionCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
  }

  export type IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerAllergenCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerAllergenUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerAllergenCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerAllergenCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
  }

  export type SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutCustomerInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutCustomerInput>
    createMany?: SurveyQuestionAnswerCreateManyCustomerInputEnvelope
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
  }

  export type CustomerProductDistanceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerProductDistanceCreateWithoutCustomerInput>, Enumerable<CustomerProductDistanceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerProductDistanceCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerProductDistanceCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
  }

  export type CustomerBoxItemsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerBoxItemsCreateWithoutCustomerInput>, Enumerable<CustomerBoxItemsUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerBoxItemsCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerBoxItemsCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
  }

  export type QueuedShopifyOrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<QueuedShopifyOrderCreateWithoutCustomerInput>, Enumerable<QueuedShopifyOrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<QueuedShopifyOrderCreateOrConnectWithoutCustomerInput>
    createMany?: QueuedShopifyOrderCreateManyCustomerInputEnvelope
    connect?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
  }

  export type IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerFlavorDislikeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerFlavorDislikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFlavorDislikeCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerFlavorDislikeCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
  }

  export type IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerCategoryPreferenceCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerCategoryPreferenceCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
  }

  export type IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerIngredientDislikeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerIngredientDislikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerIngredientDislikeCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerIngredientDislikeCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
  }

  export type IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerFoodTypeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerFoodTypeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFoodTypeCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerFoodTypeCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerUnavailableCookingMethodCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerUnavailableCookingMethodCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
  }

  export type PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<PractitionerCustomerOrderHistoryCreateWithoutCustomerInput>, Enumerable<PractitionerCustomerOrderHistoryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PractitionerCustomerOrderHistoryCreateOrConnectWithoutCustomerInput>
    createMany?: PractitionerCustomerOrderHistoryCreateManyCustomerInputEnvelope
    connect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
  }

  export type IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerNutritionNeedCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerNutritionNeedCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
  }

  export type IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerMedicalConditionCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerMedicalConditionCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
  }

  export type IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerAllergenCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerAllergenUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerAllergenCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerAllergenCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
  }

  export type SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutCustomerInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutCustomerInput>
    createMany?: SurveyQuestionAnswerCreateManyCustomerInputEnvelope
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
  }

  export type CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerProductDistanceCreateWithoutCustomerInput>, Enumerable<CustomerProductDistanceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerProductDistanceCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerProductDistanceCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
  }

  export type CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerBoxItemsCreateWithoutCustomerInput>, Enumerable<CustomerBoxItemsUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerBoxItemsCreateOrConnectWithoutCustomerInput>
    createMany?: CustomerBoxItemsCreateManyCustomerInputEnvelope
    connect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
  }

  export type QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<QueuedShopifyOrderCreateWithoutCustomerInput>, Enumerable<QueuedShopifyOrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<QueuedShopifyOrderCreateOrConnectWithoutCustomerInput>
    createMany?: QueuedShopifyOrderCreateManyCustomerInputEnvelope
    connect?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
  }

  export type IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerFlavorDislikeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerFlavorDislikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFlavorDislikeCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerFlavorDislikeCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerCategoryPreferenceCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerCategoryPreferenceCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
  }

  export type IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerIngredientDislikeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerIngredientDislikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerIngredientDislikeCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerIngredientDislikeCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
  }

  export type IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerFoodTypeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerFoodTypeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFoodTypeCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerFoodTypeCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerUnavailableCookingMethodCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutCustomerInput>
    createMany?: IntermediateCustomerUnavailableCookingMethodCreateManyCustomerInputEnvelope
    connect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
  }

  export type PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<PractitionerCustomerOrderHistoryCreateWithoutCustomerInput>, Enumerable<PractitionerCustomerOrderHistoryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PractitionerCustomerOrderHistoryCreateOrConnectWithoutCustomerInput>
    createMany?: PractitionerCustomerOrderHistoryCreateManyCustomerInputEnvelope
    connect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerNutritionNeedCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerNutritionNeedUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerNutritionNeedCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerNutritionNeedUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerNutritionNeedUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereInput>
  }

  export type IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerMedicalConditionCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerMedicalConditionUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerMedicalConditionCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerMedicalConditionUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerMedicalConditionUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereInput>
  }

  export type IntermediateCustomerAllergenUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerAllergenCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerAllergenUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerAllergenCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerAllergenUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerAllergenCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerAllergenUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerAllergenUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerAllergenScalarWhereInput>
  }

  export type SurveyQuestionAnswerUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutCustomerInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<SurveyQuestionAnswerUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: SurveyQuestionAnswerCreateManyCustomerInputEnvelope
    set?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    update?: Enumerable<SurveyQuestionAnswerUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<SurveyQuestionAnswerUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
  }

  export type CustomerProductDistanceUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerProductDistanceCreateWithoutCustomerInput>, Enumerable<CustomerProductDistanceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerProductDistanceCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerProductDistanceUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerProductDistanceCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    disconnect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    delete?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    connect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    update?: Enumerable<CustomerProductDistanceUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerProductDistanceUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerProductDistanceScalarWhereInput>
  }

  export type CustomerBoxItemsUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerBoxItemsCreateWithoutCustomerInput>, Enumerable<CustomerBoxItemsUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerBoxItemsCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerBoxItemsUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerBoxItemsCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    disconnect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    delete?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    connect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    update?: Enumerable<CustomerBoxItemsUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerBoxItemsUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerBoxItemsScalarWhereInput>
  }

  export type QueuedShopifyOrderUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<QueuedShopifyOrderCreateWithoutCustomerInput>, Enumerable<QueuedShopifyOrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<QueuedShopifyOrderCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<QueuedShopifyOrderUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: QueuedShopifyOrderCreateManyCustomerInputEnvelope
    set?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
    disconnect?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
    delete?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
    connect?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
    update?: Enumerable<QueuedShopifyOrderUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<QueuedShopifyOrderUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<QueuedShopifyOrderScalarWhereInput>
  }

  export type IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerFlavorDislikeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerFlavorDislikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFlavorDislikeCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerFlavorDislikeUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerFlavorDislikeCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerFlavorDislikeUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerFlavorDislikeUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereInput>
  }

  export type IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerCategoryPreferenceCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerCategoryPreferenceUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerCategoryPreferenceCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerCategoryPreferenceUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerCategoryPreferenceUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereInput>
  }

  export type IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerIngredientDislikeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerIngredientDislikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerIngredientDislikeCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerIngredientDislikeUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerIngredientDislikeCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerIngredientDislikeUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerIngredientDislikeUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereInput>
  }

  export type IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerFoodTypeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerFoodTypeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFoodTypeCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerFoodTypeUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerFoodTypeCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerFoodTypeUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerFoodTypeUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerFoodTypeScalarWhereInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerUnavailableCookingMethodCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerUnavailableCookingMethodCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereInput>
  }

  export type PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<PractitionerCustomerOrderHistoryCreateWithoutCustomerInput>, Enumerable<PractitionerCustomerOrderHistoryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PractitionerCustomerOrderHistoryCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<PractitionerCustomerOrderHistoryUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: PractitionerCustomerOrderHistoryCreateManyCustomerInputEnvelope
    set?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    disconnect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    delete?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    connect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    update?: Enumerable<PractitionerCustomerOrderHistoryUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<PractitionerCustomerOrderHistoryUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereInput>
  }

  export type IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerNutritionNeedCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerNutritionNeedUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerNutritionNeedCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerNutritionNeedUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerNutritionNeedUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereInput>
  }

  export type IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerMedicalConditionCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerMedicalConditionUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerMedicalConditionCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerMedicalConditionUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerMedicalConditionUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereInput>
  }

  export type IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerAllergenCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerAllergenUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerAllergenCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerAllergenUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerAllergenCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerAllergenUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerAllergenUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerAllergenScalarWhereInput>
  }

  export type SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutCustomerInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<SurveyQuestionAnswerUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: SurveyQuestionAnswerCreateManyCustomerInputEnvelope
    set?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    update?: Enumerable<SurveyQuestionAnswerUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<SurveyQuestionAnswerUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
  }

  export type CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerProductDistanceCreateWithoutCustomerInput>, Enumerable<CustomerProductDistanceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerProductDistanceCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerProductDistanceUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerProductDistanceCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    disconnect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    delete?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    connect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    update?: Enumerable<CustomerProductDistanceUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerProductDistanceUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerProductDistanceScalarWhereInput>
  }

  export type CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<CustomerBoxItemsCreateWithoutCustomerInput>, Enumerable<CustomerBoxItemsUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<CustomerBoxItemsCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<CustomerBoxItemsUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: CustomerBoxItemsCreateManyCustomerInputEnvelope
    set?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    disconnect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    delete?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    connect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    update?: Enumerable<CustomerBoxItemsUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<CustomerBoxItemsUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<CustomerBoxItemsScalarWhereInput>
  }

  export type QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<QueuedShopifyOrderCreateWithoutCustomerInput>, Enumerable<QueuedShopifyOrderUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<QueuedShopifyOrderCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<QueuedShopifyOrderUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: QueuedShopifyOrderCreateManyCustomerInputEnvelope
    set?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
    disconnect?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
    delete?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
    connect?: Enumerable<QueuedShopifyOrderWhereUniqueInput>
    update?: Enumerable<QueuedShopifyOrderUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<QueuedShopifyOrderUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<QueuedShopifyOrderScalarWhereInput>
  }

  export type IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerFlavorDislikeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerFlavorDislikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFlavorDislikeCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerFlavorDislikeUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerFlavorDislikeCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerFlavorDislikeUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerFlavorDislikeUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereInput>
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerCategoryPreferenceCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerCategoryPreferenceUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerCategoryPreferenceCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerCategoryPreferenceUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerCategoryPreferenceUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereInput>
  }

  export type IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerIngredientDislikeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerIngredientDislikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerIngredientDislikeCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerIngredientDislikeUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerIngredientDislikeCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerIngredientDislikeUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerIngredientDislikeUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereInput>
  }

  export type IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerFoodTypeCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerFoodTypeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFoodTypeCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerFoodTypeUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerFoodTypeCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerFoodTypeUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerFoodTypeUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerFoodTypeScalarWhereInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<IntermediateCustomerUnavailableCookingMethodCreateWithoutCustomerInput>, Enumerable<IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: IntermediateCustomerUnavailableCookingMethodCreateManyCustomerInputEnvelope
    set?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereInput>
  }

  export type PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput = {
    create?: XOR<Enumerable<PractitionerCustomerOrderHistoryCreateWithoutCustomerInput>, Enumerable<PractitionerCustomerOrderHistoryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<PractitionerCustomerOrderHistoryCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<PractitionerCustomerOrderHistoryUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: PractitionerCustomerOrderHistoryCreateManyCustomerInputEnvelope
    set?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    disconnect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    delete?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    connect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    update?: Enumerable<PractitionerCustomerOrderHistoryUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<PractitionerCustomerOrderHistoryUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereInput>
  }

  export type CustomerNutritionNeedCreateNestedOneWithoutIntermediateCustomerNutritionNeedInput = {
    create?: XOR<CustomerNutritionNeedCreateWithoutIntermediateCustomerNutritionNeedInput, CustomerNutritionNeedUncheckedCreateWithoutIntermediateCustomerNutritionNeedInput>
    connectOrCreate?: CustomerNutritionNeedCreateOrConnectWithoutIntermediateCustomerNutritionNeedInput
    connect?: CustomerNutritionNeedWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutIntermediateCustomerNutritionNeedsInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerNutritionNeedsInput, CustomersUncheckedCreateWithoutIntermediateCustomerNutritionNeedsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerNutritionNeedsInput
    connect?: CustomersWhereUniqueInput
  }

  export type CustomerNutritionNeedUpdateOneRequiredWithoutIntermediateCustomerNutritionNeedInput = {
    create?: XOR<CustomerNutritionNeedCreateWithoutIntermediateCustomerNutritionNeedInput, CustomerNutritionNeedUncheckedCreateWithoutIntermediateCustomerNutritionNeedInput>
    connectOrCreate?: CustomerNutritionNeedCreateOrConnectWithoutIntermediateCustomerNutritionNeedInput
    upsert?: CustomerNutritionNeedUpsertWithoutIntermediateCustomerNutritionNeedInput
    connect?: CustomerNutritionNeedWhereUniqueInput
    update?: XOR<CustomerNutritionNeedUpdateWithoutIntermediateCustomerNutritionNeedInput, CustomerNutritionNeedUncheckedUpdateWithoutIntermediateCustomerNutritionNeedInput>
  }

  export type CustomersUpdateOneRequiredWithoutIntermediateCustomerNutritionNeedsInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerNutritionNeedsInput, CustomersUncheckedCreateWithoutIntermediateCustomerNutritionNeedsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerNutritionNeedsInput
    upsert?: CustomersUpsertWithoutIntermediateCustomerNutritionNeedsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutIntermediateCustomerNutritionNeedsInput, CustomersUncheckedUpdateWithoutIntermediateCustomerNutritionNeedsInput>
  }

  export type IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerNutritionNeedInput = {
    create?: XOR<Enumerable<IntermediateCustomerNutritionNeedCreateWithoutCustomerNutritionNeedInput>, Enumerable<IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerNutritionNeedInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerNutritionNeedInput>
    createMany?: IntermediateCustomerNutritionNeedCreateManyCustomerNutritionNeedInputEnvelope
    connect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
  }

  export type IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerNutritionNeedInput = {
    create?: XOR<Enumerable<IntermediateCustomerNutritionNeedCreateWithoutCustomerNutritionNeedInput>, Enumerable<IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerNutritionNeedInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerNutritionNeedInput>
    createMany?: IntermediateCustomerNutritionNeedCreateManyCustomerNutritionNeedInputEnvelope
    connect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
  }

  export type IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerNutritionNeedInput = {
    create?: XOR<Enumerable<IntermediateCustomerNutritionNeedCreateWithoutCustomerNutritionNeedInput>, Enumerable<IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerNutritionNeedInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerNutritionNeedInput>
    upsert?: Enumerable<IntermediateCustomerNutritionNeedUpsertWithWhereUniqueWithoutCustomerNutritionNeedInput>
    createMany?: IntermediateCustomerNutritionNeedCreateManyCustomerNutritionNeedInputEnvelope
    set?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerNutritionNeedUpdateWithWhereUniqueWithoutCustomerNutritionNeedInput>
    updateMany?: Enumerable<IntermediateCustomerNutritionNeedUpdateManyWithWhereWithoutCustomerNutritionNeedInput>
    deleteMany?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereInput>
  }

  export type IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerNutritionNeedInput = {
    create?: XOR<Enumerable<IntermediateCustomerNutritionNeedCreateWithoutCustomerNutritionNeedInput>, Enumerable<IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerNutritionNeedInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerNutritionNeedInput>
    upsert?: Enumerable<IntermediateCustomerNutritionNeedUpsertWithWhereUniqueWithoutCustomerNutritionNeedInput>
    createMany?: IntermediateCustomerNutritionNeedCreateManyCustomerNutritionNeedInputEnvelope
    set?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerNutritionNeedWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerNutritionNeedUpdateWithWhereUniqueWithoutCustomerNutritionNeedInput>
    updateMany?: Enumerable<IntermediateCustomerNutritionNeedUpdateManyWithWhereWithoutCustomerNutritionNeedInput>
    deleteMany?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereInput>
  }

  export type CustomerMedicalConditionCreateNestedOneWithoutIntermediateCustomerMedicalConditionsInput = {
    create?: XOR<CustomerMedicalConditionCreateWithoutIntermediateCustomerMedicalConditionsInput, CustomerMedicalConditionUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput>
    connectOrCreate?: CustomerMedicalConditionCreateOrConnectWithoutIntermediateCustomerMedicalConditionsInput
    connect?: CustomerMedicalConditionWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutIntermediateCustomerMedicalConditionsInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerMedicalConditionsInput, CustomersUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerMedicalConditionsInput
    connect?: CustomersWhereUniqueInput
  }

  export type CustomerMedicalConditionUpdateOneRequiredWithoutIntermediateCustomerMedicalConditionsInput = {
    create?: XOR<CustomerMedicalConditionCreateWithoutIntermediateCustomerMedicalConditionsInput, CustomerMedicalConditionUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput>
    connectOrCreate?: CustomerMedicalConditionCreateOrConnectWithoutIntermediateCustomerMedicalConditionsInput
    upsert?: CustomerMedicalConditionUpsertWithoutIntermediateCustomerMedicalConditionsInput
    connect?: CustomerMedicalConditionWhereUniqueInput
    update?: XOR<CustomerMedicalConditionUpdateWithoutIntermediateCustomerMedicalConditionsInput, CustomerMedicalConditionUncheckedUpdateWithoutIntermediateCustomerMedicalConditionsInput>
  }

  export type CustomersUpdateOneRequiredWithoutIntermediateCustomerMedicalConditionsInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerMedicalConditionsInput, CustomersUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerMedicalConditionsInput
    upsert?: CustomersUpsertWithoutIntermediateCustomerMedicalConditionsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutIntermediateCustomerMedicalConditionsInput, CustomersUncheckedUpdateWithoutIntermediateCustomerMedicalConditionsInput>
  }

  export type IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerMedicalConditionInput = {
    create?: XOR<Enumerable<IntermediateCustomerMedicalConditionCreateWithoutCustomerMedicalConditionInput>, Enumerable<IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerMedicalConditionInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerMedicalConditionInput>
    createMany?: IntermediateCustomerMedicalConditionCreateManyCustomerMedicalConditionInputEnvelope
    connect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
  }

  export type IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerMedicalConditionInput = {
    create?: XOR<Enumerable<IntermediateCustomerMedicalConditionCreateWithoutCustomerMedicalConditionInput>, Enumerable<IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerMedicalConditionInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerMedicalConditionInput>
    createMany?: IntermediateCustomerMedicalConditionCreateManyCustomerMedicalConditionInputEnvelope
    connect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
  }

  export type IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerMedicalConditionInput = {
    create?: XOR<Enumerable<IntermediateCustomerMedicalConditionCreateWithoutCustomerMedicalConditionInput>, Enumerable<IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerMedicalConditionInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerMedicalConditionInput>
    upsert?: Enumerable<IntermediateCustomerMedicalConditionUpsertWithWhereUniqueWithoutCustomerMedicalConditionInput>
    createMany?: IntermediateCustomerMedicalConditionCreateManyCustomerMedicalConditionInputEnvelope
    set?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerMedicalConditionUpdateWithWhereUniqueWithoutCustomerMedicalConditionInput>
    updateMany?: Enumerable<IntermediateCustomerMedicalConditionUpdateManyWithWhereWithoutCustomerMedicalConditionInput>
    deleteMany?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereInput>
  }

  export type IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerMedicalConditionInput = {
    create?: XOR<Enumerable<IntermediateCustomerMedicalConditionCreateWithoutCustomerMedicalConditionInput>, Enumerable<IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerMedicalConditionInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerMedicalConditionInput>
    upsert?: Enumerable<IntermediateCustomerMedicalConditionUpsertWithWhereUniqueWithoutCustomerMedicalConditionInput>
    createMany?: IntermediateCustomerMedicalConditionCreateManyCustomerMedicalConditionInputEnvelope
    set?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerMedicalConditionWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerMedicalConditionUpdateWithWhereUniqueWithoutCustomerMedicalConditionInput>
    updateMany?: Enumerable<IntermediateCustomerMedicalConditionUpdateManyWithWhereWithoutCustomerMedicalConditionInput>
    deleteMany?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereInput>
  }

  export type ProductFoodTypeCreateNestedOneWithoutIntermediateCustomerFoodTypesInput = {
    create?: XOR<ProductFoodTypeCreateWithoutIntermediateCustomerFoodTypesInput, ProductFoodTypeUncheckedCreateWithoutIntermediateCustomerFoodTypesInput>
    connectOrCreate?: ProductFoodTypeCreateOrConnectWithoutIntermediateCustomerFoodTypesInput
    connect?: ProductFoodTypeWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutIntermediateCustomerFoodTypesInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerFoodTypesInput, CustomersUncheckedCreateWithoutIntermediateCustomerFoodTypesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerFoodTypesInput
    connect?: CustomersWhereUniqueInput
  }

  export type ProductFoodTypeUpdateOneRequiredWithoutIntermediateCustomerFoodTypesInput = {
    create?: XOR<ProductFoodTypeCreateWithoutIntermediateCustomerFoodTypesInput, ProductFoodTypeUncheckedCreateWithoutIntermediateCustomerFoodTypesInput>
    connectOrCreate?: ProductFoodTypeCreateOrConnectWithoutIntermediateCustomerFoodTypesInput
    upsert?: ProductFoodTypeUpsertWithoutIntermediateCustomerFoodTypesInput
    connect?: ProductFoodTypeWhereUniqueInput
    update?: XOR<ProductFoodTypeUpdateWithoutIntermediateCustomerFoodTypesInput, ProductFoodTypeUncheckedUpdateWithoutIntermediateCustomerFoodTypesInput>
  }

  export type CustomersUpdateOneRequiredWithoutIntermediateCustomerFoodTypesInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerFoodTypesInput, CustomersUncheckedCreateWithoutIntermediateCustomerFoodTypesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerFoodTypesInput
    upsert?: CustomersUpsertWithoutIntermediateCustomerFoodTypesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutIntermediateCustomerFoodTypesInput, CustomersUncheckedUpdateWithoutIntermediateCustomerFoodTypesInput>
  }

  export type IntermediateCustomerFoodTypeCreateNestedManyWithoutProductFoodTypeInput = {
    create?: XOR<Enumerable<IntermediateCustomerFoodTypeCreateWithoutProductFoodTypeInput>, Enumerable<IntermediateCustomerFoodTypeUncheckedCreateWithoutProductFoodTypeInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFoodTypeCreateOrConnectWithoutProductFoodTypeInput>
    createMany?: IntermediateCustomerFoodTypeCreateManyProductFoodTypeInputEnvelope
    connect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
  }

  export type IntermediateProductFoodTypeCreateNestedManyWithoutProductFoodTypeInput = {
    create?: XOR<Enumerable<IntermediateProductFoodTypeCreateWithoutProductFoodTypeInput>, Enumerable<IntermediateProductFoodTypeUncheckedCreateWithoutProductFoodTypeInput>>
    connectOrCreate?: Enumerable<IntermediateProductFoodTypeCreateOrConnectWithoutProductFoodTypeInput>
    createMany?: IntermediateProductFoodTypeCreateManyProductFoodTypeInputEnvelope
    connect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
  }

  export type IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutProductFoodTypeInput = {
    create?: XOR<Enumerable<IntermediateCustomerFoodTypeCreateWithoutProductFoodTypeInput>, Enumerable<IntermediateCustomerFoodTypeUncheckedCreateWithoutProductFoodTypeInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFoodTypeCreateOrConnectWithoutProductFoodTypeInput>
    createMany?: IntermediateCustomerFoodTypeCreateManyProductFoodTypeInputEnvelope
    connect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
  }

  export type IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductFoodTypeInput = {
    create?: XOR<Enumerable<IntermediateProductFoodTypeCreateWithoutProductFoodTypeInput>, Enumerable<IntermediateProductFoodTypeUncheckedCreateWithoutProductFoodTypeInput>>
    connectOrCreate?: Enumerable<IntermediateProductFoodTypeCreateOrConnectWithoutProductFoodTypeInput>
    createMany?: IntermediateProductFoodTypeCreateManyProductFoodTypeInputEnvelope
    connect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
  }

  export type IntermediateCustomerFoodTypeUpdateManyWithoutProductFoodTypeInput = {
    create?: XOR<Enumerable<IntermediateCustomerFoodTypeCreateWithoutProductFoodTypeInput>, Enumerable<IntermediateCustomerFoodTypeUncheckedCreateWithoutProductFoodTypeInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFoodTypeCreateOrConnectWithoutProductFoodTypeInput>
    upsert?: Enumerable<IntermediateCustomerFoodTypeUpsertWithWhereUniqueWithoutProductFoodTypeInput>
    createMany?: IntermediateCustomerFoodTypeCreateManyProductFoodTypeInputEnvelope
    set?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerFoodTypeUpdateWithWhereUniqueWithoutProductFoodTypeInput>
    updateMany?: Enumerable<IntermediateCustomerFoodTypeUpdateManyWithWhereWithoutProductFoodTypeInput>
    deleteMany?: Enumerable<IntermediateCustomerFoodTypeScalarWhereInput>
  }

  export type IntermediateProductFoodTypeUpdateManyWithoutProductFoodTypeInput = {
    create?: XOR<Enumerable<IntermediateProductFoodTypeCreateWithoutProductFoodTypeInput>, Enumerable<IntermediateProductFoodTypeUncheckedCreateWithoutProductFoodTypeInput>>
    connectOrCreate?: Enumerable<IntermediateProductFoodTypeCreateOrConnectWithoutProductFoodTypeInput>
    upsert?: Enumerable<IntermediateProductFoodTypeUpsertWithWhereUniqueWithoutProductFoodTypeInput>
    createMany?: IntermediateProductFoodTypeCreateManyProductFoodTypeInputEnvelope
    set?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    delete?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    connect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    update?: Enumerable<IntermediateProductFoodTypeUpdateWithWhereUniqueWithoutProductFoodTypeInput>
    updateMany?: Enumerable<IntermediateProductFoodTypeUpdateManyWithWhereWithoutProductFoodTypeInput>
    deleteMany?: Enumerable<IntermediateProductFoodTypeScalarWhereInput>
  }

  export type IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutProductFoodTypeInput = {
    create?: XOR<Enumerable<IntermediateCustomerFoodTypeCreateWithoutProductFoodTypeInput>, Enumerable<IntermediateCustomerFoodTypeUncheckedCreateWithoutProductFoodTypeInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFoodTypeCreateOrConnectWithoutProductFoodTypeInput>
    upsert?: Enumerable<IntermediateCustomerFoodTypeUpsertWithWhereUniqueWithoutProductFoodTypeInput>
    createMany?: IntermediateCustomerFoodTypeCreateManyProductFoodTypeInputEnvelope
    set?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerFoodTypeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerFoodTypeUpdateWithWhereUniqueWithoutProductFoodTypeInput>
    updateMany?: Enumerable<IntermediateCustomerFoodTypeUpdateManyWithWhereWithoutProductFoodTypeInput>
    deleteMany?: Enumerable<IntermediateCustomerFoodTypeScalarWhereInput>
  }

  export type IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductFoodTypeInput = {
    create?: XOR<Enumerable<IntermediateProductFoodTypeCreateWithoutProductFoodTypeInput>, Enumerable<IntermediateProductFoodTypeUncheckedCreateWithoutProductFoodTypeInput>>
    connectOrCreate?: Enumerable<IntermediateProductFoodTypeCreateOrConnectWithoutProductFoodTypeInput>
    upsert?: Enumerable<IntermediateProductFoodTypeUpsertWithWhereUniqueWithoutProductFoodTypeInput>
    createMany?: IntermediateProductFoodTypeCreateManyProductFoodTypeInputEnvelope
    set?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    delete?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    connect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    update?: Enumerable<IntermediateProductFoodTypeUpdateWithWhereUniqueWithoutProductFoodTypeInput>
    updateMany?: Enumerable<IntermediateProductFoodTypeUpdateManyWithWhereWithoutProductFoodTypeInput>
    deleteMany?: Enumerable<IntermediateProductFoodTypeScalarWhereInput>
  }

  export type ProductFoodTypeCreateNestedOneWithoutIntermediateProductFoodTypesInput = {
    create?: XOR<ProductFoodTypeCreateWithoutIntermediateProductFoodTypesInput, ProductFoodTypeUncheckedCreateWithoutIntermediateProductFoodTypesInput>
    connectOrCreate?: ProductFoodTypeCreateOrConnectWithoutIntermediateProductFoodTypesInput
    connect?: ProductFoodTypeWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutIntermediateProductFoodTypesInput = {
    create?: XOR<ProductCreateWithoutIntermediateProductFoodTypesInput, ProductUncheckedCreateWithoutIntermediateProductFoodTypesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediateProductFoodTypesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductFoodTypeUpdateOneRequiredWithoutIntermediateProductFoodTypesInput = {
    create?: XOR<ProductFoodTypeCreateWithoutIntermediateProductFoodTypesInput, ProductFoodTypeUncheckedCreateWithoutIntermediateProductFoodTypesInput>
    connectOrCreate?: ProductFoodTypeCreateOrConnectWithoutIntermediateProductFoodTypesInput
    upsert?: ProductFoodTypeUpsertWithoutIntermediateProductFoodTypesInput
    connect?: ProductFoodTypeWhereUniqueInput
    update?: XOR<ProductFoodTypeUpdateWithoutIntermediateProductFoodTypesInput, ProductFoodTypeUncheckedUpdateWithoutIntermediateProductFoodTypesInput>
  }

  export type ProductUpdateOneRequiredWithoutIntermediateProductFoodTypesInput = {
    create?: XOR<ProductCreateWithoutIntermediateProductFoodTypesInput, ProductUncheckedCreateWithoutIntermediateProductFoodTypesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediateProductFoodTypesInput
    upsert?: ProductUpsertWithoutIntermediateProductFoodTypesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutIntermediateProductFoodTypesInput, ProductUncheckedUpdateWithoutIntermediateProductFoodTypesInput>
  }

  export type ProductProviderCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductProviderCreateWithoutProductsInput, ProductProviderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductProviderCreateOrConnectWithoutProductsInput
    connect?: ProductProviderWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductFlavorCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductFlavorCreateWithoutProductsInput, ProductFlavorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductFlavorCreateOrConnectWithoutProductsInput
    connect?: ProductFlavorWhereUniqueInput
  }

  export type ProductVendorCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductVendorCreateWithoutProductsInput, ProductVendorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductVendorCreateOrConnectWithoutProductsInput
    connect?: ProductVendorWhereUniqueInput
  }

  export type IntermediateProductFoodTypeCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductFoodTypeCreateWithoutProductInput>, Enumerable<IntermediateProductFoodTypeUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductFoodTypeCreateOrConnectWithoutProductInput>
    createMany?: IntermediateProductFoodTypeCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
  }

  export type IntermediateProductIngredientCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductIngredientCreateWithoutProductInput>, Enumerable<IntermediateProductIngredientUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductIngredientCreateOrConnectWithoutProductInput>
    createMany?: IntermediateProductIngredientCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
  }

  export type IntermediateProductAllergenCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductAllergenCreateWithoutProductInput>, Enumerable<IntermediateProductAllergenUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductAllergenCreateOrConnectWithoutProductInput>
    createMany?: IntermediateProductAllergenCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
  }

  export type IntermediateProductCookingMethodCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductCookingMethodCreateWithoutProductInput>, Enumerable<IntermediateProductCookingMethodUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductCookingMethodCreateOrConnectWithoutProductInput>
    createMany?: IntermediateProductCookingMethodCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
  }

  export type IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediatePractitionerBoxProductCreateWithoutProductInput>, Enumerable<IntermediatePractitionerBoxProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediatePractitionerBoxProductCreateOrConnectWithoutProductInput>
    createMany?: IntermediatePractitionerBoxProductCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
  }

  export type ProductNutritionFactCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductNutritionFactCreateWithoutProductInput, ProductNutritionFactUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductNutritionFactCreateOrConnectWithoutProductInput
    connect?: ProductNutritionFactWhereUniqueInput
  }

  export type SurveyQuestionAnswerCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutProductInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutProductInput>
    createMany?: SurveyQuestionAnswerCreateManyProductInputEnvelope
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
  }

  export type CustomerProductDistanceCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CustomerProductDistanceCreateWithoutProductInput>, Enumerable<CustomerProductDistanceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CustomerProductDistanceCreateOrConnectWithoutProductInput>
    createMany?: CustomerProductDistanceCreateManyProductInputEnvelope
    connect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
  }

  export type CustomerBoxItemsCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CustomerBoxItemsCreateWithoutProductInput>, Enumerable<CustomerBoxItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CustomerBoxItemsCreateOrConnectWithoutProductInput>
    createMany?: CustomerBoxItemsCreateManyProductInputEnvelope
    connect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: Enumerable<ProductImageWhereUniqueInput>
  }

  export type IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductFoodTypeCreateWithoutProductInput>, Enumerable<IntermediateProductFoodTypeUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductFoodTypeCreateOrConnectWithoutProductInput>
    createMany?: IntermediateProductFoodTypeCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
  }

  export type IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductIngredientCreateWithoutProductInput>, Enumerable<IntermediateProductIngredientUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductIngredientCreateOrConnectWithoutProductInput>
    createMany?: IntermediateProductIngredientCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
  }

  export type IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductAllergenCreateWithoutProductInput>, Enumerable<IntermediateProductAllergenUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductAllergenCreateOrConnectWithoutProductInput>
    createMany?: IntermediateProductAllergenCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
  }

  export type IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductCookingMethodCreateWithoutProductInput>, Enumerable<IntermediateProductCookingMethodUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductCookingMethodCreateOrConnectWithoutProductInput>
    createMany?: IntermediateProductCookingMethodCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
  }

  export type IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediatePractitionerBoxProductCreateWithoutProductInput>, Enumerable<IntermediatePractitionerBoxProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediatePractitionerBoxProductCreateOrConnectWithoutProductInput>
    createMany?: IntermediatePractitionerBoxProductCreateManyProductInputEnvelope
    connect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
  }

  export type ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductNutritionFactCreateWithoutProductInput, ProductNutritionFactUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductNutritionFactCreateOrConnectWithoutProductInput
    connect?: ProductNutritionFactWhereUniqueInput
  }

  export type SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutProductInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutProductInput>
    createMany?: SurveyQuestionAnswerCreateManyProductInputEnvelope
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
  }

  export type CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CustomerProductDistanceCreateWithoutProductInput>, Enumerable<CustomerProductDistanceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CustomerProductDistanceCreateOrConnectWithoutProductInput>
    createMany?: CustomerProductDistanceCreateManyProductInputEnvelope
    connect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
  }

  export type CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CustomerBoxItemsCreateWithoutProductInput>, Enumerable<CustomerBoxItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CustomerBoxItemsCreateOrConnectWithoutProductInput>
    createMany?: CustomerBoxItemsCreateManyProductInputEnvelope
    connect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: Enumerable<ProductImageWhereUniqueInput>
  }

  export type NullableEnumActiveStatusFieldUpdateOperationsInput = {
    set?: ActiveStatus | null
  }

  export type ProductProviderUpdateOneRequiredWithoutProductsInput = {
    create?: XOR<ProductProviderCreateWithoutProductsInput, ProductProviderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductProviderCreateOrConnectWithoutProductsInput
    upsert?: ProductProviderUpsertWithoutProductsInput
    connect?: ProductProviderWhereUniqueInput
    update?: XOR<ProductProviderUpdateWithoutProductsInput, ProductProviderUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductFlavorUpdateOneWithoutProductsInput = {
    create?: XOR<ProductFlavorCreateWithoutProductsInput, ProductFlavorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductFlavorCreateOrConnectWithoutProductsInput
    upsert?: ProductFlavorUpsertWithoutProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductFlavorWhereUniqueInput
    update?: XOR<ProductFlavorUpdateWithoutProductsInput, ProductFlavorUncheckedUpdateWithoutProductsInput>
  }

  export type ProductVendorUpdateOneWithoutProductsInput = {
    create?: XOR<ProductVendorCreateWithoutProductsInput, ProductVendorUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductVendorCreateOrConnectWithoutProductsInput
    upsert?: ProductVendorUpsertWithoutProductsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductVendorWhereUniqueInput
    update?: XOR<ProductVendorUpdateWithoutProductsInput, ProductVendorUncheckedUpdateWithoutProductsInput>
  }

  export type IntermediateProductFoodTypeUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductFoodTypeCreateWithoutProductInput>, Enumerable<IntermediateProductFoodTypeUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductFoodTypeCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediateProductFoodTypeUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediateProductFoodTypeCreateManyProductInputEnvelope
    set?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    delete?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    connect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    update?: Enumerable<IntermediateProductFoodTypeUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediateProductFoodTypeUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediateProductFoodTypeScalarWhereInput>
  }

  export type IntermediateProductIngredientUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductIngredientCreateWithoutProductInput>, Enumerable<IntermediateProductIngredientUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductIngredientCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediateProductIngredientUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediateProductIngredientCreateManyProductInputEnvelope
    set?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    delete?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    connect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    update?: Enumerable<IntermediateProductIngredientUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediateProductIngredientUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediateProductIngredientScalarWhereInput>
  }

  export type IntermediateProductAllergenUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductAllergenCreateWithoutProductInput>, Enumerable<IntermediateProductAllergenUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductAllergenCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediateProductAllergenUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediateProductAllergenCreateManyProductInputEnvelope
    set?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    delete?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    connect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    update?: Enumerable<IntermediateProductAllergenUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediateProductAllergenUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediateProductAllergenScalarWhereInput>
  }

  export type IntermediateProductCookingMethodUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductCookingMethodCreateWithoutProductInput>, Enumerable<IntermediateProductCookingMethodUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductCookingMethodCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediateProductCookingMethodUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediateProductCookingMethodCreateManyProductInputEnvelope
    set?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    delete?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    connect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    update?: Enumerable<IntermediateProductCookingMethodUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediateProductCookingMethodUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediateProductCookingMethodScalarWhereInput>
  }

  export type IntermediatePractitionerBoxProductUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediatePractitionerBoxProductCreateWithoutProductInput>, Enumerable<IntermediatePractitionerBoxProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediatePractitionerBoxProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediatePractitionerBoxProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediatePractitionerBoxProductCreateManyProductInputEnvelope
    set?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    disconnect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    delete?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    connect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    update?: Enumerable<IntermediatePractitionerBoxProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediatePractitionerBoxProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediatePractitionerBoxProductScalarWhereInput>
  }

  export type ProductNutritionFactUpdateOneWithoutProductInput = {
    create?: XOR<ProductNutritionFactCreateWithoutProductInput, ProductNutritionFactUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductNutritionFactCreateOrConnectWithoutProductInput
    upsert?: ProductNutritionFactUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductNutritionFactWhereUniqueInput
    update?: XOR<ProductNutritionFactUpdateWithoutProductInput, ProductNutritionFactUncheckedUpdateWithoutProductInput>
  }

  export type SurveyQuestionAnswerUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutProductInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<SurveyQuestionAnswerUpsertWithWhereUniqueWithoutProductInput>
    createMany?: SurveyQuestionAnswerCreateManyProductInputEnvelope
    set?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    update?: Enumerable<SurveyQuestionAnswerUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<SurveyQuestionAnswerUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
  }

  export type CustomerProductDistanceUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CustomerProductDistanceCreateWithoutProductInput>, Enumerable<CustomerProductDistanceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CustomerProductDistanceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CustomerProductDistanceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CustomerProductDistanceCreateManyProductInputEnvelope
    set?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    disconnect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    delete?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    connect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    update?: Enumerable<CustomerProductDistanceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CustomerProductDistanceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CustomerProductDistanceScalarWhereInput>
  }

  export type CustomerBoxItemsUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CustomerBoxItemsCreateWithoutProductInput>, Enumerable<CustomerBoxItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CustomerBoxItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CustomerBoxItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CustomerBoxItemsCreateManyProductInputEnvelope
    set?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    disconnect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    delete?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    connect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    update?: Enumerable<CustomerBoxItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CustomerBoxItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CustomerBoxItemsScalarWhereInput>
  }

  export type ProductImageUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductImageUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: Enumerable<ProductImageWhereUniqueInput>
    disconnect?: Enumerable<ProductImageWhereUniqueInput>
    delete?: Enumerable<ProductImageWhereUniqueInput>
    connect?: Enumerable<ProductImageWhereUniqueInput>
    update?: Enumerable<ProductImageUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductImageUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductImageScalarWhereInput>
  }

  export type IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductFoodTypeCreateWithoutProductInput>, Enumerable<IntermediateProductFoodTypeUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductFoodTypeCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediateProductFoodTypeUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediateProductFoodTypeCreateManyProductInputEnvelope
    set?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    delete?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    connect?: Enumerable<IntermediateProductFoodTypeWhereUniqueInput>
    update?: Enumerable<IntermediateProductFoodTypeUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediateProductFoodTypeUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediateProductFoodTypeScalarWhereInput>
  }

  export type IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductIngredientCreateWithoutProductInput>, Enumerable<IntermediateProductIngredientUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductIngredientCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediateProductIngredientUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediateProductIngredientCreateManyProductInputEnvelope
    set?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    delete?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    connect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    update?: Enumerable<IntermediateProductIngredientUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediateProductIngredientUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediateProductIngredientScalarWhereInput>
  }

  export type IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductAllergenCreateWithoutProductInput>, Enumerable<IntermediateProductAllergenUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductAllergenCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediateProductAllergenUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediateProductAllergenCreateManyProductInputEnvelope
    set?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    delete?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    connect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    update?: Enumerable<IntermediateProductAllergenUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediateProductAllergenUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediateProductAllergenScalarWhereInput>
  }

  export type IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediateProductCookingMethodCreateWithoutProductInput>, Enumerable<IntermediateProductCookingMethodUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediateProductCookingMethodCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediateProductCookingMethodUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediateProductCookingMethodCreateManyProductInputEnvelope
    set?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    delete?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    connect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    update?: Enumerable<IntermediateProductCookingMethodUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediateProductCookingMethodUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediateProductCookingMethodScalarWhereInput>
  }

  export type IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<IntermediatePractitionerBoxProductCreateWithoutProductInput>, Enumerable<IntermediatePractitionerBoxProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<IntermediatePractitionerBoxProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<IntermediatePractitionerBoxProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: IntermediatePractitionerBoxProductCreateManyProductInputEnvelope
    set?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    disconnect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    delete?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    connect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    update?: Enumerable<IntermediatePractitionerBoxProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<IntermediatePractitionerBoxProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<IntermediatePractitionerBoxProductScalarWhereInput>
  }

  export type ProductNutritionFactUncheckedUpdateOneWithoutProductInput = {
    create?: XOR<ProductNutritionFactCreateWithoutProductInput, ProductNutritionFactUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductNutritionFactCreateOrConnectWithoutProductInput
    upsert?: ProductNutritionFactUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductNutritionFactWhereUniqueInput
    update?: XOR<ProductNutritionFactUpdateWithoutProductInput, ProductNutritionFactUncheckedUpdateWithoutProductInput>
  }

  export type SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutProductInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<SurveyQuestionAnswerUpsertWithWhereUniqueWithoutProductInput>
    createMany?: SurveyQuestionAnswerCreateManyProductInputEnvelope
    set?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    update?: Enumerable<SurveyQuestionAnswerUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<SurveyQuestionAnswerUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
  }

  export type CustomerProductDistanceUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CustomerProductDistanceCreateWithoutProductInput>, Enumerable<CustomerProductDistanceUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CustomerProductDistanceCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CustomerProductDistanceUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CustomerProductDistanceCreateManyProductInputEnvelope
    set?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    disconnect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    delete?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    connect?: Enumerable<CustomerProductDistanceWhereUniqueInput>
    update?: Enumerable<CustomerProductDistanceUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CustomerProductDistanceUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CustomerProductDistanceScalarWhereInput>
  }

  export type CustomerBoxItemsUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<CustomerBoxItemsCreateWithoutProductInput>, Enumerable<CustomerBoxItemsUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CustomerBoxItemsCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CustomerBoxItemsUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CustomerBoxItemsCreateManyProductInputEnvelope
    set?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    disconnect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    delete?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    connect?: Enumerable<CustomerBoxItemsWhereUniqueInput>
    update?: Enumerable<CustomerBoxItemsUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CustomerBoxItemsUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CustomerBoxItemsScalarWhereInput>
  }

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductImageCreateWithoutProductInput>, Enumerable<ProductImageUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductImageCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductImageUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: Enumerable<ProductImageWhereUniqueInput>
    disconnect?: Enumerable<ProductImageWhereUniqueInput>
    delete?: Enumerable<ProductImageWhereUniqueInput>
    connect?: Enumerable<ProductImageWhereUniqueInput>
    update?: Enumerable<ProductImageUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductImageUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductImageScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutProductImagesInput = {
    create?: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductImagesInput = {
    create?: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImagesInput
    upsert?: ProductUpsertWithoutProductImagesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProductImagesInput, ProductUncheckedUpdateWithoutProductImagesInput>
  }

  export type ProductCreateNestedOneWithoutIntermediateProductCookingMethodsInput = {
    create?: XOR<ProductCreateWithoutIntermediateProductCookingMethodsInput, ProductUncheckedCreateWithoutIntermediateProductCookingMethodsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediateProductCookingMethodsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductCookingMethodCreateNestedOneWithoutIntermediateProductCookingMethodsInput = {
    create?: XOR<ProductCookingMethodCreateWithoutIntermediateProductCookingMethodsInput, ProductCookingMethodUncheckedCreateWithoutIntermediateProductCookingMethodsInput>
    connectOrCreate?: ProductCookingMethodCreateOrConnectWithoutIntermediateProductCookingMethodsInput
    connect?: ProductCookingMethodWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutIntermediateProductCookingMethodsInput = {
    create?: XOR<ProductCreateWithoutIntermediateProductCookingMethodsInput, ProductUncheckedCreateWithoutIntermediateProductCookingMethodsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediateProductCookingMethodsInput
    upsert?: ProductUpsertWithoutIntermediateProductCookingMethodsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutIntermediateProductCookingMethodsInput, ProductUncheckedUpdateWithoutIntermediateProductCookingMethodsInput>
  }

  export type ProductCookingMethodUpdateOneRequiredWithoutIntermediateProductCookingMethodsInput = {
    create?: XOR<ProductCookingMethodCreateWithoutIntermediateProductCookingMethodsInput, ProductCookingMethodUncheckedCreateWithoutIntermediateProductCookingMethodsInput>
    connectOrCreate?: ProductCookingMethodCreateOrConnectWithoutIntermediateProductCookingMethodsInput
    upsert?: ProductCookingMethodUpsertWithoutIntermediateProductCookingMethodsInput
    connect?: ProductCookingMethodWhereUniqueInput
    update?: XOR<ProductCookingMethodUpdateWithoutIntermediateProductCookingMethodsInput, ProductCookingMethodUncheckedUpdateWithoutIntermediateProductCookingMethodsInput>
  }

  export type CustomersCreateNestedOneWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput, CustomersUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerUnavailableCookingMethodsInput
    connect?: CustomersWhereUniqueInput
  }

  export type ProductCookingMethodCreateNestedOneWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    create?: XOR<ProductCookingMethodCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput, ProductCookingMethodUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
    connectOrCreate?: ProductCookingMethodCreateOrConnectWithoutIntermediateCustomerUnavailableCookingMethodsInput
    connect?: ProductCookingMethodWhereUniqueInput
  }

  export type CustomersUpdateOneRequiredWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput, CustomersUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerUnavailableCookingMethodsInput
    upsert?: CustomersUpsertWithoutIntermediateCustomerUnavailableCookingMethodsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput, CustomersUncheckedUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
  }

  export type ProductCookingMethodUpdateOneRequiredWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    create?: XOR<ProductCookingMethodCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput, ProductCookingMethodUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
    connectOrCreate?: ProductCookingMethodCreateOrConnectWithoutIntermediateCustomerUnavailableCookingMethodsInput
    upsert?: ProductCookingMethodUpsertWithoutIntermediateCustomerUnavailableCookingMethodsInput
    connect?: ProductCookingMethodWhereUniqueInput
    update?: XOR<ProductCookingMethodUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput, ProductCookingMethodUncheckedUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
  }

  export type IntermediateProductCookingMethodCreateNestedManyWithoutProductCookingMethodInput = {
    create?: XOR<Enumerable<IntermediateProductCookingMethodCreateWithoutProductCookingMethodInput>, Enumerable<IntermediateProductCookingMethodUncheckedCreateWithoutProductCookingMethodInput>>
    connectOrCreate?: Enumerable<IntermediateProductCookingMethodCreateOrConnectWithoutProductCookingMethodInput>
    createMany?: IntermediateProductCookingMethodCreateManyProductCookingMethodInputEnvelope
    connect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutProductCookingMethodInput = {
    create?: XOR<Enumerable<IntermediateCustomerUnavailableCookingMethodCreateWithoutProductCookingMethodInput>, Enumerable<IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutProductCookingMethodInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutProductCookingMethodInput>
    createMany?: IntermediateCustomerUnavailableCookingMethodCreateManyProductCookingMethodInputEnvelope
    connect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
  }

  export type IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductCookingMethodInput = {
    create?: XOR<Enumerable<IntermediateProductCookingMethodCreateWithoutProductCookingMethodInput>, Enumerable<IntermediateProductCookingMethodUncheckedCreateWithoutProductCookingMethodInput>>
    connectOrCreate?: Enumerable<IntermediateProductCookingMethodCreateOrConnectWithoutProductCookingMethodInput>
    createMany?: IntermediateProductCookingMethodCreateManyProductCookingMethodInputEnvelope
    connect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutProductCookingMethodInput = {
    create?: XOR<Enumerable<IntermediateCustomerUnavailableCookingMethodCreateWithoutProductCookingMethodInput>, Enumerable<IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutProductCookingMethodInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutProductCookingMethodInput>
    createMany?: IntermediateCustomerUnavailableCookingMethodCreateManyProductCookingMethodInputEnvelope
    connect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
  }

  export type IntermediateProductCookingMethodUpdateManyWithoutProductCookingMethodInput = {
    create?: XOR<Enumerable<IntermediateProductCookingMethodCreateWithoutProductCookingMethodInput>, Enumerable<IntermediateProductCookingMethodUncheckedCreateWithoutProductCookingMethodInput>>
    connectOrCreate?: Enumerable<IntermediateProductCookingMethodCreateOrConnectWithoutProductCookingMethodInput>
    upsert?: Enumerable<IntermediateProductCookingMethodUpsertWithWhereUniqueWithoutProductCookingMethodInput>
    createMany?: IntermediateProductCookingMethodCreateManyProductCookingMethodInputEnvelope
    set?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    delete?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    connect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    update?: Enumerable<IntermediateProductCookingMethodUpdateWithWhereUniqueWithoutProductCookingMethodInput>
    updateMany?: Enumerable<IntermediateProductCookingMethodUpdateManyWithWhereWithoutProductCookingMethodInput>
    deleteMany?: Enumerable<IntermediateProductCookingMethodScalarWhereInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutProductCookingMethodInput = {
    create?: XOR<Enumerable<IntermediateCustomerUnavailableCookingMethodCreateWithoutProductCookingMethodInput>, Enumerable<IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutProductCookingMethodInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutProductCookingMethodInput>
    upsert?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpsertWithWhereUniqueWithoutProductCookingMethodInput>
    createMany?: IntermediateCustomerUnavailableCookingMethodCreateManyProductCookingMethodInputEnvelope
    set?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpdateWithWhereUniqueWithoutProductCookingMethodInput>
    updateMany?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpdateManyWithWhereWithoutProductCookingMethodInput>
    deleteMany?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereInput>
  }

  export type IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductCookingMethodInput = {
    create?: XOR<Enumerable<IntermediateProductCookingMethodCreateWithoutProductCookingMethodInput>, Enumerable<IntermediateProductCookingMethodUncheckedCreateWithoutProductCookingMethodInput>>
    connectOrCreate?: Enumerable<IntermediateProductCookingMethodCreateOrConnectWithoutProductCookingMethodInput>
    upsert?: Enumerable<IntermediateProductCookingMethodUpsertWithWhereUniqueWithoutProductCookingMethodInput>
    createMany?: IntermediateProductCookingMethodCreateManyProductCookingMethodInputEnvelope
    set?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    delete?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    connect?: Enumerable<IntermediateProductCookingMethodWhereUniqueInput>
    update?: Enumerable<IntermediateProductCookingMethodUpdateWithWhereUniqueWithoutProductCookingMethodInput>
    updateMany?: Enumerable<IntermediateProductCookingMethodUpdateManyWithWhereWithoutProductCookingMethodInput>
    deleteMany?: Enumerable<IntermediateProductCookingMethodScalarWhereInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutProductCookingMethodInput = {
    create?: XOR<Enumerable<IntermediateCustomerUnavailableCookingMethodCreateWithoutProductCookingMethodInput>, Enumerable<IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutProductCookingMethodInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutProductCookingMethodInput>
    upsert?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpsertWithWhereUniqueWithoutProductCookingMethodInput>
    createMany?: IntermediateCustomerUnavailableCookingMethodCreateManyProductCookingMethodInputEnvelope
    set?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerUnavailableCookingMethodWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpdateWithWhereUniqueWithoutProductCookingMethodInput>
    updateMany?: Enumerable<IntermediateCustomerUnavailableCookingMethodUpdateManyWithWhereWithoutProductCookingMethodInput>
    deleteMany?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutProductFlavorInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductFlavorInput>, Enumerable<ProductUncheckedCreateWithoutProductFlavorInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductFlavorInput>
    createMany?: ProductCreateManyProductFlavorInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type IntermediateCustomerFlavorDislikeCreateNestedManyWithoutProductFlavorInput = {
    create?: XOR<Enumerable<IntermediateCustomerFlavorDislikeCreateWithoutProductFlavorInput>, Enumerable<IntermediateCustomerFlavorDislikeUncheckedCreateWithoutProductFlavorInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFlavorDislikeCreateOrConnectWithoutProductFlavorInput>
    createMany?: IntermediateCustomerFlavorDislikeCreateManyProductFlavorInputEnvelope
    connect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutProductFlavorInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductFlavorInput>, Enumerable<ProductUncheckedCreateWithoutProductFlavorInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductFlavorInput>
    createMany?: ProductCreateManyProductFlavorInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutProductFlavorInput = {
    create?: XOR<Enumerable<IntermediateCustomerFlavorDislikeCreateWithoutProductFlavorInput>, Enumerable<IntermediateCustomerFlavorDislikeUncheckedCreateWithoutProductFlavorInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFlavorDislikeCreateOrConnectWithoutProductFlavorInput>
    createMany?: IntermediateCustomerFlavorDislikeCreateManyProductFlavorInputEnvelope
    connect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutProductFlavorInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductFlavorInput>, Enumerable<ProductUncheckedCreateWithoutProductFlavorInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductFlavorInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductFlavorInput>
    createMany?: ProductCreateManyProductFlavorInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductFlavorInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductFlavorInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type IntermediateCustomerFlavorDislikeUpdateManyWithoutProductFlavorInput = {
    create?: XOR<Enumerable<IntermediateCustomerFlavorDislikeCreateWithoutProductFlavorInput>, Enumerable<IntermediateCustomerFlavorDislikeUncheckedCreateWithoutProductFlavorInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFlavorDislikeCreateOrConnectWithoutProductFlavorInput>
    upsert?: Enumerable<IntermediateCustomerFlavorDislikeUpsertWithWhereUniqueWithoutProductFlavorInput>
    createMany?: IntermediateCustomerFlavorDislikeCreateManyProductFlavorInputEnvelope
    set?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerFlavorDislikeUpdateWithWhereUniqueWithoutProductFlavorInput>
    updateMany?: Enumerable<IntermediateCustomerFlavorDislikeUpdateManyWithWhereWithoutProductFlavorInput>
    deleteMany?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductFlavorInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductFlavorInput>, Enumerable<ProductUncheckedCreateWithoutProductFlavorInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductFlavorInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductFlavorInput>
    createMany?: ProductCreateManyProductFlavorInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductFlavorInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductFlavorInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutProductFlavorInput = {
    create?: XOR<Enumerable<IntermediateCustomerFlavorDislikeCreateWithoutProductFlavorInput>, Enumerable<IntermediateCustomerFlavorDislikeUncheckedCreateWithoutProductFlavorInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerFlavorDislikeCreateOrConnectWithoutProductFlavorInput>
    upsert?: Enumerable<IntermediateCustomerFlavorDislikeUpsertWithWhereUniqueWithoutProductFlavorInput>
    createMany?: IntermediateCustomerFlavorDislikeCreateManyProductFlavorInputEnvelope
    set?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerFlavorDislikeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerFlavorDislikeUpdateWithWhereUniqueWithoutProductFlavorInput>
    updateMany?: Enumerable<IntermediateCustomerFlavorDislikeUpdateManyWithWhereWithoutProductFlavorInput>
    deleteMany?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutProductVendorInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductVendorInput>, Enumerable<ProductUncheckedCreateWithoutProductVendorInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductVendorInput>
    createMany?: ProductCreateManyProductVendorInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutProductVendorInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductVendorInput>, Enumerable<ProductUncheckedCreateWithoutProductVendorInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductVendorInput>
    createMany?: ProductCreateManyProductVendorInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutProductVendorInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductVendorInput>, Enumerable<ProductUncheckedCreateWithoutProductVendorInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductVendorInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductVendorInput>
    createMany?: ProductCreateManyProductVendorInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductVendorInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductVendorInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductVendorInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductVendorInput>, Enumerable<ProductUncheckedCreateWithoutProductVendorInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductVendorInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductVendorInput>
    createMany?: ProductCreateManyProductVendorInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductVendorInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductVendorInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductFlavorCreateNestedOneWithoutIntermediateCustomerFlavorDislikesInput = {
    create?: XOR<ProductFlavorCreateWithoutIntermediateCustomerFlavorDislikesInput, ProductFlavorUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput>
    connectOrCreate?: ProductFlavorCreateOrConnectWithoutIntermediateCustomerFlavorDislikesInput
    connect?: ProductFlavorWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutIntermediateCustomerFlavorDislikesInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerFlavorDislikesInput, CustomersUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerFlavorDislikesInput
    connect?: CustomersWhereUniqueInput
  }

  export type ProductFlavorUpdateOneRequiredWithoutIntermediateCustomerFlavorDislikesInput = {
    create?: XOR<ProductFlavorCreateWithoutIntermediateCustomerFlavorDislikesInput, ProductFlavorUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput>
    connectOrCreate?: ProductFlavorCreateOrConnectWithoutIntermediateCustomerFlavorDislikesInput
    upsert?: ProductFlavorUpsertWithoutIntermediateCustomerFlavorDislikesInput
    connect?: ProductFlavorWhereUniqueInput
    update?: XOR<ProductFlavorUpdateWithoutIntermediateCustomerFlavorDislikesInput, ProductFlavorUncheckedUpdateWithoutIntermediateCustomerFlavorDislikesInput>
  }

  export type CustomersUpdateOneRequiredWithoutIntermediateCustomerFlavorDislikesInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerFlavorDislikesInput, CustomersUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerFlavorDislikesInput
    upsert?: CustomersUpsertWithoutIntermediateCustomerFlavorDislikesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutIntermediateCustomerFlavorDislikesInput, CustomersUncheckedUpdateWithoutIntermediateCustomerFlavorDislikesInput>
  }

  export type ProductCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductCategoryInput>, Enumerable<ProductUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductCategoryInput>
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<IntermediateCustomerCategoryPreferenceCreateWithoutProductCategoryInput>, Enumerable<IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutProductCategoryInput>
    createMany?: IntermediateCustomerCategoryPreferenceCreateManyProductCategoryInputEnvelope
    connect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductCategoryInput>, Enumerable<ProductUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductCategoryInput>
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<IntermediateCustomerCategoryPreferenceCreateWithoutProductCategoryInput>, Enumerable<IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutProductCategoryInput>
    createMany?: IntermediateCustomerCategoryPreferenceCreateManyProductCategoryInputEnvelope
    connect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductCategoryInput>, Enumerable<ProductUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductCategoryInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductCategoryInput>
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductCategoryInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductCategoryInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type IntermediateCustomerCategoryPreferenceUpdateManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<IntermediateCustomerCategoryPreferenceCreateWithoutProductCategoryInput>, Enumerable<IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutProductCategoryInput>
    upsert?: Enumerable<IntermediateCustomerCategoryPreferenceUpsertWithWhereUniqueWithoutProductCategoryInput>
    createMany?: IntermediateCustomerCategoryPreferenceCreateManyProductCategoryInputEnvelope
    set?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerCategoryPreferenceUpdateWithWhereUniqueWithoutProductCategoryInput>
    updateMany?: Enumerable<IntermediateCustomerCategoryPreferenceUpdateManyWithWhereWithoutProductCategoryInput>
    deleteMany?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductCategoryInput>, Enumerable<ProductUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductCategoryInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductCategoryInput>
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductCategoryInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductCategoryInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<IntermediateCustomerCategoryPreferenceCreateWithoutProductCategoryInput>, Enumerable<IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutProductCategoryInput>
    upsert?: Enumerable<IntermediateCustomerCategoryPreferenceUpsertWithWhereUniqueWithoutProductCategoryInput>
    createMany?: IntermediateCustomerCategoryPreferenceCreateManyProductCategoryInputEnvelope
    set?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerCategoryPreferenceWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerCategoryPreferenceUpdateWithWhereUniqueWithoutProductCategoryInput>
    updateMany?: Enumerable<IntermediateCustomerCategoryPreferenceUpdateManyWithWhereWithoutProductCategoryInput>
    deleteMany?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereInput>
  }

  export type ProductCategoryCreateNestedOneWithoutIntermediateCustomerCategoryPreferencesInput = {
    create?: XOR<ProductCategoryCreateWithoutIntermediateCustomerCategoryPreferencesInput, ProductCategoryUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutIntermediateCustomerCategoryPreferencesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutIntermediateCustomerCategoryPreferencesInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerCategoryPreferencesInput, CustomersUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerCategoryPreferencesInput
    connect?: CustomersWhereUniqueInput
  }

  export type ProductCategoryUpdateOneRequiredWithoutIntermediateCustomerCategoryPreferencesInput = {
    create?: XOR<ProductCategoryCreateWithoutIntermediateCustomerCategoryPreferencesInput, ProductCategoryUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutIntermediateCustomerCategoryPreferencesInput
    upsert?: ProductCategoryUpsertWithoutIntermediateCustomerCategoryPreferencesInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<ProductCategoryUpdateWithoutIntermediateCustomerCategoryPreferencesInput, ProductCategoryUncheckedUpdateWithoutIntermediateCustomerCategoryPreferencesInput>
  }

  export type CustomersUpdateOneRequiredWithoutIntermediateCustomerCategoryPreferencesInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerCategoryPreferencesInput, CustomersUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerCategoryPreferencesInput
    upsert?: CustomersUpsertWithoutIntermediateCustomerCategoryPreferencesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutIntermediateCustomerCategoryPreferencesInput, CustomersUncheckedUpdateWithoutIntermediateCustomerCategoryPreferencesInput>
  }

  export type ProductCreateNestedOneWithoutIntermediateProductIngredientsInput = {
    create?: XOR<ProductCreateWithoutIntermediateProductIngredientsInput, ProductUncheckedCreateWithoutIntermediateProductIngredientsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediateProductIngredientsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductIngredientCreateNestedOneWithoutIntermediateProductIngredientsInput = {
    create?: XOR<ProductIngredientCreateWithoutIntermediateProductIngredientsInput, ProductIngredientUncheckedCreateWithoutIntermediateProductIngredientsInput>
    connectOrCreate?: ProductIngredientCreateOrConnectWithoutIntermediateProductIngredientsInput
    connect?: ProductIngredientWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutIntermediateProductIngredientsInput = {
    create?: XOR<ProductCreateWithoutIntermediateProductIngredientsInput, ProductUncheckedCreateWithoutIntermediateProductIngredientsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediateProductIngredientsInput
    upsert?: ProductUpsertWithoutIntermediateProductIngredientsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutIntermediateProductIngredientsInput, ProductUncheckedUpdateWithoutIntermediateProductIngredientsInput>
  }

  export type ProductIngredientUpdateOneRequiredWithoutIntermediateProductIngredientsInput = {
    create?: XOR<ProductIngredientCreateWithoutIntermediateProductIngredientsInput, ProductIngredientUncheckedCreateWithoutIntermediateProductIngredientsInput>
    connectOrCreate?: ProductIngredientCreateOrConnectWithoutIntermediateProductIngredientsInput
    upsert?: ProductIngredientUpsertWithoutIntermediateProductIngredientsInput
    connect?: ProductIngredientWhereUniqueInput
    update?: XOR<ProductIngredientUpdateWithoutIntermediateProductIngredientsInput, ProductIngredientUncheckedUpdateWithoutIntermediateProductIngredientsInput>
  }

  export type IntermediateProductIngredientCreateNestedManyWithoutProductIngredientInput = {
    create?: XOR<Enumerable<IntermediateProductIngredientCreateWithoutProductIngredientInput>, Enumerable<IntermediateProductIngredientUncheckedCreateWithoutProductIngredientInput>>
    connectOrCreate?: Enumerable<IntermediateProductIngredientCreateOrConnectWithoutProductIngredientInput>
    createMany?: IntermediateProductIngredientCreateManyProductIngredientInputEnvelope
    connect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
  }

  export type IntermediateCustomerIngredientDislikeCreateNestedManyWithoutProductIngredientInput = {
    create?: XOR<Enumerable<IntermediateCustomerIngredientDislikeCreateWithoutProductIngredientInput>, Enumerable<IntermediateCustomerIngredientDislikeUncheckedCreateWithoutProductIngredientInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerIngredientDislikeCreateOrConnectWithoutProductIngredientInput>
    createMany?: IntermediateCustomerIngredientDislikeCreateManyProductIngredientInputEnvelope
    connect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
  }

  export type IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductIngredientInput = {
    create?: XOR<Enumerable<IntermediateProductIngredientCreateWithoutProductIngredientInput>, Enumerable<IntermediateProductIngredientUncheckedCreateWithoutProductIngredientInput>>
    connectOrCreate?: Enumerable<IntermediateProductIngredientCreateOrConnectWithoutProductIngredientInput>
    createMany?: IntermediateProductIngredientCreateManyProductIngredientInputEnvelope
    connect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
  }

  export type IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutProductIngredientInput = {
    create?: XOR<Enumerable<IntermediateCustomerIngredientDislikeCreateWithoutProductIngredientInput>, Enumerable<IntermediateCustomerIngredientDislikeUncheckedCreateWithoutProductIngredientInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerIngredientDislikeCreateOrConnectWithoutProductIngredientInput>
    createMany?: IntermediateCustomerIngredientDislikeCreateManyProductIngredientInputEnvelope
    connect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
  }

  export type IntermediateProductIngredientUpdateManyWithoutProductIngredientInput = {
    create?: XOR<Enumerable<IntermediateProductIngredientCreateWithoutProductIngredientInput>, Enumerable<IntermediateProductIngredientUncheckedCreateWithoutProductIngredientInput>>
    connectOrCreate?: Enumerable<IntermediateProductIngredientCreateOrConnectWithoutProductIngredientInput>
    upsert?: Enumerable<IntermediateProductIngredientUpsertWithWhereUniqueWithoutProductIngredientInput>
    createMany?: IntermediateProductIngredientCreateManyProductIngredientInputEnvelope
    set?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    delete?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    connect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    update?: Enumerable<IntermediateProductIngredientUpdateWithWhereUniqueWithoutProductIngredientInput>
    updateMany?: Enumerable<IntermediateProductIngredientUpdateManyWithWhereWithoutProductIngredientInput>
    deleteMany?: Enumerable<IntermediateProductIngredientScalarWhereInput>
  }

  export type IntermediateCustomerIngredientDislikeUpdateManyWithoutProductIngredientInput = {
    create?: XOR<Enumerable<IntermediateCustomerIngredientDislikeCreateWithoutProductIngredientInput>, Enumerable<IntermediateCustomerIngredientDislikeUncheckedCreateWithoutProductIngredientInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerIngredientDislikeCreateOrConnectWithoutProductIngredientInput>
    upsert?: Enumerable<IntermediateCustomerIngredientDislikeUpsertWithWhereUniqueWithoutProductIngredientInput>
    createMany?: IntermediateCustomerIngredientDislikeCreateManyProductIngredientInputEnvelope
    set?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerIngredientDislikeUpdateWithWhereUniqueWithoutProductIngredientInput>
    updateMany?: Enumerable<IntermediateCustomerIngredientDislikeUpdateManyWithWhereWithoutProductIngredientInput>
    deleteMany?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereInput>
  }

  export type IntermediateProductIngredientUncheckedUpdateManyWithoutProductIngredientInput = {
    create?: XOR<Enumerable<IntermediateProductIngredientCreateWithoutProductIngredientInput>, Enumerable<IntermediateProductIngredientUncheckedCreateWithoutProductIngredientInput>>
    connectOrCreate?: Enumerable<IntermediateProductIngredientCreateOrConnectWithoutProductIngredientInput>
    upsert?: Enumerable<IntermediateProductIngredientUpsertWithWhereUniqueWithoutProductIngredientInput>
    createMany?: IntermediateProductIngredientCreateManyProductIngredientInputEnvelope
    set?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    delete?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    connect?: Enumerable<IntermediateProductIngredientWhereUniqueInput>
    update?: Enumerable<IntermediateProductIngredientUpdateWithWhereUniqueWithoutProductIngredientInput>
    updateMany?: Enumerable<IntermediateProductIngredientUpdateManyWithWhereWithoutProductIngredientInput>
    deleteMany?: Enumerable<IntermediateProductIngredientScalarWhereInput>
  }

  export type IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutProductIngredientInput = {
    create?: XOR<Enumerable<IntermediateCustomerIngredientDislikeCreateWithoutProductIngredientInput>, Enumerable<IntermediateCustomerIngredientDislikeUncheckedCreateWithoutProductIngredientInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerIngredientDislikeCreateOrConnectWithoutProductIngredientInput>
    upsert?: Enumerable<IntermediateCustomerIngredientDislikeUpsertWithWhereUniqueWithoutProductIngredientInput>
    createMany?: IntermediateCustomerIngredientDislikeCreateManyProductIngredientInputEnvelope
    set?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerIngredientDislikeWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerIngredientDislikeUpdateWithWhereUniqueWithoutProductIngredientInput>
    updateMany?: Enumerable<IntermediateCustomerIngredientDislikeUpdateManyWithWhereWithoutProductIngredientInput>
    deleteMany?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereInput>
  }

  export type ProductIngredientCreateNestedOneWithoutIntermediateCustomerIngredientDislikesInput = {
    create?: XOR<ProductIngredientCreateWithoutIntermediateCustomerIngredientDislikesInput, ProductIngredientUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput>
    connectOrCreate?: ProductIngredientCreateOrConnectWithoutIntermediateCustomerIngredientDislikesInput
    connect?: ProductIngredientWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutIntermediateCustomerIngredientDislikesInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerIngredientDislikesInput, CustomersUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerIngredientDislikesInput
    connect?: CustomersWhereUniqueInput
  }

  export type ProductIngredientUpdateOneRequiredWithoutIntermediateCustomerIngredientDislikesInput = {
    create?: XOR<ProductIngredientCreateWithoutIntermediateCustomerIngredientDislikesInput, ProductIngredientUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput>
    connectOrCreate?: ProductIngredientCreateOrConnectWithoutIntermediateCustomerIngredientDislikesInput
    upsert?: ProductIngredientUpsertWithoutIntermediateCustomerIngredientDislikesInput
    connect?: ProductIngredientWhereUniqueInput
    update?: XOR<ProductIngredientUpdateWithoutIntermediateCustomerIngredientDislikesInput, ProductIngredientUncheckedUpdateWithoutIntermediateCustomerIngredientDislikesInput>
  }

  export type CustomersUpdateOneRequiredWithoutIntermediateCustomerIngredientDislikesInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerIngredientDislikesInput, CustomersUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerIngredientDislikesInput
    upsert?: CustomersUpsertWithoutIntermediateCustomerIngredientDislikesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutIntermediateCustomerIngredientDislikesInput, CustomersUncheckedUpdateWithoutIntermediateCustomerIngredientDislikesInput>
  }

  export type ProductCreateNestedOneWithoutIntermediateProductAllergensInput = {
    create?: XOR<ProductCreateWithoutIntermediateProductAllergensInput, ProductUncheckedCreateWithoutIntermediateProductAllergensInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediateProductAllergensInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductAllergenCreateNestedOneWithoutIntermediateProductAllergensInput = {
    create?: XOR<ProductAllergenCreateWithoutIntermediateProductAllergensInput, ProductAllergenUncheckedCreateWithoutIntermediateProductAllergensInput>
    connectOrCreate?: ProductAllergenCreateOrConnectWithoutIntermediateProductAllergensInput
    connect?: ProductAllergenWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutIntermediateProductAllergensInput = {
    create?: XOR<ProductCreateWithoutIntermediateProductAllergensInput, ProductUncheckedCreateWithoutIntermediateProductAllergensInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediateProductAllergensInput
    upsert?: ProductUpsertWithoutIntermediateProductAllergensInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutIntermediateProductAllergensInput, ProductUncheckedUpdateWithoutIntermediateProductAllergensInput>
  }

  export type ProductAllergenUpdateOneRequiredWithoutIntermediateProductAllergensInput = {
    create?: XOR<ProductAllergenCreateWithoutIntermediateProductAllergensInput, ProductAllergenUncheckedCreateWithoutIntermediateProductAllergensInput>
    connectOrCreate?: ProductAllergenCreateOrConnectWithoutIntermediateProductAllergensInput
    upsert?: ProductAllergenUpsertWithoutIntermediateProductAllergensInput
    connect?: ProductAllergenWhereUniqueInput
    update?: XOR<ProductAllergenUpdateWithoutIntermediateProductAllergensInput, ProductAllergenUncheckedUpdateWithoutIntermediateProductAllergensInput>
  }

  export type IntermediateProductAllergenCreateNestedManyWithoutProductAllergenInput = {
    create?: XOR<Enumerable<IntermediateProductAllergenCreateWithoutProductAllergenInput>, Enumerable<IntermediateProductAllergenUncheckedCreateWithoutProductAllergenInput>>
    connectOrCreate?: Enumerable<IntermediateProductAllergenCreateOrConnectWithoutProductAllergenInput>
    createMany?: IntermediateProductAllergenCreateManyProductAllergenInputEnvelope
    connect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
  }

  export type IntermediateCustomerAllergenCreateNestedManyWithoutProductAllergenInput = {
    create?: XOR<Enumerable<IntermediateCustomerAllergenCreateWithoutProductAllergenInput>, Enumerable<IntermediateCustomerAllergenUncheckedCreateWithoutProductAllergenInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerAllergenCreateOrConnectWithoutProductAllergenInput>
    createMany?: IntermediateCustomerAllergenCreateManyProductAllergenInputEnvelope
    connect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
  }

  export type IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductAllergenInput = {
    create?: XOR<Enumerable<IntermediateProductAllergenCreateWithoutProductAllergenInput>, Enumerable<IntermediateProductAllergenUncheckedCreateWithoutProductAllergenInput>>
    connectOrCreate?: Enumerable<IntermediateProductAllergenCreateOrConnectWithoutProductAllergenInput>
    createMany?: IntermediateProductAllergenCreateManyProductAllergenInputEnvelope
    connect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
  }

  export type IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutProductAllergenInput = {
    create?: XOR<Enumerable<IntermediateCustomerAllergenCreateWithoutProductAllergenInput>, Enumerable<IntermediateCustomerAllergenUncheckedCreateWithoutProductAllergenInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerAllergenCreateOrConnectWithoutProductAllergenInput>
    createMany?: IntermediateCustomerAllergenCreateManyProductAllergenInputEnvelope
    connect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
  }

  export type IntermediateProductAllergenUpdateManyWithoutProductAllergenInput = {
    create?: XOR<Enumerable<IntermediateProductAllergenCreateWithoutProductAllergenInput>, Enumerable<IntermediateProductAllergenUncheckedCreateWithoutProductAllergenInput>>
    connectOrCreate?: Enumerable<IntermediateProductAllergenCreateOrConnectWithoutProductAllergenInput>
    upsert?: Enumerable<IntermediateProductAllergenUpsertWithWhereUniqueWithoutProductAllergenInput>
    createMany?: IntermediateProductAllergenCreateManyProductAllergenInputEnvelope
    set?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    delete?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    connect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    update?: Enumerable<IntermediateProductAllergenUpdateWithWhereUniqueWithoutProductAllergenInput>
    updateMany?: Enumerable<IntermediateProductAllergenUpdateManyWithWhereWithoutProductAllergenInput>
    deleteMany?: Enumerable<IntermediateProductAllergenScalarWhereInput>
  }

  export type IntermediateCustomerAllergenUpdateManyWithoutProductAllergenInput = {
    create?: XOR<Enumerable<IntermediateCustomerAllergenCreateWithoutProductAllergenInput>, Enumerable<IntermediateCustomerAllergenUncheckedCreateWithoutProductAllergenInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerAllergenCreateOrConnectWithoutProductAllergenInput>
    upsert?: Enumerable<IntermediateCustomerAllergenUpsertWithWhereUniqueWithoutProductAllergenInput>
    createMany?: IntermediateCustomerAllergenCreateManyProductAllergenInputEnvelope
    set?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerAllergenUpdateWithWhereUniqueWithoutProductAllergenInput>
    updateMany?: Enumerable<IntermediateCustomerAllergenUpdateManyWithWhereWithoutProductAllergenInput>
    deleteMany?: Enumerable<IntermediateCustomerAllergenScalarWhereInput>
  }

  export type IntermediateProductAllergenUncheckedUpdateManyWithoutProductAllergenInput = {
    create?: XOR<Enumerable<IntermediateProductAllergenCreateWithoutProductAllergenInput>, Enumerable<IntermediateProductAllergenUncheckedCreateWithoutProductAllergenInput>>
    connectOrCreate?: Enumerable<IntermediateProductAllergenCreateOrConnectWithoutProductAllergenInput>
    upsert?: Enumerable<IntermediateProductAllergenUpsertWithWhereUniqueWithoutProductAllergenInput>
    createMany?: IntermediateProductAllergenCreateManyProductAllergenInputEnvelope
    set?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    disconnect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    delete?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    connect?: Enumerable<IntermediateProductAllergenWhereUniqueInput>
    update?: Enumerable<IntermediateProductAllergenUpdateWithWhereUniqueWithoutProductAllergenInput>
    updateMany?: Enumerable<IntermediateProductAllergenUpdateManyWithWhereWithoutProductAllergenInput>
    deleteMany?: Enumerable<IntermediateProductAllergenScalarWhereInput>
  }

  export type IntermediateCustomerAllergenUncheckedUpdateManyWithoutProductAllergenInput = {
    create?: XOR<Enumerable<IntermediateCustomerAllergenCreateWithoutProductAllergenInput>, Enumerable<IntermediateCustomerAllergenUncheckedCreateWithoutProductAllergenInput>>
    connectOrCreate?: Enumerable<IntermediateCustomerAllergenCreateOrConnectWithoutProductAllergenInput>
    upsert?: Enumerable<IntermediateCustomerAllergenUpsertWithWhereUniqueWithoutProductAllergenInput>
    createMany?: IntermediateCustomerAllergenCreateManyProductAllergenInputEnvelope
    set?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    disconnect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    delete?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    connect?: Enumerable<IntermediateCustomerAllergenWhereUniqueInput>
    update?: Enumerable<IntermediateCustomerAllergenUpdateWithWhereUniqueWithoutProductAllergenInput>
    updateMany?: Enumerable<IntermediateCustomerAllergenUpdateManyWithWhereWithoutProductAllergenInput>
    deleteMany?: Enumerable<IntermediateCustomerAllergenScalarWhereInput>
  }

  export type CustomersCreateNestedOneWithoutIntermediateCustomerAllergensInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerAllergensInput, CustomersUncheckedCreateWithoutIntermediateCustomerAllergensInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerAllergensInput
    connect?: CustomersWhereUniqueInput
  }

  export type ProductAllergenCreateNestedOneWithoutIntermediateCustomerAllergensInput = {
    create?: XOR<ProductAllergenCreateWithoutIntermediateCustomerAllergensInput, ProductAllergenUncheckedCreateWithoutIntermediateCustomerAllergensInput>
    connectOrCreate?: ProductAllergenCreateOrConnectWithoutIntermediateCustomerAllergensInput
    connect?: ProductAllergenWhereUniqueInput
  }

  export type CustomersUpdateOneRequiredWithoutIntermediateCustomerAllergensInput = {
    create?: XOR<CustomersCreateWithoutIntermediateCustomerAllergensInput, CustomersUncheckedCreateWithoutIntermediateCustomerAllergensInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutIntermediateCustomerAllergensInput
    upsert?: CustomersUpsertWithoutIntermediateCustomerAllergensInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutIntermediateCustomerAllergensInput, CustomersUncheckedUpdateWithoutIntermediateCustomerAllergensInput>
  }

  export type ProductAllergenUpdateOneRequiredWithoutIntermediateCustomerAllergensInput = {
    create?: XOR<ProductAllergenCreateWithoutIntermediateCustomerAllergensInput, ProductAllergenUncheckedCreateWithoutIntermediateCustomerAllergensInput>
    connectOrCreate?: ProductAllergenCreateOrConnectWithoutIntermediateCustomerAllergensInput
    upsert?: ProductAllergenUpsertWithoutIntermediateCustomerAllergensInput
    connect?: ProductAllergenWhereUniqueInput
    update?: XOR<ProductAllergenUpdateWithoutIntermediateCustomerAllergensInput, ProductAllergenUncheckedUpdateWithoutIntermediateCustomerAllergensInput>
  }

  export type ProductCreateNestedOneWithoutProductNutritionFactInput = {
    create?: XOR<ProductCreateWithoutProductNutritionFactInput, ProductUncheckedCreateWithoutProductNutritionFactInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductNutritionFactInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductNutritionFactInput = {
    create?: XOR<ProductCreateWithoutProductNutritionFactInput, ProductUncheckedCreateWithoutProductNutritionFactInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductNutritionFactInput
    upsert?: ProductUpsertWithoutProductNutritionFactInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProductNutritionFactInput, ProductUncheckedUpdateWithoutProductNutritionFactInput>
  }

  export type ProductCreateNestedManyWithoutProductProviderInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductProviderInput>, Enumerable<ProductUncheckedCreateWithoutProductProviderInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductProviderInput>
    createMany?: ProductCreateManyProductProviderInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutProductProviderInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductProviderInput>, Enumerable<ProductUncheckedCreateWithoutProductProviderInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductProviderInput>
    createMany?: ProductCreateManyProductProviderInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutProductProviderInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductProviderInput>, Enumerable<ProductUncheckedCreateWithoutProductProviderInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductProviderInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductProviderInput>
    createMany?: ProductCreateManyProductProviderInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductProviderInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductProviderInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductProviderInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductProviderInput>, Enumerable<ProductUncheckedCreateWithoutProductProviderInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductProviderInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductProviderInput>
    createMany?: ProductCreateManyProductProviderInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductProviderInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductProviderInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type IntermediateSurveyQuestionCreateNestedManyWithoutSurveyInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionCreateWithoutSurveyInput>, Enumerable<IntermediateSurveyQuestionUncheckedCreateWithoutSurveyInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionCreateOrConnectWithoutSurveyInput>
    createMany?: IntermediateSurveyQuestionCreateManySurveyInputEnvelope
    connect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
  }

  export type IntermediateSurveyQuestionUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionCreateWithoutSurveyInput>, Enumerable<IntermediateSurveyQuestionUncheckedCreateWithoutSurveyInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionCreateOrConnectWithoutSurveyInput>
    createMany?: IntermediateSurveyQuestionCreateManySurveyInputEnvelope
    connect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
  }

  export type IntermediateSurveyQuestionUpdateManyWithoutSurveyInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionCreateWithoutSurveyInput>, Enumerable<IntermediateSurveyQuestionUncheckedCreateWithoutSurveyInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionCreateOrConnectWithoutSurveyInput>
    upsert?: Enumerable<IntermediateSurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput>
    createMany?: IntermediateSurveyQuestionCreateManySurveyInputEnvelope
    set?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    disconnect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    delete?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    connect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    update?: Enumerable<IntermediateSurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput>
    updateMany?: Enumerable<IntermediateSurveyQuestionUpdateManyWithWhereWithoutSurveyInput>
    deleteMany?: Enumerable<IntermediateSurveyQuestionScalarWhereInput>
  }

  export type IntermediateSurveyQuestionUncheckedUpdateManyWithoutSurveyInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionCreateWithoutSurveyInput>, Enumerable<IntermediateSurveyQuestionUncheckedCreateWithoutSurveyInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionCreateOrConnectWithoutSurveyInput>
    upsert?: Enumerable<IntermediateSurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput>
    createMany?: IntermediateSurveyQuestionCreateManySurveyInputEnvelope
    set?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    disconnect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    delete?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    connect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    update?: Enumerable<IntermediateSurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput>
    updateMany?: Enumerable<IntermediateSurveyQuestionUpdateManyWithWhereWithoutSurveyInput>
    deleteMany?: Enumerable<IntermediateSurveyQuestionScalarWhereInput>
  }

  export type SurveyCreateNestedOneWithoutIntermediateSurveyQuestionsInput = {
    create?: XOR<SurveyCreateWithoutIntermediateSurveyQuestionsInput, SurveyUncheckedCreateWithoutIntermediateSurveyQuestionsInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutIntermediateSurveyQuestionsInput
    connect?: SurveyWhereUniqueInput
  }

  export type SurveyQuestionCreateNestedOneWithoutIntermediateSurveyQuestionsInput = {
    create?: XOR<SurveyQuestionCreateWithoutIntermediateSurveyQuestionsInput, SurveyQuestionUncheckedCreateWithoutIntermediateSurveyQuestionsInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutIntermediateSurveyQuestionsInput
    connect?: SurveyQuestionWhereUniqueInput
  }

  export type SurveyUpdateOneRequiredWithoutIntermediateSurveyQuestionsInput = {
    create?: XOR<SurveyCreateWithoutIntermediateSurveyQuestionsInput, SurveyUncheckedCreateWithoutIntermediateSurveyQuestionsInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutIntermediateSurveyQuestionsInput
    upsert?: SurveyUpsertWithoutIntermediateSurveyQuestionsInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<SurveyUpdateWithoutIntermediateSurveyQuestionsInput, SurveyUncheckedUpdateWithoutIntermediateSurveyQuestionsInput>
  }

  export type SurveyQuestionUpdateOneRequiredWithoutIntermediateSurveyQuestionsInput = {
    create?: XOR<SurveyQuestionCreateWithoutIntermediateSurveyQuestionsInput, SurveyQuestionUncheckedCreateWithoutIntermediateSurveyQuestionsInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutIntermediateSurveyQuestionsInput
    upsert?: SurveyQuestionUpsertWithoutIntermediateSurveyQuestionsInput
    connect?: SurveyQuestionWhereUniqueInput
    update?: XOR<SurveyQuestionUpdateWithoutIntermediateSurveyQuestionsInput, SurveyQuestionUncheckedUpdateWithoutIntermediateSurveyQuestionsInput>
  }

  export type QuestionCategoryCreateNestedOneWithoutSurveyQuestionsInput = {
    create?: XOR<QuestionCategoryCreateWithoutSurveyQuestionsInput, QuestionCategoryUncheckedCreateWithoutSurveyQuestionsInput>
    connectOrCreate?: QuestionCategoryCreateOrConnectWithoutSurveyQuestionsInput
    connect?: QuestionCategoryWhereUniqueInput
  }

  export type SurveyQuestionAnswerTypeCreateNestedOneWithoutSurveyQuestionsInput = {
    create?: XOR<SurveyQuestionAnswerTypeCreateWithoutSurveyQuestionsInput, SurveyQuestionAnswerTypeUncheckedCreateWithoutSurveyQuestionsInput>
    connectOrCreate?: SurveyQuestionAnswerTypeCreateOrConnectWithoutSurveyQuestionsInput
    connect?: SurveyQuestionAnswerTypeWhereUniqueInput
  }

  export type IntermediateSurveyQuestionCreateNestedManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionCreateWithoutSurveyQuestionInput>, Enumerable<IntermediateSurveyQuestionUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionCreateOrConnectWithoutSurveyQuestionInput>
    createMany?: IntermediateSurveyQuestionCreateManySurveyQuestionInputEnvelope
    connect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
  }

  export type SurveyQuestionOptionCreateNestedManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<SurveyQuestionOptionCreateWithoutSurveyQuestionInput>, Enumerable<SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionOptionCreateOrConnectWithoutSurveyQuestionInput>
    createMany?: SurveyQuestionOptionCreateManySurveyQuestionInputEnvelope
    connect?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
  }

  export type SurveyQuestionAnswerCreateNestedManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutSurveyQuestionInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutSurveyQuestionInput>
    createMany?: SurveyQuestionAnswerCreateManySurveyQuestionInputEnvelope
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
  }

  export type IntermediateSurveyQuestionUncheckedCreateNestedManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionCreateWithoutSurveyQuestionInput>, Enumerable<IntermediateSurveyQuestionUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionCreateOrConnectWithoutSurveyQuestionInput>
    createMany?: IntermediateSurveyQuestionCreateManySurveyQuestionInputEnvelope
    connect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
  }

  export type SurveyQuestionOptionUncheckedCreateNestedManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<SurveyQuestionOptionCreateWithoutSurveyQuestionInput>, Enumerable<SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionOptionCreateOrConnectWithoutSurveyQuestionInput>
    createMany?: SurveyQuestionOptionCreateManySurveyQuestionInputEnvelope
    connect?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
  }

  export type SurveyQuestionAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutSurveyQuestionInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutSurveyQuestionInput>
    createMany?: SurveyQuestionAnswerCreateManySurveyQuestionInputEnvelope
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type QuestionCategoryUpdateOneRequiredWithoutSurveyQuestionsInput = {
    create?: XOR<QuestionCategoryCreateWithoutSurveyQuestionsInput, QuestionCategoryUncheckedCreateWithoutSurveyQuestionsInput>
    connectOrCreate?: QuestionCategoryCreateOrConnectWithoutSurveyQuestionsInput
    upsert?: QuestionCategoryUpsertWithoutSurveyQuestionsInput
    connect?: QuestionCategoryWhereUniqueInput
    update?: XOR<QuestionCategoryUpdateWithoutSurveyQuestionsInput, QuestionCategoryUncheckedUpdateWithoutSurveyQuestionsInput>
  }

  export type SurveyQuestionAnswerTypeUpdateOneRequiredWithoutSurveyQuestionsInput = {
    create?: XOR<SurveyQuestionAnswerTypeCreateWithoutSurveyQuestionsInput, SurveyQuestionAnswerTypeUncheckedCreateWithoutSurveyQuestionsInput>
    connectOrCreate?: SurveyQuestionAnswerTypeCreateOrConnectWithoutSurveyQuestionsInput
    upsert?: SurveyQuestionAnswerTypeUpsertWithoutSurveyQuestionsInput
    connect?: SurveyQuestionAnswerTypeWhereUniqueInput
    update?: XOR<SurveyQuestionAnswerTypeUpdateWithoutSurveyQuestionsInput, SurveyQuestionAnswerTypeUncheckedUpdateWithoutSurveyQuestionsInput>
  }

  export type IntermediateSurveyQuestionUpdateManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionCreateWithoutSurveyQuestionInput>, Enumerable<IntermediateSurveyQuestionUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionCreateOrConnectWithoutSurveyQuestionInput>
    upsert?: Enumerable<IntermediateSurveyQuestionUpsertWithWhereUniqueWithoutSurveyQuestionInput>
    createMany?: IntermediateSurveyQuestionCreateManySurveyQuestionInputEnvelope
    set?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    disconnect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    delete?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    connect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    update?: Enumerable<IntermediateSurveyQuestionUpdateWithWhereUniqueWithoutSurveyQuestionInput>
    updateMany?: Enumerable<IntermediateSurveyQuestionUpdateManyWithWhereWithoutSurveyQuestionInput>
    deleteMany?: Enumerable<IntermediateSurveyQuestionScalarWhereInput>
  }

  export type SurveyQuestionOptionUpdateManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<SurveyQuestionOptionCreateWithoutSurveyQuestionInput>, Enumerable<SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionOptionCreateOrConnectWithoutSurveyQuestionInput>
    upsert?: Enumerable<SurveyQuestionOptionUpsertWithWhereUniqueWithoutSurveyQuestionInput>
    createMany?: SurveyQuestionOptionCreateManySurveyQuestionInputEnvelope
    set?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
    update?: Enumerable<SurveyQuestionOptionUpdateWithWhereUniqueWithoutSurveyQuestionInput>
    updateMany?: Enumerable<SurveyQuestionOptionUpdateManyWithWhereWithoutSurveyQuestionInput>
    deleteMany?: Enumerable<SurveyQuestionOptionScalarWhereInput>
  }

  export type SurveyQuestionAnswerUpdateManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutSurveyQuestionInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutSurveyQuestionInput>
    upsert?: Enumerable<SurveyQuestionAnswerUpsertWithWhereUniqueWithoutSurveyQuestionInput>
    createMany?: SurveyQuestionAnswerCreateManySurveyQuestionInputEnvelope
    set?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    update?: Enumerable<SurveyQuestionAnswerUpdateWithWhereUniqueWithoutSurveyQuestionInput>
    updateMany?: Enumerable<SurveyQuestionAnswerUpdateManyWithWhereWithoutSurveyQuestionInput>
    deleteMany?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
  }

  export type IntermediateSurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionCreateWithoutSurveyQuestionInput>, Enumerable<IntermediateSurveyQuestionUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionCreateOrConnectWithoutSurveyQuestionInput>
    upsert?: Enumerable<IntermediateSurveyQuestionUpsertWithWhereUniqueWithoutSurveyQuestionInput>
    createMany?: IntermediateSurveyQuestionCreateManySurveyQuestionInputEnvelope
    set?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    disconnect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    delete?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    connect?: Enumerable<IntermediateSurveyQuestionWhereUniqueInput>
    update?: Enumerable<IntermediateSurveyQuestionUpdateWithWhereUniqueWithoutSurveyQuestionInput>
    updateMany?: Enumerable<IntermediateSurveyQuestionUpdateManyWithWhereWithoutSurveyQuestionInput>
    deleteMany?: Enumerable<IntermediateSurveyQuestionScalarWhereInput>
  }

  export type SurveyQuestionOptionUncheckedUpdateManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<SurveyQuestionOptionCreateWithoutSurveyQuestionInput>, Enumerable<SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionOptionCreateOrConnectWithoutSurveyQuestionInput>
    upsert?: Enumerable<SurveyQuestionOptionUpsertWithWhereUniqueWithoutSurveyQuestionInput>
    createMany?: SurveyQuestionOptionCreateManySurveyQuestionInputEnvelope
    set?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionOptionWhereUniqueInput>
    update?: Enumerable<SurveyQuestionOptionUpdateWithWhereUniqueWithoutSurveyQuestionInput>
    updateMany?: Enumerable<SurveyQuestionOptionUpdateManyWithWhereWithoutSurveyQuestionInput>
    deleteMany?: Enumerable<SurveyQuestionOptionScalarWhereInput>
  }

  export type SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutSurveyQuestionInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutSurveyQuestionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutSurveyQuestionInput>
    upsert?: Enumerable<SurveyQuestionAnswerUpsertWithWhereUniqueWithoutSurveyQuestionInput>
    createMany?: SurveyQuestionAnswerCreateManySurveyQuestionInputEnvelope
    set?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    update?: Enumerable<SurveyQuestionAnswerUpdateWithWhereUniqueWithoutSurveyQuestionInput>
    updateMany?: Enumerable<SurveyQuestionAnswerUpdateManyWithWhereWithoutSurveyQuestionInput>
    deleteMany?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
  }

  export type SurveyQuestionCreateNestedManyWithoutQuestionCategoryInput = {
    create?: XOR<Enumerable<SurveyQuestionCreateWithoutQuestionCategoryInput>, Enumerable<SurveyQuestionUncheckedCreateWithoutQuestionCategoryInput>>
    connectOrCreate?: Enumerable<SurveyQuestionCreateOrConnectWithoutQuestionCategoryInput>
    createMany?: SurveyQuestionCreateManyQuestionCategoryInputEnvelope
    connect?: Enumerable<SurveyQuestionWhereUniqueInput>
  }

  export type SurveyQuestionUncheckedCreateNestedManyWithoutQuestionCategoryInput = {
    create?: XOR<Enumerable<SurveyQuestionCreateWithoutQuestionCategoryInput>, Enumerable<SurveyQuestionUncheckedCreateWithoutQuestionCategoryInput>>
    connectOrCreate?: Enumerable<SurveyQuestionCreateOrConnectWithoutQuestionCategoryInput>
    createMany?: SurveyQuestionCreateManyQuestionCategoryInputEnvelope
    connect?: Enumerable<SurveyQuestionWhereUniqueInput>
  }

  export type SurveyQuestionUpdateManyWithoutQuestionCategoryInput = {
    create?: XOR<Enumerable<SurveyQuestionCreateWithoutQuestionCategoryInput>, Enumerable<SurveyQuestionUncheckedCreateWithoutQuestionCategoryInput>>
    connectOrCreate?: Enumerable<SurveyQuestionCreateOrConnectWithoutQuestionCategoryInput>
    upsert?: Enumerable<SurveyQuestionUpsertWithWhereUniqueWithoutQuestionCategoryInput>
    createMany?: SurveyQuestionCreateManyQuestionCategoryInputEnvelope
    set?: Enumerable<SurveyQuestionWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionWhereUniqueInput>
    update?: Enumerable<SurveyQuestionUpdateWithWhereUniqueWithoutQuestionCategoryInput>
    updateMany?: Enumerable<SurveyQuestionUpdateManyWithWhereWithoutQuestionCategoryInput>
    deleteMany?: Enumerable<SurveyQuestionScalarWhereInput>
  }

  export type SurveyQuestionUncheckedUpdateManyWithoutQuestionCategoryInput = {
    create?: XOR<Enumerable<SurveyQuestionCreateWithoutQuestionCategoryInput>, Enumerable<SurveyQuestionUncheckedCreateWithoutQuestionCategoryInput>>
    connectOrCreate?: Enumerable<SurveyQuestionCreateOrConnectWithoutQuestionCategoryInput>
    upsert?: Enumerable<SurveyQuestionUpsertWithWhereUniqueWithoutQuestionCategoryInput>
    createMany?: SurveyQuestionCreateManyQuestionCategoryInputEnvelope
    set?: Enumerable<SurveyQuestionWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionWhereUniqueInput>
    update?: Enumerable<SurveyQuestionUpdateWithWhereUniqueWithoutQuestionCategoryInput>
    updateMany?: Enumerable<SurveyQuestionUpdateManyWithWhereWithoutQuestionCategoryInput>
    deleteMany?: Enumerable<SurveyQuestionScalarWhereInput>
  }

  export type SurveyQuestionCreateNestedManyWithoutSurveyQuestionAnswerTypeInput = {
    create?: XOR<Enumerable<SurveyQuestionCreateWithoutSurveyQuestionAnswerTypeInput>, Enumerable<SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerTypeInput>>
    connectOrCreate?: Enumerable<SurveyQuestionCreateOrConnectWithoutSurveyQuestionAnswerTypeInput>
    createMany?: SurveyQuestionCreateManySurveyQuestionAnswerTypeInputEnvelope
    connect?: Enumerable<SurveyQuestionWhereUniqueInput>
  }

  export type SurveyQuestionUncheckedCreateNestedManyWithoutSurveyQuestionAnswerTypeInput = {
    create?: XOR<Enumerable<SurveyQuestionCreateWithoutSurveyQuestionAnswerTypeInput>, Enumerable<SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerTypeInput>>
    connectOrCreate?: Enumerable<SurveyQuestionCreateOrConnectWithoutSurveyQuestionAnswerTypeInput>
    createMany?: SurveyQuestionCreateManySurveyQuestionAnswerTypeInputEnvelope
    connect?: Enumerable<SurveyQuestionWhereUniqueInput>
  }

  export type SurveyQuestionUpdateManyWithoutSurveyQuestionAnswerTypeInput = {
    create?: XOR<Enumerable<SurveyQuestionCreateWithoutSurveyQuestionAnswerTypeInput>, Enumerable<SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerTypeInput>>
    connectOrCreate?: Enumerable<SurveyQuestionCreateOrConnectWithoutSurveyQuestionAnswerTypeInput>
    upsert?: Enumerable<SurveyQuestionUpsertWithWhereUniqueWithoutSurveyQuestionAnswerTypeInput>
    createMany?: SurveyQuestionCreateManySurveyQuestionAnswerTypeInputEnvelope
    set?: Enumerable<SurveyQuestionWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionWhereUniqueInput>
    update?: Enumerable<SurveyQuestionUpdateWithWhereUniqueWithoutSurveyQuestionAnswerTypeInput>
    updateMany?: Enumerable<SurveyQuestionUpdateManyWithWhereWithoutSurveyQuestionAnswerTypeInput>
    deleteMany?: Enumerable<SurveyQuestionScalarWhereInput>
  }

  export type SurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionAnswerTypeInput = {
    create?: XOR<Enumerable<SurveyQuestionCreateWithoutSurveyQuestionAnswerTypeInput>, Enumerable<SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerTypeInput>>
    connectOrCreate?: Enumerable<SurveyQuestionCreateOrConnectWithoutSurveyQuestionAnswerTypeInput>
    upsert?: Enumerable<SurveyQuestionUpsertWithWhereUniqueWithoutSurveyQuestionAnswerTypeInput>
    createMany?: SurveyQuestionCreateManySurveyQuestionAnswerTypeInputEnvelope
    set?: Enumerable<SurveyQuestionWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionWhereUniqueInput>
    update?: Enumerable<SurveyQuestionUpdateWithWhereUniqueWithoutSurveyQuestionAnswerTypeInput>
    updateMany?: Enumerable<SurveyQuestionUpdateManyWithWhereWithoutSurveyQuestionAnswerTypeInput>
    deleteMany?: Enumerable<SurveyQuestionScalarWhereInput>
  }

  export type SurveyQuestionCreateNestedOneWithoutSurveyQuestionOptionsInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyQuestionOptionsInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionOptionsInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyQuestionOptionsInput
    connect?: SurveyQuestionWhereUniqueInput
  }

  export type SurveyQuestionAnswerCreateNestedManyWithoutAnswerOptionInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutAnswerOptionInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutAnswerOptionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutAnswerOptionInput>
    createMany?: SurveyQuestionAnswerCreateManyAnswerOptionInputEnvelope
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
  }

  export type IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionOptionInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionOptionInput>, Enumerable<IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionOptionInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionOptionInput>
    createMany?: IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionOptionInputEnvelope
    connect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
  }

  export type SurveyQuestionAnswerUncheckedCreateNestedManyWithoutAnswerOptionInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutAnswerOptionInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutAnswerOptionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutAnswerOptionInput>
    createMany?: SurveyQuestionAnswerCreateManyAnswerOptionInputEnvelope
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionOptionInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionOptionInput>, Enumerable<IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionOptionInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionOptionInput>
    createMany?: IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionOptionInputEnvelope
    connect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
  }

  export type SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionOptionsInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyQuestionOptionsInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionOptionsInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyQuestionOptionsInput
    upsert?: SurveyQuestionUpsertWithoutSurveyQuestionOptionsInput
    connect?: SurveyQuestionWhereUniqueInput
    update?: XOR<SurveyQuestionUpdateWithoutSurveyQuestionOptionsInput, SurveyQuestionUncheckedUpdateWithoutSurveyQuestionOptionsInput>
  }

  export type SurveyQuestionAnswerUpdateManyWithoutAnswerOptionInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutAnswerOptionInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutAnswerOptionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutAnswerOptionInput>
    upsert?: Enumerable<SurveyQuestionAnswerUpsertWithWhereUniqueWithoutAnswerOptionInput>
    createMany?: SurveyQuestionAnswerCreateManyAnswerOptionInputEnvelope
    set?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    update?: Enumerable<SurveyQuestionAnswerUpdateWithWhereUniqueWithoutAnswerOptionInput>
    updateMany?: Enumerable<SurveyQuestionAnswerUpdateManyWithWhereWithoutAnswerOptionInput>
    deleteMany?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionOptionInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionOptionInput>, Enumerable<IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionOptionInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionOptionInput>
    upsert?: Enumerable<IntermediateSurveyQuestionAnswerProductUpsertWithWhereUniqueWithoutSurveyQuestionOptionInput>
    createMany?: IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionOptionInputEnvelope
    set?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    disconnect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    delete?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    connect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    update?: Enumerable<IntermediateSurveyQuestionAnswerProductUpdateWithWhereUniqueWithoutSurveyQuestionOptionInput>
    updateMany?: Enumerable<IntermediateSurveyQuestionAnswerProductUpdateManyWithWhereWithoutSurveyQuestionOptionInput>
    deleteMany?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereInput>
  }

  export type SurveyQuestionAnswerUncheckedUpdateManyWithoutAnswerOptionInput = {
    create?: XOR<Enumerable<SurveyQuestionAnswerCreateWithoutAnswerOptionInput>, Enumerable<SurveyQuestionAnswerUncheckedCreateWithoutAnswerOptionInput>>
    connectOrCreate?: Enumerable<SurveyQuestionAnswerCreateOrConnectWithoutAnswerOptionInput>
    upsert?: Enumerable<SurveyQuestionAnswerUpsertWithWhereUniqueWithoutAnswerOptionInput>
    createMany?: SurveyQuestionAnswerCreateManyAnswerOptionInputEnvelope
    set?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    disconnect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    delete?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    connect?: Enumerable<SurveyQuestionAnswerWhereUniqueInput>
    update?: Enumerable<SurveyQuestionAnswerUpdateWithWhereUniqueWithoutAnswerOptionInput>
    updateMany?: Enumerable<SurveyQuestionAnswerUpdateManyWithWhereWithoutAnswerOptionInput>
    deleteMany?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionOptionInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionOptionInput>, Enumerable<IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionOptionInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionOptionInput>
    upsert?: Enumerable<IntermediateSurveyQuestionAnswerProductUpsertWithWhereUniqueWithoutSurveyQuestionOptionInput>
    createMany?: IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionOptionInputEnvelope
    set?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    disconnect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    delete?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    connect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    update?: Enumerable<IntermediateSurveyQuestionAnswerProductUpdateWithWhereUniqueWithoutSurveyQuestionOptionInput>
    updateMany?: Enumerable<IntermediateSurveyQuestionAnswerProductUpdateManyWithWhereWithoutSurveyQuestionOptionInput>
    deleteMany?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereInput>
  }

  export type IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionAnswerInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionAnswerInput>, Enumerable<IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionAnswerInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionAnswerInput>
    createMany?: IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionAnswerInputEnvelope
    connect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
  }

  export type CustomersCreateNestedOneWithoutSurveyQuestionAnswerInput = {
    create?: XOR<CustomersCreateWithoutSurveyQuestionAnswerInput, CustomersUncheckedCreateWithoutSurveyQuestionAnswerInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutSurveyQuestionAnswerInput
    connect?: CustomersWhereUniqueInput
  }

  export type SurveyQuestionCreateNestedOneWithoutSurveyQuestionAnswerInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyQuestionAnswerInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyQuestionAnswerInput
    connect?: SurveyQuestionWhereUniqueInput
  }

  export type SurveyQuestionOptionCreateNestedOneWithoutSurveyQuestionAnswerInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutSurveyQuestionAnswerInput, SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionAnswerInput>
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutSurveyQuestionAnswerInput
    connect?: SurveyQuestionOptionWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSurveyQuestionAnswerInput = {
    create?: XOR<ProductCreateWithoutSurveyQuestionAnswerInput, ProductUncheckedCreateWithoutSurveyQuestionAnswerInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSurveyQuestionAnswerInput
    connect?: ProductWhereUniqueInput
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionAnswerInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionAnswerInput>, Enumerable<IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionAnswerInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionAnswerInput>
    createMany?: IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionAnswerInputEnvelope
    connect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionAnswerInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionAnswerInput>, Enumerable<IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionAnswerInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionAnswerInput>
    upsert?: Enumerable<IntermediateSurveyQuestionAnswerProductUpsertWithWhereUniqueWithoutSurveyQuestionAnswerInput>
    createMany?: IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionAnswerInputEnvelope
    set?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    disconnect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    delete?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    connect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    update?: Enumerable<IntermediateSurveyQuestionAnswerProductUpdateWithWhereUniqueWithoutSurveyQuestionAnswerInput>
    updateMany?: Enumerable<IntermediateSurveyQuestionAnswerProductUpdateManyWithWhereWithoutSurveyQuestionAnswerInput>
    deleteMany?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereInput>
  }

  export type CustomersUpdateOneRequiredWithoutSurveyQuestionAnswerInput = {
    create?: XOR<CustomersCreateWithoutSurveyQuestionAnswerInput, CustomersUncheckedCreateWithoutSurveyQuestionAnswerInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutSurveyQuestionAnswerInput
    upsert?: CustomersUpsertWithoutSurveyQuestionAnswerInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutSurveyQuestionAnswerInput, CustomersUncheckedUpdateWithoutSurveyQuestionAnswerInput>
  }

  export type SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionAnswerInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyQuestionAnswerInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyQuestionAnswerInput
    upsert?: SurveyQuestionUpsertWithoutSurveyQuestionAnswerInput
    connect?: SurveyQuestionWhereUniqueInput
    update?: XOR<SurveyQuestionUpdateWithoutSurveyQuestionAnswerInput, SurveyQuestionUncheckedUpdateWithoutSurveyQuestionAnswerInput>
  }

  export type SurveyQuestionOptionUpdateOneWithoutSurveyQuestionAnswerInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutSurveyQuestionAnswerInput, SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionAnswerInput>
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutSurveyQuestionAnswerInput
    upsert?: SurveyQuestionOptionUpsertWithoutSurveyQuestionAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: SurveyQuestionOptionWhereUniqueInput
    update?: XOR<SurveyQuestionOptionUpdateWithoutSurveyQuestionAnswerInput, SurveyQuestionOptionUncheckedUpdateWithoutSurveyQuestionAnswerInput>
  }

  export type ProductUpdateOneWithoutSurveyQuestionAnswerInput = {
    create?: XOR<ProductCreateWithoutSurveyQuestionAnswerInput, ProductUncheckedCreateWithoutSurveyQuestionAnswerInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSurveyQuestionAnswerInput
    upsert?: ProductUpsertWithoutSurveyQuestionAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutSurveyQuestionAnswerInput, ProductUncheckedUpdateWithoutSurveyQuestionAnswerInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionAnswerInput = {
    create?: XOR<Enumerable<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionAnswerInput>, Enumerable<IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionAnswerInput>>
    connectOrCreate?: Enumerable<IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionAnswerInput>
    upsert?: Enumerable<IntermediateSurveyQuestionAnswerProductUpsertWithWhereUniqueWithoutSurveyQuestionAnswerInput>
    createMany?: IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionAnswerInputEnvelope
    set?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    disconnect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    delete?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    connect?: Enumerable<IntermediateSurveyQuestionAnswerProductWhereUniqueInput>
    update?: Enumerable<IntermediateSurveyQuestionAnswerProductUpdateWithWhereUniqueWithoutSurveyQuestionAnswerInput>
    updateMany?: Enumerable<IntermediateSurveyQuestionAnswerProductUpdateManyWithWhereWithoutSurveyQuestionAnswerInput>
    deleteMany?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereInput>
  }

  export type SurveyQuestionAnswerCreateNestedOneWithoutIntermediateSurveyQuestionAnswerProductInput = {
    create?: XOR<SurveyQuestionAnswerCreateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionAnswerUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput>
    connectOrCreate?: SurveyQuestionAnswerCreateOrConnectWithoutIntermediateSurveyQuestionAnswerProductInput
    connect?: SurveyQuestionAnswerWhereUniqueInput
  }

  export type SurveyQuestionOptionCreateNestedOneWithoutIntermediateSurveyQuestionAnswerProductInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionOptionUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput>
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutIntermediateSurveyQuestionAnswerProductInput
    connect?: SurveyQuestionOptionWhereUniqueInput
  }

  export type SurveyQuestionAnswerUpdateOneRequiredWithoutIntermediateSurveyQuestionAnswerProductInput = {
    create?: XOR<SurveyQuestionAnswerCreateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionAnswerUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput>
    connectOrCreate?: SurveyQuestionAnswerCreateOrConnectWithoutIntermediateSurveyQuestionAnswerProductInput
    upsert?: SurveyQuestionAnswerUpsertWithoutIntermediateSurveyQuestionAnswerProductInput
    connect?: SurveyQuestionAnswerWhereUniqueInput
    update?: XOR<SurveyQuestionAnswerUpdateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionAnswerUncheckedUpdateWithoutIntermediateSurveyQuestionAnswerProductInput>
  }

  export type SurveyQuestionOptionUpdateOneRequiredWithoutIntermediateSurveyQuestionAnswerProductInput = {
    create?: XOR<SurveyQuestionOptionCreateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionOptionUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput>
    connectOrCreate?: SurveyQuestionOptionCreateOrConnectWithoutIntermediateSurveyQuestionAnswerProductInput
    upsert?: SurveyQuestionOptionUpsertWithoutIntermediateSurveyQuestionAnswerProductInput
    connect?: SurveyQuestionOptionWhereUniqueInput
    update?: XOR<SurveyQuestionOptionUpdateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionOptionUncheckedUpdateWithoutIntermediateSurveyQuestionAnswerProductInput>
  }

  export type ProductCreateNestedOneWithoutCustomerProductDistancesInput = {
    create?: XOR<ProductCreateWithoutCustomerProductDistancesInput, ProductUncheckedCreateWithoutCustomerProductDistancesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerProductDistancesInput
    connect?: ProductWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutCustomerProductDistancesInput = {
    create?: XOR<CustomersCreateWithoutCustomerProductDistancesInput, CustomersUncheckedCreateWithoutCustomerProductDistancesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerProductDistancesInput
    connect?: CustomersWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutCustomerProductDistancesInput = {
    create?: XOR<ProductCreateWithoutCustomerProductDistancesInput, ProductUncheckedCreateWithoutCustomerProductDistancesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerProductDistancesInput
    upsert?: ProductUpsertWithoutCustomerProductDistancesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutCustomerProductDistancesInput, ProductUncheckedUpdateWithoutCustomerProductDistancesInput>
  }

  export type CustomersUpdateOneRequiredWithoutCustomerProductDistancesInput = {
    create?: XOR<CustomersCreateWithoutCustomerProductDistancesInput, CustomersUncheckedCreateWithoutCustomerProductDistancesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerProductDistancesInput
    upsert?: CustomersUpsertWithoutCustomerProductDistancesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutCustomerProductDistancesInput, CustomersUncheckedUpdateWithoutCustomerProductDistancesInput>
  }

  export type ProductCreateNestedOneWithoutCustomerBoxItemsInput = {
    create?: XOR<ProductCreateWithoutCustomerBoxItemsInput, ProductUncheckedCreateWithoutCustomerBoxItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerBoxItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutCustomerBoxItemsInput = {
    create?: XOR<CustomersCreateWithoutCustomerBoxItemsInput, CustomersUncheckedCreateWithoutCustomerBoxItemsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerBoxItemsInput
    connect?: CustomersWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutCustomerBoxItemsInput = {
    create?: XOR<ProductCreateWithoutCustomerBoxItemsInput, ProductUncheckedCreateWithoutCustomerBoxItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerBoxItemsInput
    upsert?: ProductUpsertWithoutCustomerBoxItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutCustomerBoxItemsInput, ProductUncheckedUpdateWithoutCustomerBoxItemsInput>
  }

  export type CustomersUpdateOneRequiredWithoutCustomerBoxItemsInput = {
    create?: XOR<CustomersCreateWithoutCustomerBoxItemsInput, CustomersUncheckedCreateWithoutCustomerBoxItemsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerBoxItemsInput
    upsert?: CustomersUpsertWithoutCustomerBoxItemsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutCustomerBoxItemsInput, CustomersUncheckedUpdateWithoutCustomerBoxItemsInput>
  }

  export type CustomersCreateNestedOneWithoutQueuedShopifyOrderInput = {
    create?: XOR<CustomersCreateWithoutQueuedShopifyOrderInput, CustomersUncheckedCreateWithoutQueuedShopifyOrderInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutQueuedShopifyOrderInput
    connect?: CustomersWhereUniqueInput
  }

  export type EnumQueueStatusFieldUpdateOperationsInput = {
    set?: QueueStatus
  }

  export type CustomersUpdateOneRequiredWithoutQueuedShopifyOrderInput = {
    create?: XOR<CustomersCreateWithoutQueuedShopifyOrderInput, CustomersUncheckedCreateWithoutQueuedShopifyOrderInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutQueuedShopifyOrderInput
    upsert?: CustomersUpsertWithoutQueuedShopifyOrderInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutQueuedShopifyOrderInput, CustomersUncheckedUpdateWithoutQueuedShopifyOrderInput>
  }

  export type PractitionerBoxCreateNestedManyWithoutPractitionerInput = {
    create?: XOR<Enumerable<PractitionerBoxCreateWithoutPractitionerInput>, Enumerable<PractitionerBoxUncheckedCreateWithoutPractitionerInput>>
    connectOrCreate?: Enumerable<PractitionerBoxCreateOrConnectWithoutPractitionerInput>
    createMany?: PractitionerBoxCreateManyPractitionerInputEnvelope
    connect?: Enumerable<PractitionerBoxWhereUniqueInput>
  }

  export type PractitionerSocialMediaCreateNestedOneWithoutPractitionerInput = {
    create?: XOR<PractitionerSocialMediaCreateWithoutPractitionerInput, PractitionerSocialMediaUncheckedCreateWithoutPractitionerInput>
    connectOrCreate?: PractitionerSocialMediaCreateOrConnectWithoutPractitionerInput
    connect?: PractitionerSocialMediaWhereUniqueInput
  }

  export type PractitionerBoxUncheckedCreateNestedManyWithoutPractitionerInput = {
    create?: XOR<Enumerable<PractitionerBoxCreateWithoutPractitionerInput>, Enumerable<PractitionerBoxUncheckedCreateWithoutPractitionerInput>>
    connectOrCreate?: Enumerable<PractitionerBoxCreateOrConnectWithoutPractitionerInput>
    createMany?: PractitionerBoxCreateManyPractitionerInputEnvelope
    connect?: Enumerable<PractitionerBoxWhereUniqueInput>
  }

  export type PractitionerSocialMediaUncheckedCreateNestedOneWithoutPractitionerInput = {
    create?: XOR<PractitionerSocialMediaCreateWithoutPractitionerInput, PractitionerSocialMediaUncheckedCreateWithoutPractitionerInput>
    connectOrCreate?: PractitionerSocialMediaCreateOrConnectWithoutPractitionerInput
    connect?: PractitionerSocialMediaWhereUniqueInput
  }

  export type PractitionerBoxUpdateManyWithoutPractitionerInput = {
    create?: XOR<Enumerable<PractitionerBoxCreateWithoutPractitionerInput>, Enumerable<PractitionerBoxUncheckedCreateWithoutPractitionerInput>>
    connectOrCreate?: Enumerable<PractitionerBoxCreateOrConnectWithoutPractitionerInput>
    upsert?: Enumerable<PractitionerBoxUpsertWithWhereUniqueWithoutPractitionerInput>
    createMany?: PractitionerBoxCreateManyPractitionerInputEnvelope
    set?: Enumerable<PractitionerBoxWhereUniqueInput>
    disconnect?: Enumerable<PractitionerBoxWhereUniqueInput>
    delete?: Enumerable<PractitionerBoxWhereUniqueInput>
    connect?: Enumerable<PractitionerBoxWhereUniqueInput>
    update?: Enumerable<PractitionerBoxUpdateWithWhereUniqueWithoutPractitionerInput>
    updateMany?: Enumerable<PractitionerBoxUpdateManyWithWhereWithoutPractitionerInput>
    deleteMany?: Enumerable<PractitionerBoxScalarWhereInput>
  }

  export type PractitionerSocialMediaUpdateOneWithoutPractitionerInput = {
    create?: XOR<PractitionerSocialMediaCreateWithoutPractitionerInput, PractitionerSocialMediaUncheckedCreateWithoutPractitionerInput>
    connectOrCreate?: PractitionerSocialMediaCreateOrConnectWithoutPractitionerInput
    upsert?: PractitionerSocialMediaUpsertWithoutPractitionerInput
    disconnect?: boolean
    delete?: boolean
    connect?: PractitionerSocialMediaWhereUniqueInput
    update?: XOR<PractitionerSocialMediaUpdateWithoutPractitionerInput, PractitionerSocialMediaUncheckedUpdateWithoutPractitionerInput>
  }

  export type PractitionerBoxUncheckedUpdateManyWithoutPractitionerInput = {
    create?: XOR<Enumerable<PractitionerBoxCreateWithoutPractitionerInput>, Enumerable<PractitionerBoxUncheckedCreateWithoutPractitionerInput>>
    connectOrCreate?: Enumerable<PractitionerBoxCreateOrConnectWithoutPractitionerInput>
    upsert?: Enumerable<PractitionerBoxUpsertWithWhereUniqueWithoutPractitionerInput>
    createMany?: PractitionerBoxCreateManyPractitionerInputEnvelope
    set?: Enumerable<PractitionerBoxWhereUniqueInput>
    disconnect?: Enumerable<PractitionerBoxWhereUniqueInput>
    delete?: Enumerable<PractitionerBoxWhereUniqueInput>
    connect?: Enumerable<PractitionerBoxWhereUniqueInput>
    update?: Enumerable<PractitionerBoxUpdateWithWhereUniqueWithoutPractitionerInput>
    updateMany?: Enumerable<PractitionerBoxUpdateManyWithWhereWithoutPractitionerInput>
    deleteMany?: Enumerable<PractitionerBoxScalarWhereInput>
  }

  export type PractitionerSocialMediaUncheckedUpdateOneWithoutPractitionerInput = {
    create?: XOR<PractitionerSocialMediaCreateWithoutPractitionerInput, PractitionerSocialMediaUncheckedCreateWithoutPractitionerInput>
    connectOrCreate?: PractitionerSocialMediaCreateOrConnectWithoutPractitionerInput
    upsert?: PractitionerSocialMediaUpsertWithoutPractitionerInput
    disconnect?: boolean
    delete?: boolean
    connect?: PractitionerSocialMediaWhereUniqueInput
    update?: XOR<PractitionerSocialMediaUpdateWithoutPractitionerInput, PractitionerSocialMediaUncheckedUpdateWithoutPractitionerInput>
  }

  export type PractitionerCreateNestedOneWithoutPractitionerSocialMediaInput = {
    create?: XOR<PractitionerCreateWithoutPractitionerSocialMediaInput, PractitionerUncheckedCreateWithoutPractitionerSocialMediaInput>
    connectOrCreate?: PractitionerCreateOrConnectWithoutPractitionerSocialMediaInput
    connect?: PractitionerWhereUniqueInput
  }

  export type PractitionerUpdateOneRequiredWithoutPractitionerSocialMediaInput = {
    create?: XOR<PractitionerCreateWithoutPractitionerSocialMediaInput, PractitionerUncheckedCreateWithoutPractitionerSocialMediaInput>
    connectOrCreate?: PractitionerCreateOrConnectWithoutPractitionerSocialMediaInput
    upsert?: PractitionerUpsertWithoutPractitionerSocialMediaInput
    connect?: PractitionerWhereUniqueInput
    update?: XOR<PractitionerUpdateWithoutPractitionerSocialMediaInput, PractitionerUncheckedUpdateWithoutPractitionerSocialMediaInput>
  }

  export type PractitionerCreateNestedOneWithoutPractitionerBoxInput = {
    create?: XOR<PractitionerCreateWithoutPractitionerBoxInput, PractitionerUncheckedCreateWithoutPractitionerBoxInput>
    connectOrCreate?: PractitionerCreateOrConnectWithoutPractitionerBoxInput
    connect?: PractitionerWhereUniqueInput
  }

  export type PractitionerCustomerOrderHistoryCreateNestedManyWithoutPractitionerBoxInput = {
    create?: XOR<Enumerable<PractitionerCustomerOrderHistoryCreateWithoutPractitionerBoxInput>, Enumerable<PractitionerCustomerOrderHistoryUncheckedCreateWithoutPractitionerBoxInput>>
    connectOrCreate?: Enumerable<PractitionerCustomerOrderHistoryCreateOrConnectWithoutPractitionerBoxInput>
    createMany?: PractitionerCustomerOrderHistoryCreateManyPractitionerBoxInputEnvelope
    connect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
  }

  export type IntermediatePractitionerBoxProductCreateNestedManyWithoutPractitionerBoxInput = {
    create?: XOR<Enumerable<IntermediatePractitionerBoxProductCreateWithoutPractitionerBoxInput>, Enumerable<IntermediatePractitionerBoxProductUncheckedCreateWithoutPractitionerBoxInput>>
    connectOrCreate?: Enumerable<IntermediatePractitionerBoxProductCreateOrConnectWithoutPractitionerBoxInput>
    createMany?: IntermediatePractitionerBoxProductCreateManyPractitionerBoxInputEnvelope
    connect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
  }

  export type PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutPractitionerBoxInput = {
    create?: XOR<Enumerable<PractitionerCustomerOrderHistoryCreateWithoutPractitionerBoxInput>, Enumerable<PractitionerCustomerOrderHistoryUncheckedCreateWithoutPractitionerBoxInput>>
    connectOrCreate?: Enumerable<PractitionerCustomerOrderHistoryCreateOrConnectWithoutPractitionerBoxInput>
    createMany?: PractitionerCustomerOrderHistoryCreateManyPractitionerBoxInputEnvelope
    connect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
  }

  export type IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutPractitionerBoxInput = {
    create?: XOR<Enumerable<IntermediatePractitionerBoxProductCreateWithoutPractitionerBoxInput>, Enumerable<IntermediatePractitionerBoxProductUncheckedCreateWithoutPractitionerBoxInput>>
    connectOrCreate?: Enumerable<IntermediatePractitionerBoxProductCreateOrConnectWithoutPractitionerBoxInput>
    createMany?: IntermediatePractitionerBoxProductCreateManyPractitionerBoxInputEnvelope
    connect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
  }

  export type PractitionerUpdateOneRequiredWithoutPractitionerBoxInput = {
    create?: XOR<PractitionerCreateWithoutPractitionerBoxInput, PractitionerUncheckedCreateWithoutPractitionerBoxInput>
    connectOrCreate?: PractitionerCreateOrConnectWithoutPractitionerBoxInput
    upsert?: PractitionerUpsertWithoutPractitionerBoxInput
    connect?: PractitionerWhereUniqueInput
    update?: XOR<PractitionerUpdateWithoutPractitionerBoxInput, PractitionerUncheckedUpdateWithoutPractitionerBoxInput>
  }

  export type PractitionerCustomerOrderHistoryUpdateManyWithoutPractitionerBoxInput = {
    create?: XOR<Enumerable<PractitionerCustomerOrderHistoryCreateWithoutPractitionerBoxInput>, Enumerable<PractitionerCustomerOrderHistoryUncheckedCreateWithoutPractitionerBoxInput>>
    connectOrCreate?: Enumerable<PractitionerCustomerOrderHistoryCreateOrConnectWithoutPractitionerBoxInput>
    upsert?: Enumerable<PractitionerCustomerOrderHistoryUpsertWithWhereUniqueWithoutPractitionerBoxInput>
    createMany?: PractitionerCustomerOrderHistoryCreateManyPractitionerBoxInputEnvelope
    set?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    disconnect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    delete?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    connect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    update?: Enumerable<PractitionerCustomerOrderHistoryUpdateWithWhereUniqueWithoutPractitionerBoxInput>
    updateMany?: Enumerable<PractitionerCustomerOrderHistoryUpdateManyWithWhereWithoutPractitionerBoxInput>
    deleteMany?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereInput>
  }

  export type IntermediatePractitionerBoxProductUpdateManyWithoutPractitionerBoxInput = {
    create?: XOR<Enumerable<IntermediatePractitionerBoxProductCreateWithoutPractitionerBoxInput>, Enumerable<IntermediatePractitionerBoxProductUncheckedCreateWithoutPractitionerBoxInput>>
    connectOrCreate?: Enumerable<IntermediatePractitionerBoxProductCreateOrConnectWithoutPractitionerBoxInput>
    upsert?: Enumerable<IntermediatePractitionerBoxProductUpsertWithWhereUniqueWithoutPractitionerBoxInput>
    createMany?: IntermediatePractitionerBoxProductCreateManyPractitionerBoxInputEnvelope
    set?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    disconnect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    delete?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    connect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    update?: Enumerable<IntermediatePractitionerBoxProductUpdateWithWhereUniqueWithoutPractitionerBoxInput>
    updateMany?: Enumerable<IntermediatePractitionerBoxProductUpdateManyWithWhereWithoutPractitionerBoxInput>
    deleteMany?: Enumerable<IntermediatePractitionerBoxProductScalarWhereInput>
  }

  export type PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutPractitionerBoxInput = {
    create?: XOR<Enumerable<PractitionerCustomerOrderHistoryCreateWithoutPractitionerBoxInput>, Enumerable<PractitionerCustomerOrderHistoryUncheckedCreateWithoutPractitionerBoxInput>>
    connectOrCreate?: Enumerable<PractitionerCustomerOrderHistoryCreateOrConnectWithoutPractitionerBoxInput>
    upsert?: Enumerable<PractitionerCustomerOrderHistoryUpsertWithWhereUniqueWithoutPractitionerBoxInput>
    createMany?: PractitionerCustomerOrderHistoryCreateManyPractitionerBoxInputEnvelope
    set?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    disconnect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    delete?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    connect?: Enumerable<PractitionerCustomerOrderHistoryWhereUniqueInput>
    update?: Enumerable<PractitionerCustomerOrderHistoryUpdateWithWhereUniqueWithoutPractitionerBoxInput>
    updateMany?: Enumerable<PractitionerCustomerOrderHistoryUpdateManyWithWhereWithoutPractitionerBoxInput>
    deleteMany?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereInput>
  }

  export type IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutPractitionerBoxInput = {
    create?: XOR<Enumerable<IntermediatePractitionerBoxProductCreateWithoutPractitionerBoxInput>, Enumerable<IntermediatePractitionerBoxProductUncheckedCreateWithoutPractitionerBoxInput>>
    connectOrCreate?: Enumerable<IntermediatePractitionerBoxProductCreateOrConnectWithoutPractitionerBoxInput>
    upsert?: Enumerable<IntermediatePractitionerBoxProductUpsertWithWhereUniqueWithoutPractitionerBoxInput>
    createMany?: IntermediatePractitionerBoxProductCreateManyPractitionerBoxInputEnvelope
    set?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    disconnect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    delete?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    connect?: Enumerable<IntermediatePractitionerBoxProductWhereUniqueInput>
    update?: Enumerable<IntermediatePractitionerBoxProductUpdateWithWhereUniqueWithoutPractitionerBoxInput>
    updateMany?: Enumerable<IntermediatePractitionerBoxProductUpdateManyWithWhereWithoutPractitionerBoxInput>
    deleteMany?: Enumerable<IntermediatePractitionerBoxProductScalarWhereInput>
  }

  export type PractitionerBoxCreateNestedOneWithoutIntermediatePractitionerBoxProductInput = {
    create?: XOR<PractitionerBoxCreateWithoutIntermediatePractitionerBoxProductInput, PractitionerBoxUncheckedCreateWithoutIntermediatePractitionerBoxProductInput>
    connectOrCreate?: PractitionerBoxCreateOrConnectWithoutIntermediatePractitionerBoxProductInput
    connect?: PractitionerBoxWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutIntermediatePractitionerBoxProductInput = {
    create?: XOR<ProductCreateWithoutIntermediatePractitionerBoxProductInput, ProductUncheckedCreateWithoutIntermediatePractitionerBoxProductInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediatePractitionerBoxProductInput
    connect?: ProductWhereUniqueInput
  }

  export type PractitionerBoxUpdateOneRequiredWithoutIntermediatePractitionerBoxProductInput = {
    create?: XOR<PractitionerBoxCreateWithoutIntermediatePractitionerBoxProductInput, PractitionerBoxUncheckedCreateWithoutIntermediatePractitionerBoxProductInput>
    connectOrCreate?: PractitionerBoxCreateOrConnectWithoutIntermediatePractitionerBoxProductInput
    upsert?: PractitionerBoxUpsertWithoutIntermediatePractitionerBoxProductInput
    connect?: PractitionerBoxWhereUniqueInput
    update?: XOR<PractitionerBoxUpdateWithoutIntermediatePractitionerBoxProductInput, PractitionerBoxUncheckedUpdateWithoutIntermediatePractitionerBoxProductInput>
  }

  export type ProductUpdateOneRequiredWithoutIntermediatePractitionerBoxProductInput = {
    create?: XOR<ProductCreateWithoutIntermediatePractitionerBoxProductInput, ProductUncheckedCreateWithoutIntermediatePractitionerBoxProductInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIntermediatePractitionerBoxProductInput
    upsert?: ProductUpsertWithoutIntermediatePractitionerBoxProductInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutIntermediatePractitionerBoxProductInput, ProductUncheckedUpdateWithoutIntermediatePractitionerBoxProductInput>
  }

  export type CustomersCreateNestedOneWithoutPractitionerCustomerOrderHistoryInput = {
    create?: XOR<CustomersCreateWithoutPractitionerCustomerOrderHistoryInput, CustomersUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutPractitionerCustomerOrderHistoryInput
    connect?: CustomersWhereUniqueInput
  }

  export type PractitionerBoxCreateNestedOneWithoutPractitionerCustomerOrderHistoryInput = {
    create?: XOR<PractitionerBoxCreateWithoutPractitionerCustomerOrderHistoryInput, PractitionerBoxUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput>
    connectOrCreate?: PractitionerBoxCreateOrConnectWithoutPractitionerCustomerOrderHistoryInput
    connect?: PractitionerBoxWhereUniqueInput
  }

  export type CustomersUpdateOneRequiredWithoutPractitionerCustomerOrderHistoryInput = {
    create?: XOR<CustomersCreateWithoutPractitionerCustomerOrderHistoryInput, CustomersUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutPractitionerCustomerOrderHistoryInput
    upsert?: CustomersUpsertWithoutPractitionerCustomerOrderHistoryInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<CustomersUpdateWithoutPractitionerCustomerOrderHistoryInput, CustomersUncheckedUpdateWithoutPractitionerCustomerOrderHistoryInput>
  }

  export type PractitionerBoxUpdateOneRequiredWithoutPractitionerCustomerOrderHistoryInput = {
    create?: XOR<PractitionerBoxCreateWithoutPractitionerCustomerOrderHistoryInput, PractitionerBoxUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput>
    connectOrCreate?: PractitionerBoxCreateOrConnectWithoutPractitionerCustomerOrderHistoryInput
    upsert?: PractitionerBoxUpsertWithoutPractitionerCustomerOrderHistoryInput
    connect?: PractitionerBoxWhereUniqueInput
    update?: XOR<PractitionerBoxUpdateWithoutPractitionerCustomerOrderHistoryInput, PractitionerBoxUncheckedUpdateWithoutPractitionerCustomerOrderHistoryInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumActiveStatusNullableFilter = {
    equals?: ActiveStatus | null
    in?: Enumerable<ActiveStatus> | null
    notIn?: Enumerable<ActiveStatus> | null
    not?: NestedEnumActiveStatusNullableFilter | ActiveStatus | null
  }

  export type NestedEnumActiveStatusNullableWithAggregatesFilter = {
    equals?: ActiveStatus | null
    in?: Enumerable<ActiveStatus> | null
    notIn?: Enumerable<ActiveStatus> | null
    not?: NestedEnumActiveStatusNullableWithAggregatesFilter | ActiveStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumActiveStatusNullableFilter
    _max?: NestedEnumActiveStatusNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumQueueStatusFilter = {
    equals?: QueueStatus
    in?: Enumerable<QueueStatus>
    notIn?: Enumerable<QueueStatus>
    not?: NestedEnumQueueStatusFilter | QueueStatus
  }

  export type NestedEnumQueueStatusWithAggregatesFilter = {
    equals?: QueueStatus
    in?: Enumerable<QueueStatus>
    notIn?: Enumerable<QueueStatus>
    not?: NestedEnumQueueStatusWithAggregatesFilter | QueueStatus
    _count?: NestedIntFilter
    _min?: NestedEnumQueueStatusFilter
    _max?: NestedEnumQueueStatusFilter
  }

  export type IntermediateCustomerNutritionNeedCreateWithoutCustomerInput = {
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customerNutritionNeed: CustomerNutritionNeedCreateNestedOneWithoutIntermediateCustomerNutritionNeedInput
  }

  export type IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerInput = {
    customerNutritionNeedId: number
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerInput = {
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
    create: XOR<IntermediateCustomerNutritionNeedCreateWithoutCustomerInput, IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerNutritionNeedCreateManyCustomerInputEnvelope = {
    data: Enumerable<IntermediateCustomerNutritionNeedCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerMedicalConditionCreateWithoutCustomerInput = {
    medicalConditionValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerMedicalCondition: CustomerMedicalConditionCreateNestedOneWithoutIntermediateCustomerMedicalConditionsInput
  }

  export type IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerInput = {
    medicalConditionValue: string
    customerMedicalConditionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerInput = {
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
    create: XOR<IntermediateCustomerMedicalConditionCreateWithoutCustomerInput, IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerMedicalConditionCreateManyCustomerInputEnvelope = {
    data: Enumerable<IntermediateCustomerMedicalConditionCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerAllergenCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productAllergen: ProductAllergenCreateNestedOneWithoutIntermediateCustomerAllergensInput
  }

  export type IntermediateCustomerAllergenUncheckedCreateWithoutCustomerInput = {
    productAllergenId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerAllergenCreateOrConnectWithoutCustomerInput = {
    where: IntermediateCustomerAllergenWhereUniqueInput
    create: XOR<IntermediateCustomerAllergenCreateWithoutCustomerInput, IntermediateCustomerAllergenUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerAllergenCreateManyCustomerInputEnvelope = {
    data: Enumerable<IntermediateCustomerAllergenCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type SurveyQuestionAnswerCreateWithoutCustomerInput = {
    responseId?: string | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionAnswerInput
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionCreateNestedOneWithoutSurveyQuestionAnswerInput
    product?: ProductCreateNestedOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedCreateWithoutCustomerInput = {
    id?: number
    responseId?: string | null
    surveyQuestionId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerCreateOrConnectWithoutCustomerInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    create: XOR<SurveyQuestionAnswerCreateWithoutCustomerInput, SurveyQuestionAnswerUncheckedCreateWithoutCustomerInput>
  }

  export type SurveyQuestionAnswerCreateManyCustomerInputEnvelope = {
    data: Enumerable<SurveyQuestionAnswerCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CustomerProductDistanceCreateWithoutCustomerInput = {
    distance: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCustomerProductDistancesInput
  }

  export type CustomerProductDistanceUncheckedCreateWithoutCustomerInput = {
    id?: number
    distance: number
    productId: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductDistanceCreateOrConnectWithoutCustomerInput = {
    where: CustomerProductDistanceWhereUniqueInput
    create: XOR<CustomerProductDistanceCreateWithoutCustomerInput, CustomerProductDistanceUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerProductDistanceCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerProductDistanceCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type CustomerBoxItemsCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCustomerBoxItemsInput
  }

  export type CustomerBoxItemsUncheckedCreateWithoutCustomerInput = {
    id?: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerBoxItemsCreateOrConnectWithoutCustomerInput = {
    where: CustomerBoxItemsWhereUniqueInput
    create: XOR<CustomerBoxItemsCreateWithoutCustomerInput, CustomerBoxItemsUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerBoxItemsCreateManyCustomerInputEnvelope = {
    data: Enumerable<CustomerBoxItemsCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type QueuedShopifyOrderCreateWithoutCustomerInput = {
    orderName: string
    status?: QueueStatus
    scheduledAt: string
    orderedAt?: string | null
    fulfilledAt?: string | null
  }

  export type QueuedShopifyOrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    orderName: string
    status?: QueueStatus
    scheduledAt: string
    orderedAt?: string | null
    fulfilledAt?: string | null
  }

  export type QueuedShopifyOrderCreateOrConnectWithoutCustomerInput = {
    where: QueuedShopifyOrderWhereUniqueInput
    create: XOR<QueuedShopifyOrderCreateWithoutCustomerInput, QueuedShopifyOrderUncheckedCreateWithoutCustomerInput>
  }

  export type QueuedShopifyOrderCreateManyCustomerInputEnvelope = {
    data: Enumerable<QueuedShopifyOrderCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerFlavorDislikeCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productFlavor: ProductFlavorCreateNestedOneWithoutIntermediateCustomerFlavorDislikesInput
  }

  export type IntermediateCustomerFlavorDislikeUncheckedCreateWithoutCustomerInput = {
    productFlavorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFlavorDislikeCreateOrConnectWithoutCustomerInput = {
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
    create: XOR<IntermediateCustomerFlavorDislikeCreateWithoutCustomerInput, IntermediateCustomerFlavorDislikeUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerFlavorDislikeCreateManyCustomerInputEnvelope = {
    data: Enumerable<IntermediateCustomerFlavorDislikeCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerCategoryPreferenceCreateWithoutCustomerInput = {
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productCategory: ProductCategoryCreateNestedOneWithoutIntermediateCustomerCategoryPreferencesInput
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutCustomerInput = {
    productCategoryId: number
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutCustomerInput = {
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    create: XOR<IntermediateCustomerCategoryPreferenceCreateWithoutCustomerInput, IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerCategoryPreferenceCreateManyCustomerInputEnvelope = {
    data: Enumerable<IntermediateCustomerCategoryPreferenceCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerIngredientDislikeCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productIngredient: ProductIngredientCreateNestedOneWithoutIntermediateCustomerIngredientDislikesInput
  }

  export type IntermediateCustomerIngredientDislikeUncheckedCreateWithoutCustomerInput = {
    productIngredientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerIngredientDislikeCreateOrConnectWithoutCustomerInput = {
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
    create: XOR<IntermediateCustomerIngredientDislikeCreateWithoutCustomerInput, IntermediateCustomerIngredientDislikeUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerIngredientDislikeCreateManyCustomerInputEnvelope = {
    data: Enumerable<IntermediateCustomerIngredientDislikeCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerFoodTypeCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productFoodType: ProductFoodTypeCreateNestedOneWithoutIntermediateCustomerFoodTypesInput
  }

  export type IntermediateCustomerFoodTypeUncheckedCreateWithoutCustomerInput = {
    productFoodTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFoodTypeCreateOrConnectWithoutCustomerInput = {
    where: IntermediateCustomerFoodTypeWhereUniqueInput
    create: XOR<IntermediateCustomerFoodTypeCreateWithoutCustomerInput, IntermediateCustomerFoodTypeUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerFoodTypeCreateManyCustomerInputEnvelope = {
    data: Enumerable<IntermediateCustomerFoodTypeCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateWithoutCustomerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productCookingMethod: ProductCookingMethodCreateNestedOneWithoutIntermediateCustomerUnavailableCookingMethodsInput
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutCustomerInput = {
    productCookingMethodId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutCustomerInput = {
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    create: XOR<IntermediateCustomerUnavailableCookingMethodCreateWithoutCustomerInput, IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateManyCustomerInputEnvelope = {
    data: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type PractitionerCustomerOrderHistoryCreateWithoutCustomerInput = {
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerBox: PractitionerBoxCreateNestedOneWithoutPractitionerCustomerOrderHistoryInput
  }

  export type PractitionerCustomerOrderHistoryUncheckedCreateWithoutCustomerInput = {
    id?: number
    practitionerBoxId: number
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerCustomerOrderHistoryCreateOrConnectWithoutCustomerInput = {
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
    create: XOR<PractitionerCustomerOrderHistoryCreateWithoutCustomerInput, PractitionerCustomerOrderHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type PractitionerCustomerOrderHistoryCreateManyCustomerInputEnvelope = {
    data: Enumerable<PractitionerCustomerOrderHistoryCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerNutritionNeedUpsertWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
    update: XOR<IntermediateCustomerNutritionNeedUpdateWithoutCustomerInput, IntermediateCustomerNutritionNeedUncheckedUpdateWithoutCustomerInput>
    create: XOR<IntermediateCustomerNutritionNeedCreateWithoutCustomerInput, IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerNutritionNeedUpdateWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
    data: XOR<IntermediateCustomerNutritionNeedUpdateWithoutCustomerInput, IntermediateCustomerNutritionNeedUncheckedUpdateWithoutCustomerInput>
  }

  export type IntermediateCustomerNutritionNeedUpdateManyWithWhereWithoutCustomerInput = {
    where: IntermediateCustomerNutritionNeedScalarWhereInput
    data: XOR<IntermediateCustomerNutritionNeedUpdateManyMutationInput, IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutIntermediateCustomerNutritionNeedsInput>
  }

  export type IntermediateCustomerNutritionNeedScalarWhereInput = {
    AND?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereInput>
    OR?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereInput>
    NOT?: Enumerable<IntermediateCustomerNutritionNeedScalarWhereInput>
    customerNutritionNeedId?: IntFilter | number
    customerId?: IntFilter | number
    nutritionValue?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerMedicalConditionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
    update: XOR<IntermediateCustomerMedicalConditionUpdateWithoutCustomerInput, IntermediateCustomerMedicalConditionUncheckedUpdateWithoutCustomerInput>
    create: XOR<IntermediateCustomerMedicalConditionCreateWithoutCustomerInput, IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerMedicalConditionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
    data: XOR<IntermediateCustomerMedicalConditionUpdateWithoutCustomerInput, IntermediateCustomerMedicalConditionUncheckedUpdateWithoutCustomerInput>
  }

  export type IntermediateCustomerMedicalConditionUpdateManyWithWhereWithoutCustomerInput = {
    where: IntermediateCustomerMedicalConditionScalarWhereInput
    data: XOR<IntermediateCustomerMedicalConditionUpdateManyMutationInput, IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutIntermediateCustomerMedicalConditionsInput>
  }

  export type IntermediateCustomerMedicalConditionScalarWhereInput = {
    AND?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereInput>
    OR?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereInput>
    NOT?: Enumerable<IntermediateCustomerMedicalConditionScalarWhereInput>
    medicalConditionValue?: StringFilter | string
    customerMedicalConditionId?: IntFilter | number
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerAllergenUpsertWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerAllergenWhereUniqueInput
    update: XOR<IntermediateCustomerAllergenUpdateWithoutCustomerInput, IntermediateCustomerAllergenUncheckedUpdateWithoutCustomerInput>
    create: XOR<IntermediateCustomerAllergenCreateWithoutCustomerInput, IntermediateCustomerAllergenUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerAllergenUpdateWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerAllergenWhereUniqueInput
    data: XOR<IntermediateCustomerAllergenUpdateWithoutCustomerInput, IntermediateCustomerAllergenUncheckedUpdateWithoutCustomerInput>
  }

  export type IntermediateCustomerAllergenUpdateManyWithWhereWithoutCustomerInput = {
    where: IntermediateCustomerAllergenScalarWhereInput
    data: XOR<IntermediateCustomerAllergenUpdateManyMutationInput, IntermediateCustomerAllergenUncheckedUpdateManyWithoutIntermediateCustomerAllergensInput>
  }

  export type IntermediateCustomerAllergenScalarWhereInput = {
    AND?: Enumerable<IntermediateCustomerAllergenScalarWhereInput>
    OR?: Enumerable<IntermediateCustomerAllergenScalarWhereInput>
    NOT?: Enumerable<IntermediateCustomerAllergenScalarWhereInput>
    customerId?: IntFilter | number
    productAllergenId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyQuestionAnswerUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    update: XOR<SurveyQuestionAnswerUpdateWithoutCustomerInput, SurveyQuestionAnswerUncheckedUpdateWithoutCustomerInput>
    create: XOR<SurveyQuestionAnswerCreateWithoutCustomerInput, SurveyQuestionAnswerUncheckedCreateWithoutCustomerInput>
  }

  export type SurveyQuestionAnswerUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    data: XOR<SurveyQuestionAnswerUpdateWithoutCustomerInput, SurveyQuestionAnswerUncheckedUpdateWithoutCustomerInput>
  }

  export type SurveyQuestionAnswerUpdateManyWithWhereWithoutCustomerInput = {
    where: SurveyQuestionAnswerScalarWhereInput
    data: XOR<SurveyQuestionAnswerUpdateManyMutationInput, SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionAnswerInput>
  }

  export type SurveyQuestionAnswerScalarWhereInput = {
    AND?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
    OR?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
    NOT?: Enumerable<SurveyQuestionAnswerScalarWhereInput>
    id?: IntFilter | number
    responseId?: StringNullableFilter | string | null
    customerId?: IntFilter | number
    surveyQuestionId?: IntFilter | number
    answerSingleOptionId?: IntNullableFilter | number | null
    answerNumeric?: IntNullableFilter | number | null
    answerText?: StringNullableFilter | string | null
    answerBool?: BoolNullableFilter | boolean | null
    reason?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
    answerCount?: IntNullableFilter | number | null
    productId?: IntNullableFilter | number | null
    orderNumber?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerProductDistanceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerProductDistanceWhereUniqueInput
    update: XOR<CustomerProductDistanceUpdateWithoutCustomerInput, CustomerProductDistanceUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerProductDistanceCreateWithoutCustomerInput, CustomerProductDistanceUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerProductDistanceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerProductDistanceWhereUniqueInput
    data: XOR<CustomerProductDistanceUpdateWithoutCustomerInput, CustomerProductDistanceUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerProductDistanceUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerProductDistanceScalarWhereInput
    data: XOR<CustomerProductDistanceUpdateManyMutationInput, CustomerProductDistanceUncheckedUpdateManyWithoutCustomerProductDistancesInput>
  }

  export type CustomerProductDistanceScalarWhereInput = {
    AND?: Enumerable<CustomerProductDistanceScalarWhereInput>
    OR?: Enumerable<CustomerProductDistanceScalarWhereInput>
    NOT?: Enumerable<CustomerProductDistanceScalarWhereInput>
    id?: IntFilter | number
    distance?: FloatFilter | number
    productId?: IntFilter | number
    customerId?: IntFilter | number
    version?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerBoxItemsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerBoxItemsWhereUniqueInput
    update: XOR<CustomerBoxItemsUpdateWithoutCustomerInput, CustomerBoxItemsUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerBoxItemsCreateWithoutCustomerInput, CustomerBoxItemsUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerBoxItemsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerBoxItemsWhereUniqueInput
    data: XOR<CustomerBoxItemsUpdateWithoutCustomerInput, CustomerBoxItemsUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerBoxItemsUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerBoxItemsScalarWhereInput
    data: XOR<CustomerBoxItemsUpdateManyMutationInput, CustomerBoxItemsUncheckedUpdateManyWithoutCustomerBoxItemsInput>
  }

  export type CustomerBoxItemsScalarWhereInput = {
    AND?: Enumerable<CustomerBoxItemsScalarWhereInput>
    OR?: Enumerable<CustomerBoxItemsScalarWhereInput>
    NOT?: Enumerable<CustomerBoxItemsScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type QueuedShopifyOrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: QueuedShopifyOrderWhereUniqueInput
    update: XOR<QueuedShopifyOrderUpdateWithoutCustomerInput, QueuedShopifyOrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<QueuedShopifyOrderCreateWithoutCustomerInput, QueuedShopifyOrderUncheckedCreateWithoutCustomerInput>
  }

  export type QueuedShopifyOrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: QueuedShopifyOrderWhereUniqueInput
    data: XOR<QueuedShopifyOrderUpdateWithoutCustomerInput, QueuedShopifyOrderUncheckedUpdateWithoutCustomerInput>
  }

  export type QueuedShopifyOrderUpdateManyWithWhereWithoutCustomerInput = {
    where: QueuedShopifyOrderScalarWhereInput
    data: XOR<QueuedShopifyOrderUpdateManyMutationInput, QueuedShopifyOrderUncheckedUpdateManyWithoutQueuedShopifyOrderInput>
  }

  export type QueuedShopifyOrderScalarWhereInput = {
    AND?: Enumerable<QueuedShopifyOrderScalarWhereInput>
    OR?: Enumerable<QueuedShopifyOrderScalarWhereInput>
    NOT?: Enumerable<QueuedShopifyOrderScalarWhereInput>
    id?: IntFilter | number
    customerId?: IntFilter | number
    orderName?: StringFilter | string
    status?: EnumQueueStatusFilter | QueueStatus
    scheduledAt?: StringFilter | string
    orderedAt?: StringNullableFilter | string | null
    fulfilledAt?: StringNullableFilter | string | null
  }

  export type IntermediateCustomerFlavorDislikeUpsertWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
    update: XOR<IntermediateCustomerFlavorDislikeUpdateWithoutCustomerInput, IntermediateCustomerFlavorDislikeUncheckedUpdateWithoutCustomerInput>
    create: XOR<IntermediateCustomerFlavorDislikeCreateWithoutCustomerInput, IntermediateCustomerFlavorDislikeUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerFlavorDislikeUpdateWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
    data: XOR<IntermediateCustomerFlavorDislikeUpdateWithoutCustomerInput, IntermediateCustomerFlavorDislikeUncheckedUpdateWithoutCustomerInput>
  }

  export type IntermediateCustomerFlavorDislikeUpdateManyWithWhereWithoutCustomerInput = {
    where: IntermediateCustomerFlavorDislikeScalarWhereInput
    data: XOR<IntermediateCustomerFlavorDislikeUpdateManyMutationInput, IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutIntermediateCustomerFlavorDislikesInput>
  }

  export type IntermediateCustomerFlavorDislikeScalarWhereInput = {
    AND?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereInput>
    OR?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereInput>
    NOT?: Enumerable<IntermediateCustomerFlavorDislikeScalarWhereInput>
    productFlavorId?: IntFilter | number
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerCategoryPreferenceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    update: XOR<IntermediateCustomerCategoryPreferenceUpdateWithoutCustomerInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateWithoutCustomerInput>
    create: XOR<IntermediateCustomerCategoryPreferenceCreateWithoutCustomerInput, IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerCategoryPreferenceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    data: XOR<IntermediateCustomerCategoryPreferenceUpdateWithoutCustomerInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateWithoutCustomerInput>
  }

  export type IntermediateCustomerCategoryPreferenceUpdateManyWithWhereWithoutCustomerInput = {
    where: IntermediateCustomerCategoryPreferenceScalarWhereInput
    data: XOR<IntermediateCustomerCategoryPreferenceUpdateManyMutationInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutIntermediateCustomerCategoryPreferencesInput>
  }

  export type IntermediateCustomerCategoryPreferenceScalarWhereInput = {
    AND?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereInput>
    OR?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereInput>
    NOT?: Enumerable<IntermediateCustomerCategoryPreferenceScalarWhereInput>
    productCategoryId?: IntFilter | number
    customerId?: IntFilter | number
    rank?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerIngredientDislikeUpsertWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
    update: XOR<IntermediateCustomerIngredientDislikeUpdateWithoutCustomerInput, IntermediateCustomerIngredientDislikeUncheckedUpdateWithoutCustomerInput>
    create: XOR<IntermediateCustomerIngredientDislikeCreateWithoutCustomerInput, IntermediateCustomerIngredientDislikeUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerIngredientDislikeUpdateWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
    data: XOR<IntermediateCustomerIngredientDislikeUpdateWithoutCustomerInput, IntermediateCustomerIngredientDislikeUncheckedUpdateWithoutCustomerInput>
  }

  export type IntermediateCustomerIngredientDislikeUpdateManyWithWhereWithoutCustomerInput = {
    where: IntermediateCustomerIngredientDislikeScalarWhereInput
    data: XOR<IntermediateCustomerIngredientDislikeUpdateManyMutationInput, IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutIntermediateCustomerIngredientDislikesInput>
  }

  export type IntermediateCustomerIngredientDislikeScalarWhereInput = {
    AND?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereInput>
    OR?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereInput>
    NOT?: Enumerable<IntermediateCustomerIngredientDislikeScalarWhereInput>
    productIngredientId?: IntFilter | number
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerFoodTypeUpsertWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerFoodTypeWhereUniqueInput
    update: XOR<IntermediateCustomerFoodTypeUpdateWithoutCustomerInput, IntermediateCustomerFoodTypeUncheckedUpdateWithoutCustomerInput>
    create: XOR<IntermediateCustomerFoodTypeCreateWithoutCustomerInput, IntermediateCustomerFoodTypeUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerFoodTypeUpdateWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerFoodTypeWhereUniqueInput
    data: XOR<IntermediateCustomerFoodTypeUpdateWithoutCustomerInput, IntermediateCustomerFoodTypeUncheckedUpdateWithoutCustomerInput>
  }

  export type IntermediateCustomerFoodTypeUpdateManyWithWhereWithoutCustomerInput = {
    where: IntermediateCustomerFoodTypeScalarWhereInput
    data: XOR<IntermediateCustomerFoodTypeUpdateManyMutationInput, IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutIntermediateCustomerFoodTypesInput>
  }

  export type IntermediateCustomerFoodTypeScalarWhereInput = {
    AND?: Enumerable<IntermediateCustomerFoodTypeScalarWhereInput>
    OR?: Enumerable<IntermediateCustomerFoodTypeScalarWhereInput>
    NOT?: Enumerable<IntermediateCustomerFoodTypeScalarWhereInput>
    productFoodTypeId?: IntFilter | number
    customerId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodUpsertWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    update: XOR<IntermediateCustomerUnavailableCookingMethodUpdateWithoutCustomerInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateWithoutCustomerInput>
    create: XOR<IntermediateCustomerUnavailableCookingMethodCreateWithoutCustomerInput, IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutCustomerInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateWithWhereUniqueWithoutCustomerInput = {
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    data: XOR<IntermediateCustomerUnavailableCookingMethodUpdateWithoutCustomerInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateWithoutCustomerInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateManyWithWhereWithoutCustomerInput = {
    where: IntermediateCustomerUnavailableCookingMethodScalarWhereInput
    data: XOR<IntermediateCustomerUnavailableCookingMethodUpdateManyMutationInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutIntermediateCustomerUnavailableCookingMethodsInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodScalarWhereInput = {
    AND?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereInput>
    OR?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereInput>
    NOT?: Enumerable<IntermediateCustomerUnavailableCookingMethodScalarWhereInput>
    customerId?: IntFilter | number
    productCookingMethodId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PractitionerCustomerOrderHistoryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
    update: XOR<PractitionerCustomerOrderHistoryUpdateWithoutCustomerInput, PractitionerCustomerOrderHistoryUncheckedUpdateWithoutCustomerInput>
    create: XOR<PractitionerCustomerOrderHistoryCreateWithoutCustomerInput, PractitionerCustomerOrderHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type PractitionerCustomerOrderHistoryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
    data: XOR<PractitionerCustomerOrderHistoryUpdateWithoutCustomerInput, PractitionerCustomerOrderHistoryUncheckedUpdateWithoutCustomerInput>
  }

  export type PractitionerCustomerOrderHistoryUpdateManyWithWhereWithoutCustomerInput = {
    where: PractitionerCustomerOrderHistoryScalarWhereInput
    data: XOR<PractitionerCustomerOrderHistoryUpdateManyMutationInput, PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutPractitionerCustomerOrderHistoryInput>
  }

  export type PractitionerCustomerOrderHistoryScalarWhereInput = {
    AND?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereInput>
    OR?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereInput>
    NOT?: Enumerable<PractitionerCustomerOrderHistoryScalarWhereInput>
    id?: IntFilter | number
    customerId?: IntFilter | number
    practitionerBoxId?: IntFilter | number
    orderNumber?: StringFilter | string
    purchasePrice?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CustomerNutritionNeedCreateWithoutIntermediateCustomerNutritionNeedInput = {
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNutritionNeedUncheckedCreateWithoutIntermediateCustomerNutritionNeedInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerNutritionNeedCreateOrConnectWithoutIntermediateCustomerNutritionNeedInput = {
    where: CustomerNutritionNeedWhereUniqueInput
    create: XOR<CustomerNutritionNeedCreateWithoutIntermediateCustomerNutritionNeedInput, CustomerNutritionNeedUncheckedCreateWithoutIntermediateCustomerNutritionNeedInput>
  }

  export type CustomersCreateWithoutIntermediateCustomerNutritionNeedsInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutIntermediateCustomerNutritionNeedsInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutIntermediateCustomerNutritionNeedsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutIntermediateCustomerNutritionNeedsInput, CustomersUncheckedCreateWithoutIntermediateCustomerNutritionNeedsInput>
  }

  export type CustomerNutritionNeedUpsertWithoutIntermediateCustomerNutritionNeedInput = {
    update: XOR<CustomerNutritionNeedUpdateWithoutIntermediateCustomerNutritionNeedInput, CustomerNutritionNeedUncheckedUpdateWithoutIntermediateCustomerNutritionNeedInput>
    create: XOR<CustomerNutritionNeedCreateWithoutIntermediateCustomerNutritionNeedInput, CustomerNutritionNeedUncheckedCreateWithoutIntermediateCustomerNutritionNeedInput>
  }

  export type CustomerNutritionNeedUpdateWithoutIntermediateCustomerNutritionNeedInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerNutritionNeedUncheckedUpdateWithoutIntermediateCustomerNutritionNeedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersUpsertWithoutIntermediateCustomerNutritionNeedsInput = {
    update: XOR<CustomersUpdateWithoutIntermediateCustomerNutritionNeedsInput, CustomersUncheckedUpdateWithoutIntermediateCustomerNutritionNeedsInput>
    create: XOR<CustomersCreateWithoutIntermediateCustomerNutritionNeedsInput, CustomersUncheckedCreateWithoutIntermediateCustomerNutritionNeedsInput>
  }

  export type CustomersUpdateWithoutIntermediateCustomerNutritionNeedsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutIntermediateCustomerNutritionNeedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type IntermediateCustomerNutritionNeedCreateWithoutCustomerNutritionNeedInput = {
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerNutritionNeedsInput
  }

  export type IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerNutritionNeedInput = {
    customerId: number
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerNutritionNeedCreateOrConnectWithoutCustomerNutritionNeedInput = {
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
    create: XOR<IntermediateCustomerNutritionNeedCreateWithoutCustomerNutritionNeedInput, IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerNutritionNeedInput>
  }

  export type IntermediateCustomerNutritionNeedCreateManyCustomerNutritionNeedInputEnvelope = {
    data: Enumerable<IntermediateCustomerNutritionNeedCreateManyCustomerNutritionNeedInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerNutritionNeedUpsertWithWhereUniqueWithoutCustomerNutritionNeedInput = {
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
    update: XOR<IntermediateCustomerNutritionNeedUpdateWithoutCustomerNutritionNeedInput, IntermediateCustomerNutritionNeedUncheckedUpdateWithoutCustomerNutritionNeedInput>
    create: XOR<IntermediateCustomerNutritionNeedCreateWithoutCustomerNutritionNeedInput, IntermediateCustomerNutritionNeedUncheckedCreateWithoutCustomerNutritionNeedInput>
  }

  export type IntermediateCustomerNutritionNeedUpdateWithWhereUniqueWithoutCustomerNutritionNeedInput = {
    where: IntermediateCustomerNutritionNeedWhereUniqueInput
    data: XOR<IntermediateCustomerNutritionNeedUpdateWithoutCustomerNutritionNeedInput, IntermediateCustomerNutritionNeedUncheckedUpdateWithoutCustomerNutritionNeedInput>
  }

  export type IntermediateCustomerNutritionNeedUpdateManyWithWhereWithoutCustomerNutritionNeedInput = {
    where: IntermediateCustomerNutritionNeedScalarWhereInput
    data: XOR<IntermediateCustomerNutritionNeedUpdateManyMutationInput, IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutIntermediateCustomerNutritionNeedInput>
  }

  export type CustomerMedicalConditionCreateWithoutIntermediateCustomerMedicalConditionsInput = {
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerMedicalConditionUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerMedicalConditionCreateOrConnectWithoutIntermediateCustomerMedicalConditionsInput = {
    where: CustomerMedicalConditionWhereUniqueInput
    create: XOR<CustomerMedicalConditionCreateWithoutIntermediateCustomerMedicalConditionsInput, CustomerMedicalConditionUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput>
  }

  export type CustomersCreateWithoutIntermediateCustomerMedicalConditionsInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutIntermediateCustomerMedicalConditionsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutIntermediateCustomerMedicalConditionsInput, CustomersUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput>
  }

  export type CustomerMedicalConditionUpsertWithoutIntermediateCustomerMedicalConditionsInput = {
    update: XOR<CustomerMedicalConditionUpdateWithoutIntermediateCustomerMedicalConditionsInput, CustomerMedicalConditionUncheckedUpdateWithoutIntermediateCustomerMedicalConditionsInput>
    create: XOR<CustomerMedicalConditionCreateWithoutIntermediateCustomerMedicalConditionsInput, CustomerMedicalConditionUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput>
  }

  export type CustomerMedicalConditionUpdateWithoutIntermediateCustomerMedicalConditionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerMedicalConditionUncheckedUpdateWithoutIntermediateCustomerMedicalConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersUpsertWithoutIntermediateCustomerMedicalConditionsInput = {
    update: XOR<CustomersUpdateWithoutIntermediateCustomerMedicalConditionsInput, CustomersUncheckedUpdateWithoutIntermediateCustomerMedicalConditionsInput>
    create: XOR<CustomersCreateWithoutIntermediateCustomerMedicalConditionsInput, CustomersUncheckedCreateWithoutIntermediateCustomerMedicalConditionsInput>
  }

  export type CustomersUpdateWithoutIntermediateCustomerMedicalConditionsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutIntermediateCustomerMedicalConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type IntermediateCustomerMedicalConditionCreateWithoutCustomerMedicalConditionInput = {
    medicalConditionValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerMedicalConditionsInput
  }

  export type IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerMedicalConditionInput = {
    medicalConditionValue: string
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerMedicalConditionCreateOrConnectWithoutCustomerMedicalConditionInput = {
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
    create: XOR<IntermediateCustomerMedicalConditionCreateWithoutCustomerMedicalConditionInput, IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerMedicalConditionInput>
  }

  export type IntermediateCustomerMedicalConditionCreateManyCustomerMedicalConditionInputEnvelope = {
    data: Enumerable<IntermediateCustomerMedicalConditionCreateManyCustomerMedicalConditionInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerMedicalConditionUpsertWithWhereUniqueWithoutCustomerMedicalConditionInput = {
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
    update: XOR<IntermediateCustomerMedicalConditionUpdateWithoutCustomerMedicalConditionInput, IntermediateCustomerMedicalConditionUncheckedUpdateWithoutCustomerMedicalConditionInput>
    create: XOR<IntermediateCustomerMedicalConditionCreateWithoutCustomerMedicalConditionInput, IntermediateCustomerMedicalConditionUncheckedCreateWithoutCustomerMedicalConditionInput>
  }

  export type IntermediateCustomerMedicalConditionUpdateWithWhereUniqueWithoutCustomerMedicalConditionInput = {
    where: IntermediateCustomerMedicalConditionWhereUniqueInput
    data: XOR<IntermediateCustomerMedicalConditionUpdateWithoutCustomerMedicalConditionInput, IntermediateCustomerMedicalConditionUncheckedUpdateWithoutCustomerMedicalConditionInput>
  }

  export type IntermediateCustomerMedicalConditionUpdateManyWithWhereWithoutCustomerMedicalConditionInput = {
    where: IntermediateCustomerMedicalConditionScalarWhereInput
    data: XOR<IntermediateCustomerMedicalConditionUpdateManyMutationInput, IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutIntermediateCustomerMedicalConditionsInput>
  }

  export type ProductFoodTypeCreateWithoutIntermediateCustomerFoodTypesInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeUncheckedCreateWithoutIntermediateCustomerFoodTypesInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeCreateOrConnectWithoutIntermediateCustomerFoodTypesInput = {
    where: ProductFoodTypeWhereUniqueInput
    create: XOR<ProductFoodTypeCreateWithoutIntermediateCustomerFoodTypesInput, ProductFoodTypeUncheckedCreateWithoutIntermediateCustomerFoodTypesInput>
  }

  export type CustomersCreateWithoutIntermediateCustomerFoodTypesInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutIntermediateCustomerFoodTypesInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutIntermediateCustomerFoodTypesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutIntermediateCustomerFoodTypesInput, CustomersUncheckedCreateWithoutIntermediateCustomerFoodTypesInput>
  }

  export type ProductFoodTypeUpsertWithoutIntermediateCustomerFoodTypesInput = {
    update: XOR<ProductFoodTypeUpdateWithoutIntermediateCustomerFoodTypesInput, ProductFoodTypeUncheckedUpdateWithoutIntermediateCustomerFoodTypesInput>
    create: XOR<ProductFoodTypeCreateWithoutIntermediateCustomerFoodTypesInput, ProductFoodTypeUncheckedCreateWithoutIntermediateCustomerFoodTypesInput>
  }

  export type ProductFoodTypeUpdateWithoutIntermediateCustomerFoodTypesInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeUncheckedUpdateWithoutIntermediateCustomerFoodTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductFoodTypeInput
  }

  export type CustomersUpsertWithoutIntermediateCustomerFoodTypesInput = {
    update: XOR<CustomersUpdateWithoutIntermediateCustomerFoodTypesInput, CustomersUncheckedUpdateWithoutIntermediateCustomerFoodTypesInput>
    create: XOR<CustomersCreateWithoutIntermediateCustomerFoodTypesInput, CustomersUncheckedCreateWithoutIntermediateCustomerFoodTypesInput>
  }

  export type CustomersUpdateWithoutIntermediateCustomerFoodTypesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutIntermediateCustomerFoodTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type IntermediateCustomerFoodTypeCreateWithoutProductFoodTypeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerFoodTypesInput
  }

  export type IntermediateCustomerFoodTypeUncheckedCreateWithoutProductFoodTypeInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFoodTypeCreateOrConnectWithoutProductFoodTypeInput = {
    where: IntermediateCustomerFoodTypeWhereUniqueInput
    create: XOR<IntermediateCustomerFoodTypeCreateWithoutProductFoodTypeInput, IntermediateCustomerFoodTypeUncheckedCreateWithoutProductFoodTypeInput>
  }

  export type IntermediateCustomerFoodTypeCreateManyProductFoodTypeInputEnvelope = {
    data: Enumerable<IntermediateCustomerFoodTypeCreateManyProductFoodTypeInput>
    skipDuplicates?: boolean
  }

  export type IntermediateProductFoodTypeCreateWithoutProductFoodTypeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntermediateProductFoodTypesInput
  }

  export type IntermediateProductFoodTypeUncheckedCreateWithoutProductFoodTypeInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductFoodTypeCreateOrConnectWithoutProductFoodTypeInput = {
    where: IntermediateProductFoodTypeWhereUniqueInput
    create: XOR<IntermediateProductFoodTypeCreateWithoutProductFoodTypeInput, IntermediateProductFoodTypeUncheckedCreateWithoutProductFoodTypeInput>
  }

  export type IntermediateProductFoodTypeCreateManyProductFoodTypeInputEnvelope = {
    data: Enumerable<IntermediateProductFoodTypeCreateManyProductFoodTypeInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerFoodTypeUpsertWithWhereUniqueWithoutProductFoodTypeInput = {
    where: IntermediateCustomerFoodTypeWhereUniqueInput
    update: XOR<IntermediateCustomerFoodTypeUpdateWithoutProductFoodTypeInput, IntermediateCustomerFoodTypeUncheckedUpdateWithoutProductFoodTypeInput>
    create: XOR<IntermediateCustomerFoodTypeCreateWithoutProductFoodTypeInput, IntermediateCustomerFoodTypeUncheckedCreateWithoutProductFoodTypeInput>
  }

  export type IntermediateCustomerFoodTypeUpdateWithWhereUniqueWithoutProductFoodTypeInput = {
    where: IntermediateCustomerFoodTypeWhereUniqueInput
    data: XOR<IntermediateCustomerFoodTypeUpdateWithoutProductFoodTypeInput, IntermediateCustomerFoodTypeUncheckedUpdateWithoutProductFoodTypeInput>
  }

  export type IntermediateCustomerFoodTypeUpdateManyWithWhereWithoutProductFoodTypeInput = {
    where: IntermediateCustomerFoodTypeScalarWhereInput
    data: XOR<IntermediateCustomerFoodTypeUpdateManyMutationInput, IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutIntermediateCustomerFoodTypesInput>
  }

  export type IntermediateProductFoodTypeUpsertWithWhereUniqueWithoutProductFoodTypeInput = {
    where: IntermediateProductFoodTypeWhereUniqueInput
    update: XOR<IntermediateProductFoodTypeUpdateWithoutProductFoodTypeInput, IntermediateProductFoodTypeUncheckedUpdateWithoutProductFoodTypeInput>
    create: XOR<IntermediateProductFoodTypeCreateWithoutProductFoodTypeInput, IntermediateProductFoodTypeUncheckedCreateWithoutProductFoodTypeInput>
  }

  export type IntermediateProductFoodTypeUpdateWithWhereUniqueWithoutProductFoodTypeInput = {
    where: IntermediateProductFoodTypeWhereUniqueInput
    data: XOR<IntermediateProductFoodTypeUpdateWithoutProductFoodTypeInput, IntermediateProductFoodTypeUncheckedUpdateWithoutProductFoodTypeInput>
  }

  export type IntermediateProductFoodTypeUpdateManyWithWhereWithoutProductFoodTypeInput = {
    where: IntermediateProductFoodTypeScalarWhereInput
    data: XOR<IntermediateProductFoodTypeUpdateManyMutationInput, IntermediateProductFoodTypeUncheckedUpdateManyWithoutIntermediateProductFoodTypesInput>
  }

  export type IntermediateProductFoodTypeScalarWhereInput = {
    AND?: Enumerable<IntermediateProductFoodTypeScalarWhereInput>
    OR?: Enumerable<IntermediateProductFoodTypeScalarWhereInput>
    NOT?: Enumerable<IntermediateProductFoodTypeScalarWhereInput>
    productFoodTypeId?: IntFilter | number
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductFoodTypeCreateWithoutIntermediateProductFoodTypesInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeUncheckedCreateWithoutIntermediateProductFoodTypesInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeCreateOrConnectWithoutIntermediateProductFoodTypesInput = {
    where: ProductFoodTypeWhereUniqueInput
    create: XOR<ProductFoodTypeCreateWithoutIntermediateProductFoodTypesInput, ProductFoodTypeUncheckedCreateWithoutIntermediateProductFoodTypesInput>
  }

  export type ProductCreateWithoutIntermediateProductFoodTypesInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutIntermediateProductFoodTypesInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutIntermediateProductFoodTypesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutIntermediateProductFoodTypesInput, ProductUncheckedCreateWithoutIntermediateProductFoodTypesInput>
  }

  export type ProductFoodTypeUpsertWithoutIntermediateProductFoodTypesInput = {
    update: XOR<ProductFoodTypeUpdateWithoutIntermediateProductFoodTypesInput, ProductFoodTypeUncheckedUpdateWithoutIntermediateProductFoodTypesInput>
    create: XOR<ProductFoodTypeCreateWithoutIntermediateProductFoodTypesInput, ProductFoodTypeUncheckedCreateWithoutIntermediateProductFoodTypesInput>
  }

  export type ProductFoodTypeUpdateWithoutIntermediateProductFoodTypesInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutProductFoodTypeInput
  }

  export type ProductFoodTypeUncheckedUpdateWithoutIntermediateProductFoodTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutProductFoodTypeInput
  }

  export type ProductUpsertWithoutIntermediateProductFoodTypesInput = {
    update: XOR<ProductUpdateWithoutIntermediateProductFoodTypesInput, ProductUncheckedUpdateWithoutIntermediateProductFoodTypesInput>
    create: XOR<ProductCreateWithoutIntermediateProductFoodTypesInput, ProductUncheckedCreateWithoutIntermediateProductFoodTypesInput>
  }

  export type ProductUpdateWithoutIntermediateProductFoodTypesInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutIntermediateProductFoodTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type ProductProviderCreateWithoutProductsInput = {
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProviderUncheckedCreateWithoutProductsInput = {
    id?: number
    provider: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductProviderCreateOrConnectWithoutProductsInput = {
    where: ProductProviderWhereUniqueInput
    create: XOR<ProductProviderCreateWithoutProductsInput, ProductProviderUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    label: string
    name: string
    src?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    label: string
    name: string
    src?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductFlavorCreateWithoutProductsInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutProductFlavorInput
  }

  export type ProductFlavorUncheckedCreateWithoutProductsInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutProductFlavorInput
  }

  export type ProductFlavorCreateOrConnectWithoutProductsInput = {
    where: ProductFlavorWhereUniqueInput
    create: XOR<ProductFlavorCreateWithoutProductsInput, ProductFlavorUncheckedCreateWithoutProductsInput>
  }

  export type ProductVendorCreateWithoutProductsInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVendorUncheckedCreateWithoutProductsInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVendorCreateOrConnectWithoutProductsInput = {
    where: ProductVendorWhereUniqueInput
    create: XOR<ProductVendorCreateWithoutProductsInput, ProductVendorUncheckedCreateWithoutProductsInput>
  }

  export type IntermediateProductFoodTypeCreateWithoutProductInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productFoodType: ProductFoodTypeCreateNestedOneWithoutIntermediateProductFoodTypesInput
  }

  export type IntermediateProductFoodTypeUncheckedCreateWithoutProductInput = {
    productFoodTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductFoodTypeCreateOrConnectWithoutProductInput = {
    where: IntermediateProductFoodTypeWhereUniqueInput
    create: XOR<IntermediateProductFoodTypeCreateWithoutProductInput, IntermediateProductFoodTypeUncheckedCreateWithoutProductInput>
  }

  export type IntermediateProductFoodTypeCreateManyProductInputEnvelope = {
    data: Enumerable<IntermediateProductFoodTypeCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type IntermediateProductIngredientCreateWithoutProductInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productIngredient: ProductIngredientCreateNestedOneWithoutIntermediateProductIngredientsInput
  }

  export type IntermediateProductIngredientUncheckedCreateWithoutProductInput = {
    productIngredientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductIngredientCreateOrConnectWithoutProductInput = {
    where: IntermediateProductIngredientWhereUniqueInput
    create: XOR<IntermediateProductIngredientCreateWithoutProductInput, IntermediateProductIngredientUncheckedCreateWithoutProductInput>
  }

  export type IntermediateProductIngredientCreateManyProductInputEnvelope = {
    data: Enumerable<IntermediateProductIngredientCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type IntermediateProductAllergenCreateWithoutProductInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productAllergen: ProductAllergenCreateNestedOneWithoutIntermediateProductAllergensInput
  }

  export type IntermediateProductAllergenUncheckedCreateWithoutProductInput = {
    productAllergenId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductAllergenCreateOrConnectWithoutProductInput = {
    where: IntermediateProductAllergenWhereUniqueInput
    create: XOR<IntermediateProductAllergenCreateWithoutProductInput, IntermediateProductAllergenUncheckedCreateWithoutProductInput>
  }

  export type IntermediateProductAllergenCreateManyProductInputEnvelope = {
    data: Enumerable<IntermediateProductAllergenCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type IntermediateProductCookingMethodCreateWithoutProductInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    productCookingMethod: ProductCookingMethodCreateNestedOneWithoutIntermediateProductCookingMethodsInput
  }

  export type IntermediateProductCookingMethodUncheckedCreateWithoutProductInput = {
    productCookingMethodId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductCookingMethodCreateOrConnectWithoutProductInput = {
    where: IntermediateProductCookingMethodWhereUniqueInput
    create: XOR<IntermediateProductCookingMethodCreateWithoutProductInput, IntermediateProductCookingMethodUncheckedCreateWithoutProductInput>
  }

  export type IntermediateProductCookingMethodCreateManyProductInputEnvelope = {
    data: Enumerable<IntermediateProductCookingMethodCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type IntermediatePractitionerBoxProductCreateWithoutProductInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerBox: PractitionerBoxCreateNestedOneWithoutIntermediatePractitionerBoxProductInput
  }

  export type IntermediatePractitionerBoxProductUncheckedCreateWithoutProductInput = {
    practitionerBoxId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediatePractitionerBoxProductCreateOrConnectWithoutProductInput = {
    where: IntermediatePractitionerBoxProductWhereUniqueInput
    create: XOR<IntermediatePractitionerBoxProductCreateWithoutProductInput, IntermediatePractitionerBoxProductUncheckedCreateWithoutProductInput>
  }

  export type IntermediatePractitionerBoxProductCreateManyProductInputEnvelope = {
    data: Enumerable<IntermediatePractitionerBoxProductCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductNutritionFactCreateWithoutProductInput = {
    quantity?: number | null
    servingSize?: number | null
    calories?: number | null
    totalFatG?: number | null
    saturatedFatG?: number | null
    transFatG?: number | null
    cholesteroleMg?: number | null
    sodiumMg?: number | null
    totalCarbohydrateG?: number | null
    dietaryFiberG?: number | null
    totalSugarG?: number | null
    addedSugarG?: number | null
    proteinG?: number | null
    sweet?: number | null
    sour?: number | null
    salty?: number | null
    bitter?: number | null
    spicy?: number | null
    texture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductNutritionFactUncheckedCreateWithoutProductInput = {
    id?: number
    quantity?: number | null
    servingSize?: number | null
    calories?: number | null
    totalFatG?: number | null
    saturatedFatG?: number | null
    transFatG?: number | null
    cholesteroleMg?: number | null
    sodiumMg?: number | null
    totalCarbohydrateG?: number | null
    dietaryFiberG?: number | null
    totalSugarG?: number | null
    addedSugarG?: number | null
    proteinG?: number | null
    sweet?: number | null
    sour?: number | null
    salty?: number | null
    bitter?: number | null
    spicy?: number | null
    texture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductNutritionFactCreateOrConnectWithoutProductInput = {
    where: ProductNutritionFactWhereUniqueInput
    create: XOR<ProductNutritionFactCreateWithoutProductInput, ProductNutritionFactUncheckedCreateWithoutProductInput>
  }

  export type SurveyQuestionAnswerCreateWithoutProductInput = {
    responseId?: string | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionAnswerInput
    customer: CustomersCreateNestedOneWithoutSurveyQuestionAnswerInput
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionCreateNestedOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedCreateWithoutProductInput = {
    id?: number
    responseId?: string | null
    customerId: number
    surveyQuestionId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerCreateOrConnectWithoutProductInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    create: XOR<SurveyQuestionAnswerCreateWithoutProductInput, SurveyQuestionAnswerUncheckedCreateWithoutProductInput>
  }

  export type SurveyQuestionAnswerCreateManyProductInputEnvelope = {
    data: Enumerable<SurveyQuestionAnswerCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type CustomerProductDistanceCreateWithoutProductInput = {
    distance: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutCustomerProductDistancesInput
  }

  export type CustomerProductDistanceUncheckedCreateWithoutProductInput = {
    id?: number
    distance: number
    customerId: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductDistanceCreateOrConnectWithoutProductInput = {
    where: CustomerProductDistanceWhereUniqueInput
    create: XOR<CustomerProductDistanceCreateWithoutProductInput, CustomerProductDistanceUncheckedCreateWithoutProductInput>
  }

  export type CustomerProductDistanceCreateManyProductInputEnvelope = {
    data: Enumerable<CustomerProductDistanceCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type CustomerBoxItemsCreateWithoutProductInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutCustomerBoxItemsInput
  }

  export type CustomerBoxItemsUncheckedCreateWithoutProductInput = {
    id?: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerBoxItemsCreateOrConnectWithoutProductInput = {
    where: CustomerBoxItemsWhereUniqueInput
    create: XOR<CustomerBoxItemsCreateWithoutProductInput, CustomerBoxItemsUncheckedCreateWithoutProductInput>
  }

  export type CustomerBoxItemsCreateManyProductInputEnvelope = {
    data: Enumerable<CustomerBoxItemsCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductImageCreateWithoutProductInput = {
    src: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: number
    src: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: Enumerable<ProductImageCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductProviderUpsertWithoutProductsInput = {
    update: XOR<ProductProviderUpdateWithoutProductsInput, ProductProviderUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductProviderCreateWithoutProductsInput, ProductProviderUncheckedCreateWithoutProductsInput>
  }

  export type ProductProviderUpdateWithoutProductsInput = {
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductProviderUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutProductCategoryInput
  }

  export type ProductFlavorUpsertWithoutProductsInput = {
    update: XOR<ProductFlavorUpdateWithoutProductsInput, ProductFlavorUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductFlavorCreateWithoutProductsInput, ProductFlavorUncheckedCreateWithoutProductsInput>
  }

  export type ProductFlavorUpdateWithoutProductsInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutProductFlavorInput
  }

  export type ProductFlavorUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutProductFlavorInput
  }

  export type ProductVendorUpsertWithoutProductsInput = {
    update: XOR<ProductVendorUpdateWithoutProductsInput, ProductVendorUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductVendorCreateWithoutProductsInput, ProductVendorUncheckedCreateWithoutProductsInput>
  }

  export type ProductVendorUpdateWithoutProductsInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVendorUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductFoodTypeUpsertWithWhereUniqueWithoutProductInput = {
    where: IntermediateProductFoodTypeWhereUniqueInput
    update: XOR<IntermediateProductFoodTypeUpdateWithoutProductInput, IntermediateProductFoodTypeUncheckedUpdateWithoutProductInput>
    create: XOR<IntermediateProductFoodTypeCreateWithoutProductInput, IntermediateProductFoodTypeUncheckedCreateWithoutProductInput>
  }

  export type IntermediateProductFoodTypeUpdateWithWhereUniqueWithoutProductInput = {
    where: IntermediateProductFoodTypeWhereUniqueInput
    data: XOR<IntermediateProductFoodTypeUpdateWithoutProductInput, IntermediateProductFoodTypeUncheckedUpdateWithoutProductInput>
  }

  export type IntermediateProductFoodTypeUpdateManyWithWhereWithoutProductInput = {
    where: IntermediateProductFoodTypeScalarWhereInput
    data: XOR<IntermediateProductFoodTypeUpdateManyMutationInput, IntermediateProductFoodTypeUncheckedUpdateManyWithoutIntermediateProductFoodTypesInput>
  }

  export type IntermediateProductIngredientUpsertWithWhereUniqueWithoutProductInput = {
    where: IntermediateProductIngredientWhereUniqueInput
    update: XOR<IntermediateProductIngredientUpdateWithoutProductInput, IntermediateProductIngredientUncheckedUpdateWithoutProductInput>
    create: XOR<IntermediateProductIngredientCreateWithoutProductInput, IntermediateProductIngredientUncheckedCreateWithoutProductInput>
  }

  export type IntermediateProductIngredientUpdateWithWhereUniqueWithoutProductInput = {
    where: IntermediateProductIngredientWhereUniqueInput
    data: XOR<IntermediateProductIngredientUpdateWithoutProductInput, IntermediateProductIngredientUncheckedUpdateWithoutProductInput>
  }

  export type IntermediateProductIngredientUpdateManyWithWhereWithoutProductInput = {
    where: IntermediateProductIngredientScalarWhereInput
    data: XOR<IntermediateProductIngredientUpdateManyMutationInput, IntermediateProductIngredientUncheckedUpdateManyWithoutIntermediateProductIngredientsInput>
  }

  export type IntermediateProductIngredientScalarWhereInput = {
    AND?: Enumerable<IntermediateProductIngredientScalarWhereInput>
    OR?: Enumerable<IntermediateProductIngredientScalarWhereInput>
    NOT?: Enumerable<IntermediateProductIngredientScalarWhereInput>
    productId?: IntFilter | number
    productIngredientId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateProductAllergenUpsertWithWhereUniqueWithoutProductInput = {
    where: IntermediateProductAllergenWhereUniqueInput
    update: XOR<IntermediateProductAllergenUpdateWithoutProductInput, IntermediateProductAllergenUncheckedUpdateWithoutProductInput>
    create: XOR<IntermediateProductAllergenCreateWithoutProductInput, IntermediateProductAllergenUncheckedCreateWithoutProductInput>
  }

  export type IntermediateProductAllergenUpdateWithWhereUniqueWithoutProductInput = {
    where: IntermediateProductAllergenWhereUniqueInput
    data: XOR<IntermediateProductAllergenUpdateWithoutProductInput, IntermediateProductAllergenUncheckedUpdateWithoutProductInput>
  }

  export type IntermediateProductAllergenUpdateManyWithWhereWithoutProductInput = {
    where: IntermediateProductAllergenScalarWhereInput
    data: XOR<IntermediateProductAllergenUpdateManyMutationInput, IntermediateProductAllergenUncheckedUpdateManyWithoutIntermediateProductAllergensInput>
  }

  export type IntermediateProductAllergenScalarWhereInput = {
    AND?: Enumerable<IntermediateProductAllergenScalarWhereInput>
    OR?: Enumerable<IntermediateProductAllergenScalarWhereInput>
    NOT?: Enumerable<IntermediateProductAllergenScalarWhereInput>
    productId?: IntFilter | number
    productAllergenId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateProductCookingMethodUpsertWithWhereUniqueWithoutProductInput = {
    where: IntermediateProductCookingMethodWhereUniqueInput
    update: XOR<IntermediateProductCookingMethodUpdateWithoutProductInput, IntermediateProductCookingMethodUncheckedUpdateWithoutProductInput>
    create: XOR<IntermediateProductCookingMethodCreateWithoutProductInput, IntermediateProductCookingMethodUncheckedCreateWithoutProductInput>
  }

  export type IntermediateProductCookingMethodUpdateWithWhereUniqueWithoutProductInput = {
    where: IntermediateProductCookingMethodWhereUniqueInput
    data: XOR<IntermediateProductCookingMethodUpdateWithoutProductInput, IntermediateProductCookingMethodUncheckedUpdateWithoutProductInput>
  }

  export type IntermediateProductCookingMethodUpdateManyWithWhereWithoutProductInput = {
    where: IntermediateProductCookingMethodScalarWhereInput
    data: XOR<IntermediateProductCookingMethodUpdateManyMutationInput, IntermediateProductCookingMethodUncheckedUpdateManyWithoutIntermediateProductCookingMethodsInput>
  }

  export type IntermediateProductCookingMethodScalarWhereInput = {
    AND?: Enumerable<IntermediateProductCookingMethodScalarWhereInput>
    OR?: Enumerable<IntermediateProductCookingMethodScalarWhereInput>
    NOT?: Enumerable<IntermediateProductCookingMethodScalarWhereInput>
    productId?: IntFilter | number
    productCookingMethodId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediatePractitionerBoxProductUpsertWithWhereUniqueWithoutProductInput = {
    where: IntermediatePractitionerBoxProductWhereUniqueInput
    update: XOR<IntermediatePractitionerBoxProductUpdateWithoutProductInput, IntermediatePractitionerBoxProductUncheckedUpdateWithoutProductInput>
    create: XOR<IntermediatePractitionerBoxProductCreateWithoutProductInput, IntermediatePractitionerBoxProductUncheckedCreateWithoutProductInput>
  }

  export type IntermediatePractitionerBoxProductUpdateWithWhereUniqueWithoutProductInput = {
    where: IntermediatePractitionerBoxProductWhereUniqueInput
    data: XOR<IntermediatePractitionerBoxProductUpdateWithoutProductInput, IntermediatePractitionerBoxProductUncheckedUpdateWithoutProductInput>
  }

  export type IntermediatePractitionerBoxProductUpdateManyWithWhereWithoutProductInput = {
    where: IntermediatePractitionerBoxProductScalarWhereInput
    data: XOR<IntermediatePractitionerBoxProductUpdateManyMutationInput, IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutIntermediatePractitionerBoxProductInput>
  }

  export type IntermediatePractitionerBoxProductScalarWhereInput = {
    AND?: Enumerable<IntermediatePractitionerBoxProductScalarWhereInput>
    OR?: Enumerable<IntermediatePractitionerBoxProductScalarWhereInput>
    NOT?: Enumerable<IntermediatePractitionerBoxProductScalarWhereInput>
    practitionerBoxId?: IntFilter | number
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductNutritionFactUpsertWithoutProductInput = {
    update: XOR<ProductNutritionFactUpdateWithoutProductInput, ProductNutritionFactUncheckedUpdateWithoutProductInput>
    create: XOR<ProductNutritionFactCreateWithoutProductInput, ProductNutritionFactUncheckedCreateWithoutProductInput>
  }

  export type ProductNutritionFactUpdateWithoutProductInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    servingSize?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    totalFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    saturatedFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    transFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesteroleMg?: NullableFloatFieldUpdateOperationsInput | number | null
    sodiumMg?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCarbohydrateG?: NullableFloatFieldUpdateOperationsInput | number | null
    dietaryFiberG?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    addedSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    proteinG?: NullableFloatFieldUpdateOperationsInput | number | null
    sweet?: NullableIntFieldUpdateOperationsInput | number | null
    sour?: NullableIntFieldUpdateOperationsInput | number | null
    salty?: NullableIntFieldUpdateOperationsInput | number | null
    bitter?: NullableIntFieldUpdateOperationsInput | number | null
    spicy?: NullableIntFieldUpdateOperationsInput | number | null
    texture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductNutritionFactUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    servingSize?: NullableIntFieldUpdateOperationsInput | number | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    totalFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    saturatedFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    transFatG?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesteroleMg?: NullableFloatFieldUpdateOperationsInput | number | null
    sodiumMg?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCarbohydrateG?: NullableFloatFieldUpdateOperationsInput | number | null
    dietaryFiberG?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    addedSugarG?: NullableFloatFieldUpdateOperationsInput | number | null
    proteinG?: NullableFloatFieldUpdateOperationsInput | number | null
    sweet?: NullableIntFieldUpdateOperationsInput | number | null
    sour?: NullableIntFieldUpdateOperationsInput | number | null
    salty?: NullableIntFieldUpdateOperationsInput | number | null
    bitter?: NullableIntFieldUpdateOperationsInput | number | null
    spicy?: NullableIntFieldUpdateOperationsInput | number | null
    texture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerUpsertWithWhereUniqueWithoutProductInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    update: XOR<SurveyQuestionAnswerUpdateWithoutProductInput, SurveyQuestionAnswerUncheckedUpdateWithoutProductInput>
    create: XOR<SurveyQuestionAnswerCreateWithoutProductInput, SurveyQuestionAnswerUncheckedCreateWithoutProductInput>
  }

  export type SurveyQuestionAnswerUpdateWithWhereUniqueWithoutProductInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    data: XOR<SurveyQuestionAnswerUpdateWithoutProductInput, SurveyQuestionAnswerUncheckedUpdateWithoutProductInput>
  }

  export type SurveyQuestionAnswerUpdateManyWithWhereWithoutProductInput = {
    where: SurveyQuestionAnswerScalarWhereInput
    data: XOR<SurveyQuestionAnswerUpdateManyMutationInput, SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionAnswerInput>
  }

  export type CustomerProductDistanceUpsertWithWhereUniqueWithoutProductInput = {
    where: CustomerProductDistanceWhereUniqueInput
    update: XOR<CustomerProductDistanceUpdateWithoutProductInput, CustomerProductDistanceUncheckedUpdateWithoutProductInput>
    create: XOR<CustomerProductDistanceCreateWithoutProductInput, CustomerProductDistanceUncheckedCreateWithoutProductInput>
  }

  export type CustomerProductDistanceUpdateWithWhereUniqueWithoutProductInput = {
    where: CustomerProductDistanceWhereUniqueInput
    data: XOR<CustomerProductDistanceUpdateWithoutProductInput, CustomerProductDistanceUncheckedUpdateWithoutProductInput>
  }

  export type CustomerProductDistanceUpdateManyWithWhereWithoutProductInput = {
    where: CustomerProductDistanceScalarWhereInput
    data: XOR<CustomerProductDistanceUpdateManyMutationInput, CustomerProductDistanceUncheckedUpdateManyWithoutCustomerProductDistancesInput>
  }

  export type CustomerBoxItemsUpsertWithWhereUniqueWithoutProductInput = {
    where: CustomerBoxItemsWhereUniqueInput
    update: XOR<CustomerBoxItemsUpdateWithoutProductInput, CustomerBoxItemsUncheckedUpdateWithoutProductInput>
    create: XOR<CustomerBoxItemsCreateWithoutProductInput, CustomerBoxItemsUncheckedCreateWithoutProductInput>
  }

  export type CustomerBoxItemsUpdateWithWhereUniqueWithoutProductInput = {
    where: CustomerBoxItemsWhereUniqueInput
    data: XOR<CustomerBoxItemsUpdateWithoutProductInput, CustomerBoxItemsUncheckedUpdateWithoutProductInput>
  }

  export type CustomerBoxItemsUpdateManyWithWhereWithoutProductInput = {
    where: CustomerBoxItemsScalarWhereInput
    data: XOR<CustomerBoxItemsUpdateManyMutationInput, CustomerBoxItemsUncheckedUpdateManyWithoutCustomerBoxItemsInput>
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductImagesInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: Enumerable<ProductImageScalarWhereInput>
    OR?: Enumerable<ProductImageScalarWhereInput>
    NOT?: Enumerable<ProductImageScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    src?: StringFilter | string
    position?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProductCreateWithoutProductImagesInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductImagesInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
  }

  export type ProductUpsertWithoutProductImagesInput = {
    update: XOR<ProductUpdateWithoutProductImagesInput, ProductUncheckedUpdateWithoutProductImagesInput>
    create: XOR<ProductCreateWithoutProductImagesInput, ProductUncheckedCreateWithoutProductImagesInput>
  }

  export type ProductUpdateWithoutProductImagesInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateWithoutIntermediateProductCookingMethodsInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutIntermediateProductCookingMethodsInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutIntermediateProductCookingMethodsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutIntermediateProductCookingMethodsInput, ProductUncheckedCreateWithoutIntermediateProductCookingMethodsInput>
  }

  export type ProductCookingMethodCreateWithoutIntermediateProductCookingMethodsInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodUncheckedCreateWithoutIntermediateProductCookingMethodsInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodCreateOrConnectWithoutIntermediateProductCookingMethodsInput = {
    where: ProductCookingMethodWhereUniqueInput
    create: XOR<ProductCookingMethodCreateWithoutIntermediateProductCookingMethodsInput, ProductCookingMethodUncheckedCreateWithoutIntermediateProductCookingMethodsInput>
  }

  export type ProductUpsertWithoutIntermediateProductCookingMethodsInput = {
    update: XOR<ProductUpdateWithoutIntermediateProductCookingMethodsInput, ProductUncheckedUpdateWithoutIntermediateProductCookingMethodsInput>
    create: XOR<ProductCreateWithoutIntermediateProductCookingMethodsInput, ProductUncheckedCreateWithoutIntermediateProductCookingMethodsInput>
  }

  export type ProductUpdateWithoutIntermediateProductCookingMethodsInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutIntermediateProductCookingMethodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCookingMethodUpsertWithoutIntermediateProductCookingMethodsInput = {
    update: XOR<ProductCookingMethodUpdateWithoutIntermediateProductCookingMethodsInput, ProductCookingMethodUncheckedUpdateWithoutIntermediateProductCookingMethodsInput>
    create: XOR<ProductCookingMethodCreateWithoutIntermediateProductCookingMethodsInput, ProductCookingMethodUncheckedCreateWithoutIntermediateProductCookingMethodsInput>
  }

  export type ProductCookingMethodUpdateWithoutIntermediateProductCookingMethodsInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodUncheckedUpdateWithoutIntermediateProductCookingMethodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutProductCookingMethodInput
  }

  export type CustomersCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput, CustomersUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
  }

  export type ProductCookingMethodCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodCreateOrConnectWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    where: ProductCookingMethodWhereUniqueInput
    create: XOR<ProductCookingMethodCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput, ProductCookingMethodUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
  }

  export type CustomersUpsertWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    update: XOR<CustomersUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput, CustomersUncheckedUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
    create: XOR<CustomersCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput, CustomersUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
  }

  export type CustomersUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type ProductCookingMethodUpsertWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    update: XOR<ProductCookingMethodUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput, ProductCookingMethodUncheckedUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
    create: XOR<ProductCookingMethodCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput, ProductCookingMethodUncheckedCreateWithoutIntermediateCustomerUnavailableCookingMethodsInput>
  }

  export type ProductCookingMethodUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductCookingMethodInput
  }

  export type ProductCookingMethodUncheckedUpdateWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductCookingMethodInput
  }

  export type IntermediateProductCookingMethodCreateWithoutProductCookingMethodInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntermediateProductCookingMethodsInput
  }

  export type IntermediateProductCookingMethodUncheckedCreateWithoutProductCookingMethodInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductCookingMethodCreateOrConnectWithoutProductCookingMethodInput = {
    where: IntermediateProductCookingMethodWhereUniqueInput
    create: XOR<IntermediateProductCookingMethodCreateWithoutProductCookingMethodInput, IntermediateProductCookingMethodUncheckedCreateWithoutProductCookingMethodInput>
  }

  export type IntermediateProductCookingMethodCreateManyProductCookingMethodInputEnvelope = {
    data: Enumerable<IntermediateProductCookingMethodCreateManyProductCookingMethodInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateWithoutProductCookingMethodInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerUnavailableCookingMethodsInput
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutProductCookingMethodInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateOrConnectWithoutProductCookingMethodInput = {
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    create: XOR<IntermediateCustomerUnavailableCookingMethodCreateWithoutProductCookingMethodInput, IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutProductCookingMethodInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateManyProductCookingMethodInputEnvelope = {
    data: Enumerable<IntermediateCustomerUnavailableCookingMethodCreateManyProductCookingMethodInput>
    skipDuplicates?: boolean
  }

  export type IntermediateProductCookingMethodUpsertWithWhereUniqueWithoutProductCookingMethodInput = {
    where: IntermediateProductCookingMethodWhereUniqueInput
    update: XOR<IntermediateProductCookingMethodUpdateWithoutProductCookingMethodInput, IntermediateProductCookingMethodUncheckedUpdateWithoutProductCookingMethodInput>
    create: XOR<IntermediateProductCookingMethodCreateWithoutProductCookingMethodInput, IntermediateProductCookingMethodUncheckedCreateWithoutProductCookingMethodInput>
  }

  export type IntermediateProductCookingMethodUpdateWithWhereUniqueWithoutProductCookingMethodInput = {
    where: IntermediateProductCookingMethodWhereUniqueInput
    data: XOR<IntermediateProductCookingMethodUpdateWithoutProductCookingMethodInput, IntermediateProductCookingMethodUncheckedUpdateWithoutProductCookingMethodInput>
  }

  export type IntermediateProductCookingMethodUpdateManyWithWhereWithoutProductCookingMethodInput = {
    where: IntermediateProductCookingMethodScalarWhereInput
    data: XOR<IntermediateProductCookingMethodUpdateManyMutationInput, IntermediateProductCookingMethodUncheckedUpdateManyWithoutIntermediateProductCookingMethodsInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUpsertWithWhereUniqueWithoutProductCookingMethodInput = {
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    update: XOR<IntermediateCustomerUnavailableCookingMethodUpdateWithoutProductCookingMethodInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateWithoutProductCookingMethodInput>
    create: XOR<IntermediateCustomerUnavailableCookingMethodCreateWithoutProductCookingMethodInput, IntermediateCustomerUnavailableCookingMethodUncheckedCreateWithoutProductCookingMethodInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateWithWhereUniqueWithoutProductCookingMethodInput = {
    where: IntermediateCustomerUnavailableCookingMethodWhereUniqueInput
    data: XOR<IntermediateCustomerUnavailableCookingMethodUpdateWithoutProductCookingMethodInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateWithoutProductCookingMethodInput>
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateManyWithWhereWithoutProductCookingMethodInput = {
    where: IntermediateCustomerUnavailableCookingMethodScalarWhereInput
    data: XOR<IntermediateCustomerUnavailableCookingMethodUpdateManyMutationInput, IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutIntermediateCustomerUnavailableCookingMethodsInput>
  }

  export type ProductCreateWithoutProductFlavorInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductFlavorInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductFlavorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductFlavorInput, ProductUncheckedCreateWithoutProductFlavorInput>
  }

  export type ProductCreateManyProductFlavorInputEnvelope = {
    data: Enumerable<ProductCreateManyProductFlavorInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerFlavorDislikeCreateWithoutProductFlavorInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerFlavorDislikesInput
  }

  export type IntermediateCustomerFlavorDislikeUncheckedCreateWithoutProductFlavorInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFlavorDislikeCreateOrConnectWithoutProductFlavorInput = {
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
    create: XOR<IntermediateCustomerFlavorDislikeCreateWithoutProductFlavorInput, IntermediateCustomerFlavorDislikeUncheckedCreateWithoutProductFlavorInput>
  }

  export type IntermediateCustomerFlavorDislikeCreateManyProductFlavorInputEnvelope = {
    data: Enumerable<IntermediateCustomerFlavorDislikeCreateManyProductFlavorInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductFlavorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductFlavorInput, ProductUncheckedUpdateWithoutProductFlavorInput>
    create: XOR<ProductCreateWithoutProductFlavorInput, ProductUncheckedCreateWithoutProductFlavorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductFlavorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductFlavorInput, ProductUncheckedUpdateWithoutProductFlavorInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductFlavorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: IntFilter | number
    activeStatus?: EnumActiveStatusNullableFilter | ActiveStatus | null
    name?: StringNullableFilter | string | null
    label?: StringNullableFilter | string | null
    ingredientLabel?: StringNullableFilter | string | null
    allergenLabel?: StringNullableFilter | string | null
    expertComment?: StringNullableFilter | string | null
    productProviderId?: IntFilter | number
    productCategoryId?: IntNullableFilter | number | null
    productFlavorId?: IntNullableFilter | number | null
    productVendorId?: IntNullableFilter | number | null
    externalSku?: StringFilter | string
    upcCode?: StringNullableFilter | string | null
    MSP?: FloatNullableFilter | number | null
    WSP?: FloatNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateCustomerFlavorDislikeUpsertWithWhereUniqueWithoutProductFlavorInput = {
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
    update: XOR<IntermediateCustomerFlavorDislikeUpdateWithoutProductFlavorInput, IntermediateCustomerFlavorDislikeUncheckedUpdateWithoutProductFlavorInput>
    create: XOR<IntermediateCustomerFlavorDislikeCreateWithoutProductFlavorInput, IntermediateCustomerFlavorDislikeUncheckedCreateWithoutProductFlavorInput>
  }

  export type IntermediateCustomerFlavorDislikeUpdateWithWhereUniqueWithoutProductFlavorInput = {
    where: IntermediateCustomerFlavorDislikeWhereUniqueInput
    data: XOR<IntermediateCustomerFlavorDislikeUpdateWithoutProductFlavorInput, IntermediateCustomerFlavorDislikeUncheckedUpdateWithoutProductFlavorInput>
  }

  export type IntermediateCustomerFlavorDislikeUpdateManyWithWhereWithoutProductFlavorInput = {
    where: IntermediateCustomerFlavorDislikeScalarWhereInput
    data: XOR<IntermediateCustomerFlavorDislikeUpdateManyMutationInput, IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutIntermediateCustomerFlavorDislikesInput>
  }

  export type ProductCreateWithoutProductVendorInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductVendorInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductVendorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductVendorInput, ProductUncheckedCreateWithoutProductVendorInput>
  }

  export type ProductCreateManyProductVendorInputEnvelope = {
    data: Enumerable<ProductCreateManyProductVendorInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductVendorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductVendorInput, ProductUncheckedUpdateWithoutProductVendorInput>
    create: XOR<ProductCreateWithoutProductVendorInput, ProductUncheckedCreateWithoutProductVendorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductVendorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductVendorInput, ProductUncheckedUpdateWithoutProductVendorInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductVendorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductFlavorCreateWithoutIntermediateCustomerFlavorDislikesInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutProductFlavorInput
  }

  export type ProductFlavorUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductFlavorInput
  }

  export type ProductFlavorCreateOrConnectWithoutIntermediateCustomerFlavorDislikesInput = {
    where: ProductFlavorWhereUniqueInput
    create: XOR<ProductFlavorCreateWithoutIntermediateCustomerFlavorDislikesInput, ProductFlavorUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput>
  }

  export type CustomersCreateWithoutIntermediateCustomerFlavorDislikesInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutIntermediateCustomerFlavorDislikesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutIntermediateCustomerFlavorDislikesInput, CustomersUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput>
  }

  export type ProductFlavorUpsertWithoutIntermediateCustomerFlavorDislikesInput = {
    update: XOR<ProductFlavorUpdateWithoutIntermediateCustomerFlavorDislikesInput, ProductFlavorUncheckedUpdateWithoutIntermediateCustomerFlavorDislikesInput>
    create: XOR<ProductFlavorCreateWithoutIntermediateCustomerFlavorDislikesInput, ProductFlavorUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput>
  }

  export type ProductFlavorUpdateWithoutIntermediateCustomerFlavorDislikesInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutProductFlavorInput
  }

  export type ProductFlavorUncheckedUpdateWithoutIntermediateCustomerFlavorDislikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductFlavorInput
  }

  export type CustomersUpsertWithoutIntermediateCustomerFlavorDislikesInput = {
    update: XOR<CustomersUpdateWithoutIntermediateCustomerFlavorDislikesInput, CustomersUncheckedUpdateWithoutIntermediateCustomerFlavorDislikesInput>
    create: XOR<CustomersCreateWithoutIntermediateCustomerFlavorDislikesInput, CustomersUncheckedCreateWithoutIntermediateCustomerFlavorDislikesInput>
  }

  export type CustomersUpdateWithoutIntermediateCustomerFlavorDislikesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutIntermediateCustomerFlavorDislikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type ProductCreateWithoutProductCategoryInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductCategoryInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductCreateManyProductCategoryInputEnvelope = {
    data: Enumerable<ProductCreateManyProductCategoryInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerCategoryPreferenceCreateWithoutProductCategoryInput = {
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerCategoryPreferencesInput
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutProductCategoryInput = {
    customerId: number
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerCategoryPreferenceCreateOrConnectWithoutProductCategoryInput = {
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    create: XOR<IntermediateCustomerCategoryPreferenceCreateWithoutProductCategoryInput, IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutProductCategoryInput>
  }

  export type IntermediateCustomerCategoryPreferenceCreateManyProductCategoryInputEnvelope = {
    data: Enumerable<IntermediateCustomerCategoryPreferenceCreateManyProductCategoryInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type IntermediateCustomerCategoryPreferenceUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    update: XOR<IntermediateCustomerCategoryPreferenceUpdateWithoutProductCategoryInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<IntermediateCustomerCategoryPreferenceCreateWithoutProductCategoryInput, IntermediateCustomerCategoryPreferenceUncheckedCreateWithoutProductCategoryInput>
  }

  export type IntermediateCustomerCategoryPreferenceUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: IntermediateCustomerCategoryPreferenceWhereUniqueInput
    data: XOR<IntermediateCustomerCategoryPreferenceUpdateWithoutProductCategoryInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateWithoutProductCategoryInput>
  }

  export type IntermediateCustomerCategoryPreferenceUpdateManyWithWhereWithoutProductCategoryInput = {
    where: IntermediateCustomerCategoryPreferenceScalarWhereInput
    data: XOR<IntermediateCustomerCategoryPreferenceUpdateManyMutationInput, IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutIntermediateCustomerCategoryPreferencesInput>
  }

  export type ProductCategoryCreateWithoutIntermediateCustomerCategoryPreferencesInput = {
    label: string
    name: string
    src?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput = {
    id?: number
    label: string
    name: string
    src?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutIntermediateCustomerCategoryPreferencesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutIntermediateCustomerCategoryPreferencesInput, ProductCategoryUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput>
  }

  export type CustomersCreateWithoutIntermediateCustomerCategoryPreferencesInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutIntermediateCustomerCategoryPreferencesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutIntermediateCustomerCategoryPreferencesInput, CustomersUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput>
  }

  export type ProductCategoryUpsertWithoutIntermediateCustomerCategoryPreferencesInput = {
    update: XOR<ProductCategoryUpdateWithoutIntermediateCustomerCategoryPreferencesInput, ProductCategoryUncheckedUpdateWithoutIntermediateCustomerCategoryPreferencesInput>
    create: XOR<ProductCategoryCreateWithoutIntermediateCustomerCategoryPreferencesInput, ProductCategoryUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput>
  }

  export type ProductCategoryUpdateWithoutIntermediateCustomerCategoryPreferencesInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedUpdateWithoutIntermediateCustomerCategoryPreferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    src?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutProductCategoryInput
  }

  export type CustomersUpsertWithoutIntermediateCustomerCategoryPreferencesInput = {
    update: XOR<CustomersUpdateWithoutIntermediateCustomerCategoryPreferencesInput, CustomersUncheckedUpdateWithoutIntermediateCustomerCategoryPreferencesInput>
    create: XOR<CustomersCreateWithoutIntermediateCustomerCategoryPreferencesInput, CustomersUncheckedCreateWithoutIntermediateCustomerCategoryPreferencesInput>
  }

  export type CustomersUpdateWithoutIntermediateCustomerCategoryPreferencesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutIntermediateCustomerCategoryPreferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type ProductCreateWithoutIntermediateProductIngredientsInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutIntermediateProductIngredientsInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutIntermediateProductIngredientsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutIntermediateProductIngredientsInput, ProductUncheckedCreateWithoutIntermediateProductIngredientsInput>
  }

  export type ProductIngredientCreateWithoutIntermediateProductIngredientsInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutProductIngredientInput
  }

  export type ProductIngredientUncheckedCreateWithoutIntermediateProductIngredientsInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutProductIngredientInput
  }

  export type ProductIngredientCreateOrConnectWithoutIntermediateProductIngredientsInput = {
    where: ProductIngredientWhereUniqueInput
    create: XOR<ProductIngredientCreateWithoutIntermediateProductIngredientsInput, ProductIngredientUncheckedCreateWithoutIntermediateProductIngredientsInput>
  }

  export type ProductUpsertWithoutIntermediateProductIngredientsInput = {
    update: XOR<ProductUpdateWithoutIntermediateProductIngredientsInput, ProductUncheckedUpdateWithoutIntermediateProductIngredientsInput>
    create: XOR<ProductCreateWithoutIntermediateProductIngredientsInput, ProductUncheckedCreateWithoutIntermediateProductIngredientsInput>
  }

  export type ProductUpdateWithoutIntermediateProductIngredientsInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutIntermediateProductIngredientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type ProductIngredientUpsertWithoutIntermediateProductIngredientsInput = {
    update: XOR<ProductIngredientUpdateWithoutIntermediateProductIngredientsInput, ProductIngredientUncheckedUpdateWithoutIntermediateProductIngredientsInput>
    create: XOR<ProductIngredientCreateWithoutIntermediateProductIngredientsInput, ProductIngredientUncheckedCreateWithoutIntermediateProductIngredientsInput>
  }

  export type ProductIngredientUpdateWithoutIntermediateProductIngredientsInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutProductIngredientInput
  }

  export type ProductIngredientUncheckedUpdateWithoutIntermediateProductIngredientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutProductIngredientInput
  }

  export type IntermediateProductIngredientCreateWithoutProductIngredientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntermediateProductIngredientsInput
  }

  export type IntermediateProductIngredientUncheckedCreateWithoutProductIngredientInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductIngredientCreateOrConnectWithoutProductIngredientInput = {
    where: IntermediateProductIngredientWhereUniqueInput
    create: XOR<IntermediateProductIngredientCreateWithoutProductIngredientInput, IntermediateProductIngredientUncheckedCreateWithoutProductIngredientInput>
  }

  export type IntermediateProductIngredientCreateManyProductIngredientInputEnvelope = {
    data: Enumerable<IntermediateProductIngredientCreateManyProductIngredientInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerIngredientDislikeCreateWithoutProductIngredientInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerIngredientDislikesInput
  }

  export type IntermediateCustomerIngredientDislikeUncheckedCreateWithoutProductIngredientInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerIngredientDislikeCreateOrConnectWithoutProductIngredientInput = {
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
    create: XOR<IntermediateCustomerIngredientDislikeCreateWithoutProductIngredientInput, IntermediateCustomerIngredientDislikeUncheckedCreateWithoutProductIngredientInput>
  }

  export type IntermediateCustomerIngredientDislikeCreateManyProductIngredientInputEnvelope = {
    data: Enumerable<IntermediateCustomerIngredientDislikeCreateManyProductIngredientInput>
    skipDuplicates?: boolean
  }

  export type IntermediateProductIngredientUpsertWithWhereUniqueWithoutProductIngredientInput = {
    where: IntermediateProductIngredientWhereUniqueInput
    update: XOR<IntermediateProductIngredientUpdateWithoutProductIngredientInput, IntermediateProductIngredientUncheckedUpdateWithoutProductIngredientInput>
    create: XOR<IntermediateProductIngredientCreateWithoutProductIngredientInput, IntermediateProductIngredientUncheckedCreateWithoutProductIngredientInput>
  }

  export type IntermediateProductIngredientUpdateWithWhereUniqueWithoutProductIngredientInput = {
    where: IntermediateProductIngredientWhereUniqueInput
    data: XOR<IntermediateProductIngredientUpdateWithoutProductIngredientInput, IntermediateProductIngredientUncheckedUpdateWithoutProductIngredientInput>
  }

  export type IntermediateProductIngredientUpdateManyWithWhereWithoutProductIngredientInput = {
    where: IntermediateProductIngredientScalarWhereInput
    data: XOR<IntermediateProductIngredientUpdateManyMutationInput, IntermediateProductIngredientUncheckedUpdateManyWithoutIntermediateProductIngredientsInput>
  }

  export type IntermediateCustomerIngredientDislikeUpsertWithWhereUniqueWithoutProductIngredientInput = {
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
    update: XOR<IntermediateCustomerIngredientDislikeUpdateWithoutProductIngredientInput, IntermediateCustomerIngredientDislikeUncheckedUpdateWithoutProductIngredientInput>
    create: XOR<IntermediateCustomerIngredientDislikeCreateWithoutProductIngredientInput, IntermediateCustomerIngredientDislikeUncheckedCreateWithoutProductIngredientInput>
  }

  export type IntermediateCustomerIngredientDislikeUpdateWithWhereUniqueWithoutProductIngredientInput = {
    where: IntermediateCustomerIngredientDislikeWhereUniqueInput
    data: XOR<IntermediateCustomerIngredientDislikeUpdateWithoutProductIngredientInput, IntermediateCustomerIngredientDislikeUncheckedUpdateWithoutProductIngredientInput>
  }

  export type IntermediateCustomerIngredientDislikeUpdateManyWithWhereWithoutProductIngredientInput = {
    where: IntermediateCustomerIngredientDislikeScalarWhereInput
    data: XOR<IntermediateCustomerIngredientDislikeUpdateManyMutationInput, IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutIntermediateCustomerIngredientDislikesInput>
  }

  export type ProductIngredientCreateWithoutIntermediateCustomerIngredientDislikesInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductIngredientInput
  }

  export type ProductIngredientUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductIngredientInput
  }

  export type ProductIngredientCreateOrConnectWithoutIntermediateCustomerIngredientDislikesInput = {
    where: ProductIngredientWhereUniqueInput
    create: XOR<ProductIngredientCreateWithoutIntermediateCustomerIngredientDislikesInput, ProductIngredientUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput>
  }

  export type CustomersCreateWithoutIntermediateCustomerIngredientDislikesInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutIntermediateCustomerIngredientDislikesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutIntermediateCustomerIngredientDislikesInput, CustomersUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput>
  }

  export type ProductIngredientUpsertWithoutIntermediateCustomerIngredientDislikesInput = {
    update: XOR<ProductIngredientUpdateWithoutIntermediateCustomerIngredientDislikesInput, ProductIngredientUncheckedUpdateWithoutIntermediateCustomerIngredientDislikesInput>
    create: XOR<ProductIngredientCreateWithoutIntermediateCustomerIngredientDislikesInput, ProductIngredientUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput>
  }

  export type ProductIngredientUpdateWithoutIntermediateCustomerIngredientDislikesInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductIngredientInput
  }

  export type ProductIngredientUncheckedUpdateWithoutIntermediateCustomerIngredientDislikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductIngredientInput
  }

  export type CustomersUpsertWithoutIntermediateCustomerIngredientDislikesInput = {
    update: XOR<CustomersUpdateWithoutIntermediateCustomerIngredientDislikesInput, CustomersUncheckedUpdateWithoutIntermediateCustomerIngredientDislikesInput>
    create: XOR<CustomersCreateWithoutIntermediateCustomerIngredientDislikesInput, CustomersUncheckedCreateWithoutIntermediateCustomerIngredientDislikesInput>
  }

  export type CustomersUpdateWithoutIntermediateCustomerIngredientDislikesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutIntermediateCustomerIngredientDislikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type ProductCreateWithoutIntermediateProductAllergensInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutIntermediateProductAllergensInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutIntermediateProductAllergensInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutIntermediateProductAllergensInput, ProductUncheckedCreateWithoutIntermediateProductAllergensInput>
  }

  export type ProductAllergenCreateWithoutIntermediateProductAllergensInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutProductAllergenInput
  }

  export type ProductAllergenUncheckedCreateWithoutIntermediateProductAllergensInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutProductAllergenInput
  }

  export type ProductAllergenCreateOrConnectWithoutIntermediateProductAllergensInput = {
    where: ProductAllergenWhereUniqueInput
    create: XOR<ProductAllergenCreateWithoutIntermediateProductAllergensInput, ProductAllergenUncheckedCreateWithoutIntermediateProductAllergensInput>
  }

  export type ProductUpsertWithoutIntermediateProductAllergensInput = {
    update: XOR<ProductUpdateWithoutIntermediateProductAllergensInput, ProductUncheckedUpdateWithoutIntermediateProductAllergensInput>
    create: XOR<ProductCreateWithoutIntermediateProductAllergensInput, ProductUncheckedCreateWithoutIntermediateProductAllergensInput>
  }

  export type ProductUpdateWithoutIntermediateProductAllergensInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutIntermediateProductAllergensInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type ProductAllergenUpsertWithoutIntermediateProductAllergensInput = {
    update: XOR<ProductAllergenUpdateWithoutIntermediateProductAllergensInput, ProductAllergenUncheckedUpdateWithoutIntermediateProductAllergensInput>
    create: XOR<ProductAllergenCreateWithoutIntermediateProductAllergensInput, ProductAllergenUncheckedCreateWithoutIntermediateProductAllergensInput>
  }

  export type ProductAllergenUpdateWithoutIntermediateProductAllergensInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutProductAllergenInput
  }

  export type ProductAllergenUncheckedUpdateWithoutIntermediateProductAllergensInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutProductAllergenInput
  }

  export type IntermediateProductAllergenCreateWithoutProductAllergenInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntermediateProductAllergensInput
  }

  export type IntermediateProductAllergenUncheckedCreateWithoutProductAllergenInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductAllergenCreateOrConnectWithoutProductAllergenInput = {
    where: IntermediateProductAllergenWhereUniqueInput
    create: XOR<IntermediateProductAllergenCreateWithoutProductAllergenInput, IntermediateProductAllergenUncheckedCreateWithoutProductAllergenInput>
  }

  export type IntermediateProductAllergenCreateManyProductAllergenInputEnvelope = {
    data: Enumerable<IntermediateProductAllergenCreateManyProductAllergenInput>
    skipDuplicates?: boolean
  }

  export type IntermediateCustomerAllergenCreateWithoutProductAllergenInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutIntermediateCustomerAllergensInput
  }

  export type IntermediateCustomerAllergenUncheckedCreateWithoutProductAllergenInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerAllergenCreateOrConnectWithoutProductAllergenInput = {
    where: IntermediateCustomerAllergenWhereUniqueInput
    create: XOR<IntermediateCustomerAllergenCreateWithoutProductAllergenInput, IntermediateCustomerAllergenUncheckedCreateWithoutProductAllergenInput>
  }

  export type IntermediateCustomerAllergenCreateManyProductAllergenInputEnvelope = {
    data: Enumerable<IntermediateCustomerAllergenCreateManyProductAllergenInput>
    skipDuplicates?: boolean
  }

  export type IntermediateProductAllergenUpsertWithWhereUniqueWithoutProductAllergenInput = {
    where: IntermediateProductAllergenWhereUniqueInput
    update: XOR<IntermediateProductAllergenUpdateWithoutProductAllergenInput, IntermediateProductAllergenUncheckedUpdateWithoutProductAllergenInput>
    create: XOR<IntermediateProductAllergenCreateWithoutProductAllergenInput, IntermediateProductAllergenUncheckedCreateWithoutProductAllergenInput>
  }

  export type IntermediateProductAllergenUpdateWithWhereUniqueWithoutProductAllergenInput = {
    where: IntermediateProductAllergenWhereUniqueInput
    data: XOR<IntermediateProductAllergenUpdateWithoutProductAllergenInput, IntermediateProductAllergenUncheckedUpdateWithoutProductAllergenInput>
  }

  export type IntermediateProductAllergenUpdateManyWithWhereWithoutProductAllergenInput = {
    where: IntermediateProductAllergenScalarWhereInput
    data: XOR<IntermediateProductAllergenUpdateManyMutationInput, IntermediateProductAllergenUncheckedUpdateManyWithoutIntermediateProductAllergensInput>
  }

  export type IntermediateCustomerAllergenUpsertWithWhereUniqueWithoutProductAllergenInput = {
    where: IntermediateCustomerAllergenWhereUniqueInput
    update: XOR<IntermediateCustomerAllergenUpdateWithoutProductAllergenInput, IntermediateCustomerAllergenUncheckedUpdateWithoutProductAllergenInput>
    create: XOR<IntermediateCustomerAllergenCreateWithoutProductAllergenInput, IntermediateCustomerAllergenUncheckedCreateWithoutProductAllergenInput>
  }

  export type IntermediateCustomerAllergenUpdateWithWhereUniqueWithoutProductAllergenInput = {
    where: IntermediateCustomerAllergenWhereUniqueInput
    data: XOR<IntermediateCustomerAllergenUpdateWithoutProductAllergenInput, IntermediateCustomerAllergenUncheckedUpdateWithoutProductAllergenInput>
  }

  export type IntermediateCustomerAllergenUpdateManyWithWhereWithoutProductAllergenInput = {
    where: IntermediateCustomerAllergenScalarWhereInput
    data: XOR<IntermediateCustomerAllergenUpdateManyMutationInput, IntermediateCustomerAllergenUncheckedUpdateManyWithoutIntermediateCustomerAllergensInput>
  }

  export type CustomersCreateWithoutIntermediateCustomerAllergensInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutIntermediateCustomerAllergensInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutIntermediateCustomerAllergensInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutIntermediateCustomerAllergensInput, CustomersUncheckedCreateWithoutIntermediateCustomerAllergensInput>
  }

  export type ProductAllergenCreateWithoutIntermediateCustomerAllergensInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductAllergenInput
  }

  export type ProductAllergenUncheckedCreateWithoutIntermediateCustomerAllergensInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductAllergenInput
  }

  export type ProductAllergenCreateOrConnectWithoutIntermediateCustomerAllergensInput = {
    where: ProductAllergenWhereUniqueInput
    create: XOR<ProductAllergenCreateWithoutIntermediateCustomerAllergensInput, ProductAllergenUncheckedCreateWithoutIntermediateCustomerAllergensInput>
  }

  export type CustomersUpsertWithoutIntermediateCustomerAllergensInput = {
    update: XOR<CustomersUpdateWithoutIntermediateCustomerAllergensInput, CustomersUncheckedUpdateWithoutIntermediateCustomerAllergensInput>
    create: XOR<CustomersCreateWithoutIntermediateCustomerAllergensInput, CustomersUncheckedCreateWithoutIntermediateCustomerAllergensInput>
  }

  export type CustomersUpdateWithoutIntermediateCustomerAllergensInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutIntermediateCustomerAllergensInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type ProductAllergenUpsertWithoutIntermediateCustomerAllergensInput = {
    update: XOR<ProductAllergenUpdateWithoutIntermediateCustomerAllergensInput, ProductAllergenUncheckedUpdateWithoutIntermediateCustomerAllergensInput>
    create: XOR<ProductAllergenCreateWithoutIntermediateCustomerAllergensInput, ProductAllergenUncheckedCreateWithoutIntermediateCustomerAllergensInput>
  }

  export type ProductAllergenUpdateWithoutIntermediateCustomerAllergensInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductAllergenInput
  }

  export type ProductAllergenUncheckedUpdateWithoutIntermediateCustomerAllergensInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductAllergenInput
  }

  export type ProductCreateWithoutProductNutritionFactInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductNutritionFactInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductNutritionFactInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductNutritionFactInput, ProductUncheckedCreateWithoutProductNutritionFactInput>
  }

  export type ProductUpsertWithoutProductNutritionFactInput = {
    update: XOR<ProductUpdateWithoutProductNutritionFactInput, ProductUncheckedUpdateWithoutProductNutritionFactInput>
    create: XOR<ProductCreateWithoutProductNutritionFactInput, ProductUncheckedCreateWithoutProductNutritionFactInput>
  }

  export type ProductUpdateWithoutProductNutritionFactInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProductNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateWithoutProductProviderInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductProviderInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductProviderInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductProviderInput, ProductUncheckedCreateWithoutProductProviderInput>
  }

  export type ProductCreateManyProductProviderInputEnvelope = {
    data: Enumerable<ProductCreateManyProductProviderInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductProviderInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductProviderInput, ProductUncheckedUpdateWithoutProductProviderInput>
    create: XOR<ProductCreateWithoutProductProviderInput, ProductUncheckedCreateWithoutProductProviderInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductProviderInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductProviderInput, ProductUncheckedUpdateWithoutProductProviderInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductProviderInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type IntermediateSurveyQuestionCreateWithoutSurveyInput = {
    displayOrder?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutIntermediateSurveyQuestionsInput
  }

  export type IntermediateSurveyQuestionUncheckedCreateWithoutSurveyInput = {
    displayOrder?: number | null
    surveyQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionCreateOrConnectWithoutSurveyInput = {
    where: IntermediateSurveyQuestionWhereUniqueInput
    create: XOR<IntermediateSurveyQuestionCreateWithoutSurveyInput, IntermediateSurveyQuestionUncheckedCreateWithoutSurveyInput>
  }

  export type IntermediateSurveyQuestionCreateManySurveyInputEnvelope = {
    data: Enumerable<IntermediateSurveyQuestionCreateManySurveyInput>
    skipDuplicates?: boolean
  }

  export type IntermediateSurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput = {
    where: IntermediateSurveyQuestionWhereUniqueInput
    update: XOR<IntermediateSurveyQuestionUpdateWithoutSurveyInput, IntermediateSurveyQuestionUncheckedUpdateWithoutSurveyInput>
    create: XOR<IntermediateSurveyQuestionCreateWithoutSurveyInput, IntermediateSurveyQuestionUncheckedCreateWithoutSurveyInput>
  }

  export type IntermediateSurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput = {
    where: IntermediateSurveyQuestionWhereUniqueInput
    data: XOR<IntermediateSurveyQuestionUpdateWithoutSurveyInput, IntermediateSurveyQuestionUncheckedUpdateWithoutSurveyInput>
  }

  export type IntermediateSurveyQuestionUpdateManyWithWhereWithoutSurveyInput = {
    where: IntermediateSurveyQuestionScalarWhereInput
    data: XOR<IntermediateSurveyQuestionUpdateManyMutationInput, IntermediateSurveyQuestionUncheckedUpdateManyWithoutIntermediateSurveyQuestionsInput>
  }

  export type IntermediateSurveyQuestionScalarWhereInput = {
    AND?: Enumerable<IntermediateSurveyQuestionScalarWhereInput>
    OR?: Enumerable<IntermediateSurveyQuestionScalarWhereInput>
    NOT?: Enumerable<IntermediateSurveyQuestionScalarWhereInput>
    surveyId?: IntFilter | number
    displayOrder?: IntNullableFilter | number | null
    surveyQuestionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyCreateWithoutIntermediateSurveyQuestionsInput = {
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyUncheckedCreateWithoutIntermediateSurveyQuestionsInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyCreateOrConnectWithoutIntermediateSurveyQuestionsInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutIntermediateSurveyQuestionsInput, SurveyUncheckedCreateWithoutIntermediateSurveyQuestionsInput>
  }

  export type SurveyQuestionCreateWithoutIntermediateSurveyQuestionsInput = {
    name: string
    label: string
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionCategory: QuestionCategoryCreateNestedOneWithoutSurveyQuestionsInput
    surveyQuestionAnswerType: SurveyQuestionAnswerTypeCreateNestedOneWithoutSurveyQuestionsInput
    surveyQuestionOptions?: SurveyQuestionOptionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutIntermediateSurveyQuestionsInput = {
    id?: number
    name: string
    label: string
    questionCategoryId: number
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    surveyQuestionAnswerTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutIntermediateSurveyQuestionsInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutIntermediateSurveyQuestionsInput, SurveyQuestionUncheckedCreateWithoutIntermediateSurveyQuestionsInput>
  }

  export type SurveyUpsertWithoutIntermediateSurveyQuestionsInput = {
    update: XOR<SurveyUpdateWithoutIntermediateSurveyQuestionsInput, SurveyUncheckedUpdateWithoutIntermediateSurveyQuestionsInput>
    create: XOR<SurveyCreateWithoutIntermediateSurveyQuestionsInput, SurveyUncheckedCreateWithoutIntermediateSurveyQuestionsInput>
  }

  export type SurveyUpdateWithoutIntermediateSurveyQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUncheckedUpdateWithoutIntermediateSurveyQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionUpsertWithoutIntermediateSurveyQuestionsInput = {
    update: XOR<SurveyQuestionUpdateWithoutIntermediateSurveyQuestionsInput, SurveyQuestionUncheckedUpdateWithoutIntermediateSurveyQuestionsInput>
    create: XOR<SurveyQuestionCreateWithoutIntermediateSurveyQuestionsInput, SurveyQuestionUncheckedCreateWithoutIntermediateSurveyQuestionsInput>
  }

  export type SurveyQuestionUpdateWithoutIntermediateSurveyQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionCategory?: QuestionCategoryUpdateOneRequiredWithoutSurveyQuestionsInput
    surveyQuestionAnswerType?: SurveyQuestionAnswerTypeUpdateOneRequiredWithoutSurveyQuestionsInput
    surveyQuestionOptions?: SurveyQuestionOptionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutIntermediateSurveyQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    questionCategoryId?: IntFieldUpdateOperationsInput | number
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionAnswerTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionInput
  }

  export type QuestionCategoryCreateWithoutSurveyQuestionsInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCategoryUncheckedCreateWithoutSurveyQuestionsInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCategoryCreateOrConnectWithoutSurveyQuestionsInput = {
    where: QuestionCategoryWhereUniqueInput
    create: XOR<QuestionCategoryCreateWithoutSurveyQuestionsInput, QuestionCategoryUncheckedCreateWithoutSurveyQuestionsInput>
  }

  export type SurveyQuestionAnswerTypeCreateWithoutSurveyQuestionsInput = {
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerTypeUncheckedCreateWithoutSurveyQuestionsInput = {
    id?: number
    name: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerTypeCreateOrConnectWithoutSurveyQuestionsInput = {
    where: SurveyQuestionAnswerTypeWhereUniqueInput
    create: XOR<SurveyQuestionAnswerTypeCreateWithoutSurveyQuestionsInput, SurveyQuestionAnswerTypeUncheckedCreateWithoutSurveyQuestionsInput>
  }

  export type IntermediateSurveyQuestionCreateWithoutSurveyQuestionInput = {
    displayOrder?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    survey: SurveyCreateNestedOneWithoutIntermediateSurveyQuestionsInput
  }

  export type IntermediateSurveyQuestionUncheckedCreateWithoutSurveyQuestionInput = {
    surveyId: number
    displayOrder?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionCreateOrConnectWithoutSurveyQuestionInput = {
    where: IntermediateSurveyQuestionWhereUniqueInput
    create: XOR<IntermediateSurveyQuestionCreateWithoutSurveyQuestionInput, IntermediateSurveyQuestionUncheckedCreateWithoutSurveyQuestionInput>
  }

  export type IntermediateSurveyQuestionCreateManySurveyQuestionInputEnvelope = {
    data: Enumerable<IntermediateSurveyQuestionCreateManySurveyQuestionInput>
    skipDuplicates?: boolean
  }

  export type SurveyQuestionOptionCreateWithoutSurveyQuestionInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutAnswerOptionInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutAnswerOptionInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionCreateOrConnectWithoutSurveyQuestionInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    create: XOR<SurveyQuestionOptionCreateWithoutSurveyQuestionInput, SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionInput>
  }

  export type SurveyQuestionOptionCreateManySurveyQuestionInputEnvelope = {
    data: Enumerable<SurveyQuestionOptionCreateManySurveyQuestionInput>
    skipDuplicates?: boolean
  }

  export type SurveyQuestionAnswerCreateWithoutSurveyQuestionInput = {
    responseId?: string | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionAnswerInput
    customer: CustomersCreateNestedOneWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionCreateNestedOneWithoutSurveyQuestionAnswerInput
    product?: ProductCreateNestedOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedCreateWithoutSurveyQuestionInput = {
    id?: number
    responseId?: string | null
    customerId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerCreateOrConnectWithoutSurveyQuestionInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    create: XOR<SurveyQuestionAnswerCreateWithoutSurveyQuestionInput, SurveyQuestionAnswerUncheckedCreateWithoutSurveyQuestionInput>
  }

  export type SurveyQuestionAnswerCreateManySurveyQuestionInputEnvelope = {
    data: Enumerable<SurveyQuestionAnswerCreateManySurveyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuestionCategoryUpsertWithoutSurveyQuestionsInput = {
    update: XOR<QuestionCategoryUpdateWithoutSurveyQuestionsInput, QuestionCategoryUncheckedUpdateWithoutSurveyQuestionsInput>
    create: XOR<QuestionCategoryCreateWithoutSurveyQuestionsInput, QuestionCategoryUncheckedCreateWithoutSurveyQuestionsInput>
  }

  export type QuestionCategoryUpdateWithoutSurveyQuestionsInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCategoryUncheckedUpdateWithoutSurveyQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerTypeUpsertWithoutSurveyQuestionsInput = {
    update: XOR<SurveyQuestionAnswerTypeUpdateWithoutSurveyQuestionsInput, SurveyQuestionAnswerTypeUncheckedUpdateWithoutSurveyQuestionsInput>
    create: XOR<SurveyQuestionAnswerTypeCreateWithoutSurveyQuestionsInput, SurveyQuestionAnswerTypeUncheckedCreateWithoutSurveyQuestionsInput>
  }

  export type SurveyQuestionAnswerTypeUpdateWithoutSurveyQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerTypeUncheckedUpdateWithoutSurveyQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionUpsertWithWhereUniqueWithoutSurveyQuestionInput = {
    where: IntermediateSurveyQuestionWhereUniqueInput
    update: XOR<IntermediateSurveyQuestionUpdateWithoutSurveyQuestionInput, IntermediateSurveyQuestionUncheckedUpdateWithoutSurveyQuestionInput>
    create: XOR<IntermediateSurveyQuestionCreateWithoutSurveyQuestionInput, IntermediateSurveyQuestionUncheckedCreateWithoutSurveyQuestionInput>
  }

  export type IntermediateSurveyQuestionUpdateWithWhereUniqueWithoutSurveyQuestionInput = {
    where: IntermediateSurveyQuestionWhereUniqueInput
    data: XOR<IntermediateSurveyQuestionUpdateWithoutSurveyQuestionInput, IntermediateSurveyQuestionUncheckedUpdateWithoutSurveyQuestionInput>
  }

  export type IntermediateSurveyQuestionUpdateManyWithWhereWithoutSurveyQuestionInput = {
    where: IntermediateSurveyQuestionScalarWhereInput
    data: XOR<IntermediateSurveyQuestionUpdateManyMutationInput, IntermediateSurveyQuestionUncheckedUpdateManyWithoutIntermediateSurveyQuestionsInput>
  }

  export type SurveyQuestionOptionUpsertWithWhereUniqueWithoutSurveyQuestionInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    update: XOR<SurveyQuestionOptionUpdateWithoutSurveyQuestionInput, SurveyQuestionOptionUncheckedUpdateWithoutSurveyQuestionInput>
    create: XOR<SurveyQuestionOptionCreateWithoutSurveyQuestionInput, SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionInput>
  }

  export type SurveyQuestionOptionUpdateWithWhereUniqueWithoutSurveyQuestionInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    data: XOR<SurveyQuestionOptionUpdateWithoutSurveyQuestionInput, SurveyQuestionOptionUncheckedUpdateWithoutSurveyQuestionInput>
  }

  export type SurveyQuestionOptionUpdateManyWithWhereWithoutSurveyQuestionInput = {
    where: SurveyQuestionOptionScalarWhereInput
    data: XOR<SurveyQuestionOptionUpdateManyMutationInput, SurveyQuestionOptionUncheckedUpdateManyWithoutSurveyQuestionOptionsInput>
  }

  export type SurveyQuestionOptionScalarWhereInput = {
    AND?: Enumerable<SurveyQuestionOptionScalarWhereInput>
    OR?: Enumerable<SurveyQuestionOptionScalarWhereInput>
    NOT?: Enumerable<SurveyQuestionOptionScalarWhereInput>
    id?: IntFilter | number
    label?: StringFilter | string
    name?: StringFilter | string
    surveyQuestionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyQuestionAnswerUpsertWithWhereUniqueWithoutSurveyQuestionInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    update: XOR<SurveyQuestionAnswerUpdateWithoutSurveyQuestionInput, SurveyQuestionAnswerUncheckedUpdateWithoutSurveyQuestionInput>
    create: XOR<SurveyQuestionAnswerCreateWithoutSurveyQuestionInput, SurveyQuestionAnswerUncheckedCreateWithoutSurveyQuestionInput>
  }

  export type SurveyQuestionAnswerUpdateWithWhereUniqueWithoutSurveyQuestionInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    data: XOR<SurveyQuestionAnswerUpdateWithoutSurveyQuestionInput, SurveyQuestionAnswerUncheckedUpdateWithoutSurveyQuestionInput>
  }

  export type SurveyQuestionAnswerUpdateManyWithWhereWithoutSurveyQuestionInput = {
    where: SurveyQuestionAnswerScalarWhereInput
    data: XOR<SurveyQuestionAnswerUpdateManyMutationInput, SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionAnswerInput>
  }

  export type SurveyQuestionCreateWithoutQuestionCategoryInput = {
    name: string
    label: string
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionAnswerType: SurveyQuestionAnswerTypeCreateNestedOneWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutQuestionCategoryInput = {
    id?: number
    name: string
    label: string
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    surveyQuestionAnswerTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutQuestionCategoryInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutQuestionCategoryInput, SurveyQuestionUncheckedCreateWithoutQuestionCategoryInput>
  }

  export type SurveyQuestionCreateManyQuestionCategoryInputEnvelope = {
    data: Enumerable<SurveyQuestionCreateManyQuestionCategoryInput>
    skipDuplicates?: boolean
  }

  export type SurveyQuestionUpsertWithWhereUniqueWithoutQuestionCategoryInput = {
    where: SurveyQuestionWhereUniqueInput
    update: XOR<SurveyQuestionUpdateWithoutQuestionCategoryInput, SurveyQuestionUncheckedUpdateWithoutQuestionCategoryInput>
    create: XOR<SurveyQuestionCreateWithoutQuestionCategoryInput, SurveyQuestionUncheckedCreateWithoutQuestionCategoryInput>
  }

  export type SurveyQuestionUpdateWithWhereUniqueWithoutQuestionCategoryInput = {
    where: SurveyQuestionWhereUniqueInput
    data: XOR<SurveyQuestionUpdateWithoutQuestionCategoryInput, SurveyQuestionUncheckedUpdateWithoutQuestionCategoryInput>
  }

  export type SurveyQuestionUpdateManyWithWhereWithoutQuestionCategoryInput = {
    where: SurveyQuestionScalarWhereInput
    data: XOR<SurveyQuestionUpdateManyMutationInput, SurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionsInput>
  }

  export type SurveyQuestionScalarWhereInput = {
    AND?: Enumerable<SurveyQuestionScalarWhereInput>
    OR?: Enumerable<SurveyQuestionScalarWhereInput>
    NOT?: Enumerable<SurveyQuestionScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    label?: StringFilter | string
    questionCategoryId?: IntFilter | number
    mustBeAnswered?: BoolFilter | boolean
    instruction?: StringNullableFilter | string | null
    placeholder?: StringNullableFilter | string | null
    surveyQuestionAnswerTypeId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SurveyQuestionCreateWithoutSurveyQuestionAnswerTypeInput = {
    name: string
    label: string
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionCategory: QuestionCategoryCreateNestedOneWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerTypeInput = {
    id?: number
    name: string
    label: string
    questionCategoryId: number
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutSurveyQuestionAnswerTypeInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutSurveyQuestionAnswerTypeInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerTypeInput>
  }

  export type SurveyQuestionCreateManySurveyQuestionAnswerTypeInputEnvelope = {
    data: Enumerable<SurveyQuestionCreateManySurveyQuestionAnswerTypeInput>
    skipDuplicates?: boolean
  }

  export type SurveyQuestionUpsertWithWhereUniqueWithoutSurveyQuestionAnswerTypeInput = {
    where: SurveyQuestionWhereUniqueInput
    update: XOR<SurveyQuestionUpdateWithoutSurveyQuestionAnswerTypeInput, SurveyQuestionUncheckedUpdateWithoutSurveyQuestionAnswerTypeInput>
    create: XOR<SurveyQuestionCreateWithoutSurveyQuestionAnswerTypeInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerTypeInput>
  }

  export type SurveyQuestionUpdateWithWhereUniqueWithoutSurveyQuestionAnswerTypeInput = {
    where: SurveyQuestionWhereUniqueInput
    data: XOR<SurveyQuestionUpdateWithoutSurveyQuestionAnswerTypeInput, SurveyQuestionUncheckedUpdateWithoutSurveyQuestionAnswerTypeInput>
  }

  export type SurveyQuestionUpdateManyWithWhereWithoutSurveyQuestionAnswerTypeInput = {
    where: SurveyQuestionScalarWhereInput
    data: XOR<SurveyQuestionUpdateManyMutationInput, SurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionsInput>
  }

  export type SurveyQuestionCreateWithoutSurveyQuestionOptionsInput = {
    name: string
    label: string
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionCategory: QuestionCategoryCreateNestedOneWithoutSurveyQuestionsInput
    surveyQuestionAnswerType: SurveyQuestionAnswerTypeCreateNestedOneWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutSurveyQuestionOptionsInput = {
    id?: number
    name: string
    label: string
    questionCategoryId: number
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    surveyQuestionAnswerTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutSurveyQuestionOptionsInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutSurveyQuestionOptionsInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionOptionsInput>
  }

  export type SurveyQuestionAnswerCreateWithoutAnswerOptionInput = {
    responseId?: string | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionAnswerInput
    customer: CustomersCreateNestedOneWithoutSurveyQuestionAnswerInput
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyQuestionAnswerInput
    product?: ProductCreateNestedOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedCreateWithoutAnswerOptionInput = {
    id?: number
    responseId?: string | null
    customerId: number
    surveyQuestionId: number
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerCreateOrConnectWithoutAnswerOptionInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    create: XOR<SurveyQuestionAnswerCreateWithoutAnswerOptionInput, SurveyQuestionAnswerUncheckedCreateWithoutAnswerOptionInput>
  }

  export type SurveyQuestionAnswerCreateManyAnswerOptionInputEnvelope = {
    data: Enumerable<SurveyQuestionAnswerCreateManyAnswerOptionInput>
    skipDuplicates?: boolean
  }

  export type IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionOptionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionAnswer: SurveyQuestionAnswerCreateNestedOneWithoutIntermediateSurveyQuestionAnswerProductInput
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionOptionInput = {
    surveyQuestionAnswerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionOptionInput = {
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    create: XOR<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionOptionInput, IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionOptionInput>
  }

  export type IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionOptionInputEnvelope = {
    data: Enumerable<IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionOptionInput>
    skipDuplicates?: boolean
  }

  export type SurveyQuestionUpsertWithoutSurveyQuestionOptionsInput = {
    update: XOR<SurveyQuestionUpdateWithoutSurveyQuestionOptionsInput, SurveyQuestionUncheckedUpdateWithoutSurveyQuestionOptionsInput>
    create: XOR<SurveyQuestionCreateWithoutSurveyQuestionOptionsInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionOptionsInput>
  }

  export type SurveyQuestionUpdateWithoutSurveyQuestionOptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionCategory?: QuestionCategoryUpdateOneRequiredWithoutSurveyQuestionsInput
    surveyQuestionAnswerType?: SurveyQuestionAnswerTypeUpdateOneRequiredWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutSurveyQuestionOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    questionCategoryId?: IntFieldUpdateOperationsInput | number
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionAnswerTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionAnswerUpsertWithWhereUniqueWithoutAnswerOptionInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    update: XOR<SurveyQuestionAnswerUpdateWithoutAnswerOptionInput, SurveyQuestionAnswerUncheckedUpdateWithoutAnswerOptionInput>
    create: XOR<SurveyQuestionAnswerCreateWithoutAnswerOptionInput, SurveyQuestionAnswerUncheckedCreateWithoutAnswerOptionInput>
  }

  export type SurveyQuestionAnswerUpdateWithWhereUniqueWithoutAnswerOptionInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    data: XOR<SurveyQuestionAnswerUpdateWithoutAnswerOptionInput, SurveyQuestionAnswerUncheckedUpdateWithoutAnswerOptionInput>
  }

  export type SurveyQuestionAnswerUpdateManyWithWhereWithoutAnswerOptionInput = {
    where: SurveyQuestionAnswerScalarWhereInput
    data: XOR<SurveyQuestionAnswerUpdateManyMutationInput, SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionAnswerInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUpsertWithWhereUniqueWithoutSurveyQuestionOptionInput = {
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    update: XOR<IntermediateSurveyQuestionAnswerProductUpdateWithoutSurveyQuestionOptionInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateWithoutSurveyQuestionOptionInput>
    create: XOR<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionOptionInput, IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionOptionInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateWithWhereUniqueWithoutSurveyQuestionOptionInput = {
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    data: XOR<IntermediateSurveyQuestionAnswerProductUpdateWithoutSurveyQuestionOptionInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateWithoutSurveyQuestionOptionInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateManyWithWhereWithoutSurveyQuestionOptionInput = {
    where: IntermediateSurveyQuestionAnswerProductScalarWhereInput
    data: XOR<IntermediateSurveyQuestionAnswerProductUpdateManyMutationInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutIntermediateSurveyQuestionAnswerProductInput>
  }

  export type IntermediateSurveyQuestionAnswerProductScalarWhereInput = {
    AND?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereInput>
    OR?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereInput>
    NOT?: Enumerable<IntermediateSurveyQuestionAnswerProductScalarWhereInput>
    surveyQuestionAnswerId?: IntFilter | number
    surveyQuestionOptionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionAnswerInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionOption: SurveyQuestionOptionCreateNestedOneWithoutIntermediateSurveyQuestionAnswerProductInput
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionAnswerInput = {
    surveyQuestionOptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductCreateOrConnectWithoutSurveyQuestionAnswerInput = {
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    create: XOR<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionAnswerInput, IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionAnswerInputEnvelope = {
    data: Enumerable<IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionAnswerInput>
    skipDuplicates?: boolean
  }

  export type CustomersCreateWithoutSurveyQuestionAnswerInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutSurveyQuestionAnswerInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutSurveyQuestionAnswerInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutSurveyQuestionAnswerInput, CustomersUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type SurveyQuestionCreateWithoutSurveyQuestionAnswerInput = {
    name: string
    label: string
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionCategory: QuestionCategoryCreateNestedOneWithoutSurveyQuestionsInput
    surveyQuestionAnswerType: SurveyQuestionAnswerTypeCreateNestedOneWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerInput = {
    id?: number
    name: string
    label: string
    questionCategoryId: number
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    surveyQuestionAnswerTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedCreateNestedManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutSurveyQuestionAnswerInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutSurveyQuestionAnswerInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type SurveyQuestionOptionCreateWithoutSurveyQuestionAnswerInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyQuestionOptionsInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductCreateNestedManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionAnswerInput = {
    id?: number
    label: string
    name: string
    surveyQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedCreateNestedManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionCreateOrConnectWithoutSurveyQuestionAnswerInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    create: XOR<SurveyQuestionOptionCreateWithoutSurveyQuestionAnswerInput, SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type ProductCreateWithoutSurveyQuestionAnswerInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSurveyQuestionAnswerInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSurveyQuestionAnswerInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSurveyQuestionAnswerInput, ProductUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUpsertWithWhereUniqueWithoutSurveyQuestionAnswerInput = {
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    update: XOR<IntermediateSurveyQuestionAnswerProductUpdateWithoutSurveyQuestionAnswerInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateWithoutSurveyQuestionAnswerInput>
    create: XOR<IntermediateSurveyQuestionAnswerProductCreateWithoutSurveyQuestionAnswerInput, IntermediateSurveyQuestionAnswerProductUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateWithWhereUniqueWithoutSurveyQuestionAnswerInput = {
    where: IntermediateSurveyQuestionAnswerProductWhereUniqueInput
    data: XOR<IntermediateSurveyQuestionAnswerProductUpdateWithoutSurveyQuestionAnswerInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateWithoutSurveyQuestionAnswerInput>
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateManyWithWhereWithoutSurveyQuestionAnswerInput = {
    where: IntermediateSurveyQuestionAnswerProductScalarWhereInput
    data: XOR<IntermediateSurveyQuestionAnswerProductUpdateManyMutationInput, IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutIntermediateSurveyQuestionAnswerProductInput>
  }

  export type CustomersUpsertWithoutSurveyQuestionAnswerInput = {
    update: XOR<CustomersUpdateWithoutSurveyQuestionAnswerInput, CustomersUncheckedUpdateWithoutSurveyQuestionAnswerInput>
    create: XOR<CustomersCreateWithoutSurveyQuestionAnswerInput, CustomersUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type CustomersUpdateWithoutSurveyQuestionAnswerInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutSurveyQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type SurveyQuestionUpsertWithoutSurveyQuestionAnswerInput = {
    update: XOR<SurveyQuestionUpdateWithoutSurveyQuestionAnswerInput, SurveyQuestionUncheckedUpdateWithoutSurveyQuestionAnswerInput>
    create: XOR<SurveyQuestionCreateWithoutSurveyQuestionAnswerInput, SurveyQuestionUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type SurveyQuestionUpdateWithoutSurveyQuestionAnswerInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionCategory?: QuestionCategoryUpdateOneRequiredWithoutSurveyQuestionsInput
    surveyQuestionAnswerType?: SurveyQuestionAnswerTypeUpdateOneRequiredWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutSurveyQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    questionCategoryId?: IntFieldUpdateOperationsInput | number
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionAnswerTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionOptionUpsertWithoutSurveyQuestionAnswerInput = {
    update: XOR<SurveyQuestionOptionUpdateWithoutSurveyQuestionAnswerInput, SurveyQuestionOptionUncheckedUpdateWithoutSurveyQuestionAnswerInput>
    create: XOR<SurveyQuestionOptionCreateWithoutSurveyQuestionAnswerInput, SurveyQuestionOptionUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type SurveyQuestionOptionUpdateWithoutSurveyQuestionAnswerInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionOptionsInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionUncheckedUpdateWithoutSurveyQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionOptionInput
  }

  export type ProductUpsertWithoutSurveyQuestionAnswerInput = {
    update: XOR<ProductUpdateWithoutSurveyQuestionAnswerInput, ProductUncheckedUpdateWithoutSurveyQuestionAnswerInput>
    create: XOR<ProductCreateWithoutSurveyQuestionAnswerInput, ProductUncheckedCreateWithoutSurveyQuestionAnswerInput>
  }

  export type ProductUpdateWithoutSurveyQuestionAnswerInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutSurveyQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type SurveyQuestionAnswerCreateWithoutIntermediateSurveyQuestionAnswerProductInput = {
    responseId?: string | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutSurveyQuestionAnswerInput
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionCreateNestedOneWithoutSurveyQuestionAnswerInput
    product?: ProductCreateNestedOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput = {
    id?: number
    responseId?: string | null
    customerId: number
    surveyQuestionId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerCreateOrConnectWithoutIntermediateSurveyQuestionAnswerProductInput = {
    where: SurveyQuestionAnswerWhereUniqueInput
    create: XOR<SurveyQuestionAnswerCreateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionAnswerUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput>
  }

  export type SurveyQuestionOptionCreateWithoutIntermediateSurveyQuestionAnswerProductInput = {
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyQuestionOptionsInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutAnswerOptionInput
  }

  export type SurveyQuestionOptionUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput = {
    id?: number
    label: string
    name: string
    surveyQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutAnswerOptionInput
  }

  export type SurveyQuestionOptionCreateOrConnectWithoutIntermediateSurveyQuestionAnswerProductInput = {
    where: SurveyQuestionOptionWhereUniqueInput
    create: XOR<SurveyQuestionOptionCreateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionOptionUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput>
  }

  export type SurveyQuestionAnswerUpsertWithoutIntermediateSurveyQuestionAnswerProductInput = {
    update: XOR<SurveyQuestionAnswerUpdateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionAnswerUncheckedUpdateWithoutIntermediateSurveyQuestionAnswerProductInput>
    create: XOR<SurveyQuestionAnswerCreateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionAnswerUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput>
  }

  export type SurveyQuestionAnswerUpdateWithoutIntermediateSurveyQuestionAnswerProductInput = {
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionUpdateOneWithoutSurveyQuestionAnswerInput
    product?: ProductUpdateOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedUpdateWithoutIntermediateSurveyQuestionAnswerProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    answerSingleOptionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionOptionUpsertWithoutIntermediateSurveyQuestionAnswerProductInput = {
    update: XOR<SurveyQuestionOptionUpdateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionOptionUncheckedUpdateWithoutIntermediateSurveyQuestionAnswerProductInput>
    create: XOR<SurveyQuestionOptionCreateWithoutIntermediateSurveyQuestionAnswerProductInput, SurveyQuestionOptionUncheckedCreateWithoutIntermediateSurveyQuestionAnswerProductInput>
  }

  export type SurveyQuestionOptionUpdateWithoutIntermediateSurveyQuestionAnswerProductInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionOptionsInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutAnswerOptionInput
  }

  export type SurveyQuestionOptionUncheckedUpdateWithoutIntermediateSurveyQuestionAnswerProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutAnswerOptionInput
  }

  export type ProductCreateWithoutCustomerProductDistancesInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCustomerProductDistancesInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCustomerProductDistancesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCustomerProductDistancesInput, ProductUncheckedCreateWithoutCustomerProductDistancesInput>
  }

  export type CustomersCreateWithoutCustomerProductDistancesInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutCustomerProductDistancesInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutCustomerProductDistancesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCustomerProductDistancesInput, CustomersUncheckedCreateWithoutCustomerProductDistancesInput>
  }

  export type ProductUpsertWithoutCustomerProductDistancesInput = {
    update: XOR<ProductUpdateWithoutCustomerProductDistancesInput, ProductUncheckedUpdateWithoutCustomerProductDistancesInput>
    create: XOR<ProductCreateWithoutCustomerProductDistancesInput, ProductUncheckedCreateWithoutCustomerProductDistancesInput>
  }

  export type ProductUpdateWithoutCustomerProductDistancesInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutCustomerProductDistancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type CustomersUpsertWithoutCustomerProductDistancesInput = {
    update: XOR<CustomersUpdateWithoutCustomerProductDistancesInput, CustomersUncheckedUpdateWithoutCustomerProductDistancesInput>
    create: XOR<CustomersCreateWithoutCustomerProductDistancesInput, CustomersUncheckedCreateWithoutCustomerProductDistancesInput>
  }

  export type CustomersUpdateWithoutCustomerProductDistancesInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutCustomerProductDistancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type ProductCreateWithoutCustomerBoxItemsInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCustomerBoxItemsInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCustomerBoxItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCustomerBoxItemsInput, ProductUncheckedCreateWithoutCustomerBoxItemsInput>
  }

  export type CustomersCreateWithoutCustomerBoxItemsInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutCustomerBoxItemsInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutCustomerBoxItemsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCustomerBoxItemsInput, CustomersUncheckedCreateWithoutCustomerBoxItemsInput>
  }

  export type ProductUpsertWithoutCustomerBoxItemsInput = {
    update: XOR<ProductUpdateWithoutCustomerBoxItemsInput, ProductUncheckedUpdateWithoutCustomerBoxItemsInput>
    create: XOR<ProductCreateWithoutCustomerBoxItemsInput, ProductUncheckedCreateWithoutCustomerBoxItemsInput>
  }

  export type ProductUpdateWithoutCustomerBoxItemsInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutCustomerBoxItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type CustomersUpsertWithoutCustomerBoxItemsInput = {
    update: XOR<CustomersUpdateWithoutCustomerBoxItemsInput, CustomersUncheckedUpdateWithoutCustomerBoxItemsInput>
    create: XOR<CustomersCreateWithoutCustomerBoxItemsInput, CustomersUncheckedCreateWithoutCustomerBoxItemsInput>
  }

  export type CustomersUpdateWithoutCustomerBoxItemsInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutCustomerBoxItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type CustomersCreateWithoutQueuedShopifyOrderInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutQueuedShopifyOrderInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutQueuedShopifyOrderInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutQueuedShopifyOrderInput, CustomersUncheckedCreateWithoutQueuedShopifyOrderInput>
  }

  export type CustomersUpsertWithoutQueuedShopifyOrderInput = {
    update: XOR<CustomersUpdateWithoutQueuedShopifyOrderInput, CustomersUncheckedUpdateWithoutQueuedShopifyOrderInput>
    create: XOR<CustomersCreateWithoutQueuedShopifyOrderInput, CustomersUncheckedCreateWithoutQueuedShopifyOrderInput>
  }

  export type CustomersUpdateWithoutQueuedShopifyOrderInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutQueuedShopifyOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutCustomerInput
  }

  export type PractitionerBoxCreateWithoutPractitionerInput = {
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedCreateWithoutPractitionerInput = {
    id?: number
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxCreateOrConnectWithoutPractitionerInput = {
    where: PractitionerBoxWhereUniqueInput
    create: XOR<PractitionerBoxCreateWithoutPractitionerInput, PractitionerBoxUncheckedCreateWithoutPractitionerInput>
  }

  export type PractitionerBoxCreateManyPractitionerInputEnvelope = {
    data: Enumerable<PractitionerBoxCreateManyPractitionerInput>
    skipDuplicates?: boolean
  }

  export type PractitionerSocialMediaCreateWithoutPractitionerInput = {
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerSocialMediaUncheckedCreateWithoutPractitionerInput = {
    id?: number
    instagram?: string | null
    facebook?: string | null
    twitter?: string | null
    website?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerSocialMediaCreateOrConnectWithoutPractitionerInput = {
    where: PractitionerSocialMediaWhereUniqueInput
    create: XOR<PractitionerSocialMediaCreateWithoutPractitionerInput, PractitionerSocialMediaUncheckedCreateWithoutPractitionerInput>
  }

  export type PractitionerBoxUpsertWithWhereUniqueWithoutPractitionerInput = {
    where: PractitionerBoxWhereUniqueInput
    update: XOR<PractitionerBoxUpdateWithoutPractitionerInput, PractitionerBoxUncheckedUpdateWithoutPractitionerInput>
    create: XOR<PractitionerBoxCreateWithoutPractitionerInput, PractitionerBoxUncheckedCreateWithoutPractitionerInput>
  }

  export type PractitionerBoxUpdateWithWhereUniqueWithoutPractitionerInput = {
    where: PractitionerBoxWhereUniqueInput
    data: XOR<PractitionerBoxUpdateWithoutPractitionerInput, PractitionerBoxUncheckedUpdateWithoutPractitionerInput>
  }

  export type PractitionerBoxUpdateManyWithWhereWithoutPractitionerInput = {
    where: PractitionerBoxScalarWhereInput
    data: XOR<PractitionerBoxUpdateManyMutationInput, PractitionerBoxUncheckedUpdateManyWithoutPractitionerBoxInput>
  }

  export type PractitionerBoxScalarWhereInput = {
    AND?: Enumerable<PractitionerBoxScalarWhereInput>
    OR?: Enumerable<PractitionerBoxScalarWhereInput>
    NOT?: Enumerable<PractitionerBoxScalarWhereInput>
    id?: IntFilter | number
    practitionerId?: IntFilter | number
    label?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PractitionerSocialMediaUpsertWithoutPractitionerInput = {
    update: XOR<PractitionerSocialMediaUpdateWithoutPractitionerInput, PractitionerSocialMediaUncheckedUpdateWithoutPractitionerInput>
    create: XOR<PractitionerSocialMediaCreateWithoutPractitionerInput, PractitionerSocialMediaUncheckedCreateWithoutPractitionerInput>
  }

  export type PractitionerSocialMediaUpdateWithoutPractitionerInput = {
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerSocialMediaUncheckedUpdateWithoutPractitionerInput = {
    id?: IntFieldUpdateOperationsInput | number
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerCreateWithoutPractitionerSocialMediaInput = {
    uuid: string
    email: string
    phoneNumber?: string | null
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerBox?: PractitionerBoxCreateNestedManyWithoutPractitionerInput
  }

  export type PractitionerUncheckedCreateWithoutPractitionerSocialMediaInput = {
    id?: number
    uuid: string
    email: string
    phoneNumber?: string | null
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerBox?: PractitionerBoxUncheckedCreateNestedManyWithoutPractitionerInput
  }

  export type PractitionerCreateOrConnectWithoutPractitionerSocialMediaInput = {
    where: PractitionerWhereUniqueInput
    create: XOR<PractitionerCreateWithoutPractitionerSocialMediaInput, PractitionerUncheckedCreateWithoutPractitionerSocialMediaInput>
  }

  export type PractitionerUpsertWithoutPractitionerSocialMediaInput = {
    update: XOR<PractitionerUpdateWithoutPractitionerSocialMediaInput, PractitionerUncheckedUpdateWithoutPractitionerSocialMediaInput>
    create: XOR<PractitionerCreateWithoutPractitionerSocialMediaInput, PractitionerUncheckedCreateWithoutPractitionerSocialMediaInput>
  }

  export type PractitionerUpdateWithoutPractitionerSocialMediaInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerBox?: PractitionerBoxUpdateManyWithoutPractitionerInput
  }

  export type PractitionerUncheckedUpdateWithoutPractitionerSocialMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerBox?: PractitionerBoxUncheckedUpdateManyWithoutPractitionerInput
  }

  export type PractitionerCreateWithoutPractitionerBoxInput = {
    uuid: string
    email: string
    phoneNumber?: string | null
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerSocialMedia?: PractitionerSocialMediaCreateNestedOneWithoutPractitionerInput
  }

  export type PractitionerUncheckedCreateWithoutPractitionerBoxInput = {
    id?: number
    uuid: string
    email: string
    phoneNumber?: string | null
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerSocialMedia?: PractitionerSocialMediaUncheckedCreateNestedOneWithoutPractitionerInput
  }

  export type PractitionerCreateOrConnectWithoutPractitionerBoxInput = {
    where: PractitionerWhereUniqueInput
    create: XOR<PractitionerCreateWithoutPractitionerBoxInput, PractitionerUncheckedCreateWithoutPractitionerBoxInput>
  }

  export type PractitionerCustomerOrderHistoryCreateWithoutPractitionerBoxInput = {
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomersCreateNestedOneWithoutPractitionerCustomerOrderHistoryInput
  }

  export type PractitionerCustomerOrderHistoryUncheckedCreateWithoutPractitionerBoxInput = {
    id?: number
    customerId: number
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerCustomerOrderHistoryCreateOrConnectWithoutPractitionerBoxInput = {
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
    create: XOR<PractitionerCustomerOrderHistoryCreateWithoutPractitionerBoxInput, PractitionerCustomerOrderHistoryUncheckedCreateWithoutPractitionerBoxInput>
  }

  export type PractitionerCustomerOrderHistoryCreateManyPractitionerBoxInputEnvelope = {
    data: Enumerable<PractitionerCustomerOrderHistoryCreateManyPractitionerBoxInput>
    skipDuplicates?: boolean
  }

  export type IntermediatePractitionerBoxProductCreateWithoutPractitionerBoxInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutIntermediatePractitionerBoxProductInput
  }

  export type IntermediatePractitionerBoxProductUncheckedCreateWithoutPractitionerBoxInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediatePractitionerBoxProductCreateOrConnectWithoutPractitionerBoxInput = {
    where: IntermediatePractitionerBoxProductWhereUniqueInput
    create: XOR<IntermediatePractitionerBoxProductCreateWithoutPractitionerBoxInput, IntermediatePractitionerBoxProductUncheckedCreateWithoutPractitionerBoxInput>
  }

  export type IntermediatePractitionerBoxProductCreateManyPractitionerBoxInputEnvelope = {
    data: Enumerable<IntermediatePractitionerBoxProductCreateManyPractitionerBoxInput>
    skipDuplicates?: boolean
  }

  export type PractitionerUpsertWithoutPractitionerBoxInput = {
    update: XOR<PractitionerUpdateWithoutPractitionerBoxInput, PractitionerUncheckedUpdateWithoutPractitionerBoxInput>
    create: XOR<PractitionerCreateWithoutPractitionerBoxInput, PractitionerUncheckedCreateWithoutPractitionerBoxInput>
  }

  export type PractitionerUpdateWithoutPractitionerBoxInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerSocialMedia?: PractitionerSocialMediaUpdateOneWithoutPractitionerInput
  }

  export type PractitionerUncheckedUpdateWithoutPractitionerBoxInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerSocialMedia?: PractitionerSocialMediaUncheckedUpdateOneWithoutPractitionerInput
  }

  export type PractitionerCustomerOrderHistoryUpsertWithWhereUniqueWithoutPractitionerBoxInput = {
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
    update: XOR<PractitionerCustomerOrderHistoryUpdateWithoutPractitionerBoxInput, PractitionerCustomerOrderHistoryUncheckedUpdateWithoutPractitionerBoxInput>
    create: XOR<PractitionerCustomerOrderHistoryCreateWithoutPractitionerBoxInput, PractitionerCustomerOrderHistoryUncheckedCreateWithoutPractitionerBoxInput>
  }

  export type PractitionerCustomerOrderHistoryUpdateWithWhereUniqueWithoutPractitionerBoxInput = {
    where: PractitionerCustomerOrderHistoryWhereUniqueInput
    data: XOR<PractitionerCustomerOrderHistoryUpdateWithoutPractitionerBoxInput, PractitionerCustomerOrderHistoryUncheckedUpdateWithoutPractitionerBoxInput>
  }

  export type PractitionerCustomerOrderHistoryUpdateManyWithWhereWithoutPractitionerBoxInput = {
    where: PractitionerCustomerOrderHistoryScalarWhereInput
    data: XOR<PractitionerCustomerOrderHistoryUpdateManyMutationInput, PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutPractitionerCustomerOrderHistoryInput>
  }

  export type IntermediatePractitionerBoxProductUpsertWithWhereUniqueWithoutPractitionerBoxInput = {
    where: IntermediatePractitionerBoxProductWhereUniqueInput
    update: XOR<IntermediatePractitionerBoxProductUpdateWithoutPractitionerBoxInput, IntermediatePractitionerBoxProductUncheckedUpdateWithoutPractitionerBoxInput>
    create: XOR<IntermediatePractitionerBoxProductCreateWithoutPractitionerBoxInput, IntermediatePractitionerBoxProductUncheckedCreateWithoutPractitionerBoxInput>
  }

  export type IntermediatePractitionerBoxProductUpdateWithWhereUniqueWithoutPractitionerBoxInput = {
    where: IntermediatePractitionerBoxProductWhereUniqueInput
    data: XOR<IntermediatePractitionerBoxProductUpdateWithoutPractitionerBoxInput, IntermediatePractitionerBoxProductUncheckedUpdateWithoutPractitionerBoxInput>
  }

  export type IntermediatePractitionerBoxProductUpdateManyWithWhereWithoutPractitionerBoxInput = {
    where: IntermediatePractitionerBoxProductScalarWhereInput
    data: XOR<IntermediatePractitionerBoxProductUpdateManyMutationInput, IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutIntermediatePractitionerBoxProductInput>
  }

  export type PractitionerBoxCreateWithoutIntermediatePractitionerBoxProductInput = {
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    practitioner: PractitionerCreateNestedOneWithoutPractitionerBoxInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryCreateNestedManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedCreateWithoutIntermediatePractitionerBoxProductInput = {
    id?: number
    practitionerId: number
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedCreateNestedManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxCreateOrConnectWithoutIntermediatePractitionerBoxProductInput = {
    where: PractitionerBoxWhereUniqueInput
    create: XOR<PractitionerBoxCreateWithoutIntermediatePractitionerBoxProductInput, PractitionerBoxUncheckedCreateWithoutIntermediatePractitionerBoxProductInput>
  }

  export type ProductCreateWithoutIntermediatePractitionerBoxProductInput = {
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productProvider: ProductProviderCreateNestedOneWithoutProductsInput
    productCategory?: ProductCategoryCreateNestedOneWithoutProductsInput
    productFlavor?: ProductFlavorCreateNestedOneWithoutProductsInput
    productVendor?: ProductVendorCreateNestedOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutProductInput
    productImages?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutIntermediatePractitionerBoxProductInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedCreateNestedManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedCreateNestedManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedCreateNestedManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedCreateNestedManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedCreateNestedOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutProductInput
    productImages?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutIntermediatePractitionerBoxProductInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutIntermediatePractitionerBoxProductInput, ProductUncheckedCreateWithoutIntermediatePractitionerBoxProductInput>
  }

  export type PractitionerBoxUpsertWithoutIntermediatePractitionerBoxProductInput = {
    update: XOR<PractitionerBoxUpdateWithoutIntermediatePractitionerBoxProductInput, PractitionerBoxUncheckedUpdateWithoutIntermediatePractitionerBoxProductInput>
    create: XOR<PractitionerBoxCreateWithoutIntermediatePractitionerBoxProductInput, PractitionerBoxUncheckedCreateWithoutIntermediatePractitionerBoxProductInput>
  }

  export type PractitionerBoxUpdateWithoutIntermediatePractitionerBoxProductInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitioner?: PractitionerUpdateOneRequiredWithoutPractitionerBoxInput
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedUpdateWithoutIntermediatePractitionerBoxProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    practitionerId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutPractitionerBoxInput
  }

  export type ProductUpsertWithoutIntermediatePractitionerBoxProductInput = {
    update: XOR<ProductUpdateWithoutIntermediatePractitionerBoxProductInput, ProductUncheckedUpdateWithoutIntermediatePractitionerBoxProductInput>
    create: XOR<ProductCreateWithoutIntermediatePractitionerBoxProductInput, ProductUncheckedCreateWithoutIntermediatePractitionerBoxProductInput>
  }

  export type ProductUpdateWithoutIntermediatePractitionerBoxProductInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutIntermediatePractitionerBoxProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type CustomersCreateWithoutPractitionerCustomerOrderHistoryInput = {
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput = {
    id?: number
    uuid?: string | null
    email: string
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    gender?: string | null
    activeLevel?: string | null
    mealsPerDay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedCreateNestedManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedCreateNestedManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedCreateNestedManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedCreateNestedManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedCreateNestedManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutPractitionerCustomerOrderHistoryInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutPractitionerCustomerOrderHistoryInput, CustomersUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput>
  }

  export type PractitionerBoxCreateWithoutPractitionerCustomerOrderHistoryInput = {
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    practitioner: PractitionerCreateNestedOneWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductCreateNestedManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput = {
    id?: number
    practitionerId: number
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedCreateNestedManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxCreateOrConnectWithoutPractitionerCustomerOrderHistoryInput = {
    where: PractitionerBoxWhereUniqueInput
    create: XOR<PractitionerBoxCreateWithoutPractitionerCustomerOrderHistoryInput, PractitionerBoxUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput>
  }

  export type CustomersUpsertWithoutPractitionerCustomerOrderHistoryInput = {
    update: XOR<CustomersUpdateWithoutPractitionerCustomerOrderHistoryInput, CustomersUncheckedUpdateWithoutPractitionerCustomerOrderHistoryInput>
    create: XOR<CustomersCreateWithoutPractitionerCustomerOrderHistoryInput, CustomersUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput>
  }

  export type CustomersUpdateWithoutPractitionerCustomerOrderHistoryInput = {
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUpdateManyWithoutCustomerInput
  }

  export type CustomersUncheckedUpdateWithoutPractitionerCustomerOrderHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    activeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    mealsPerDay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateCustomerNutritionNeeds?: IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerMedicalConditions?: IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerAllergens?: IntermediateCustomerAllergenUncheckedUpdateManyWithoutCustomerInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutCustomerInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutCustomerInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutCustomerInput
    queuedShopifyOrder?: QueuedShopifyOrderUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFlavorDislikes?: IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerCategoryPreferences?: IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerIngredientDislikes?: IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerFoodTypes?: IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutCustomerInput
    intermediateCustomerUnavailableCookingMethods?: IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutCustomerInput
  }

  export type PractitionerBoxUpsertWithoutPractitionerCustomerOrderHistoryInput = {
    update: XOR<PractitionerBoxUpdateWithoutPractitionerCustomerOrderHistoryInput, PractitionerBoxUncheckedUpdateWithoutPractitionerCustomerOrderHistoryInput>
    create: XOR<PractitionerBoxCreateWithoutPractitionerCustomerOrderHistoryInput, PractitionerBoxUncheckedCreateWithoutPractitionerCustomerOrderHistoryInput>
  }

  export type PractitionerBoxUpdateWithoutPractitionerCustomerOrderHistoryInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitioner?: PractitionerUpdateOneRequiredWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedUpdateWithoutPractitionerCustomerOrderHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    practitionerId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutPractitionerBoxInput
  }

  export type IntermediateCustomerNutritionNeedCreateManyCustomerInput = {
    customerNutritionNeedId: number
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerMedicalConditionCreateManyCustomerInput = {
    medicalConditionValue: string
    customerMedicalConditionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerAllergenCreateManyCustomerInput = {
    productAllergenId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerCreateManyCustomerInput = {
    id?: number
    responseId?: string | null
    surveyQuestionId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductDistanceCreateManyCustomerInput = {
    id?: number
    distance: number
    productId: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerBoxItemsCreateManyCustomerInput = {
    id?: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueuedShopifyOrderCreateManyCustomerInput = {
    id?: number
    orderName: string
    status?: QueueStatus
    scheduledAt: string
    orderedAt?: string | null
    fulfilledAt?: string | null
  }

  export type IntermediateCustomerFlavorDislikeCreateManyCustomerInput = {
    productFlavorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerCategoryPreferenceCreateManyCustomerInput = {
    productCategoryId: number
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerIngredientDislikeCreateManyCustomerInput = {
    productIngredientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFoodTypeCreateManyCustomerInput = {
    productFoodTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateManyCustomerInput = {
    productCookingMethodId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerCustomerOrderHistoryCreateManyCustomerInput = {
    id?: number
    practitionerBoxId: number
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerNutritionNeedUpdateWithoutCustomerInput = {
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerNutritionNeed?: CustomerNutritionNeedUpdateOneRequiredWithoutIntermediateCustomerNutritionNeedInput
  }

  export type IntermediateCustomerNutritionNeedUncheckedUpdateWithoutCustomerInput = {
    customerNutritionNeedId?: IntFieldUpdateOperationsInput | number
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutIntermediateCustomerNutritionNeedsInput = {
    customerNutritionNeedId?: IntFieldUpdateOperationsInput | number
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerMedicalConditionUpdateWithoutCustomerInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerMedicalCondition?: CustomerMedicalConditionUpdateOneRequiredWithoutIntermediateCustomerMedicalConditionsInput
  }

  export type IntermediateCustomerMedicalConditionUncheckedUpdateWithoutCustomerInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    customerMedicalConditionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerMedicalConditionUncheckedUpdateManyWithoutIntermediateCustomerMedicalConditionsInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    customerMedicalConditionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerAllergenUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productAllergen?: ProductAllergenUpdateOneRequiredWithoutIntermediateCustomerAllergensInput
  }

  export type IntermediateCustomerAllergenUncheckedUpdateWithoutCustomerInput = {
    productAllergenId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerAllergenUncheckedUpdateManyWithoutIntermediateCustomerAllergensInput = {
    productAllergenId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerUpdateWithoutCustomerInput = {
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionAnswerInput
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionUpdateOneWithoutSurveyQuestionAnswerInput
    product?: ProductUpdateOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    answerSingleOptionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    answerSingleOptionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductDistanceUpdateWithoutCustomerInput = {
    distance?: FloatFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCustomerProductDistancesInput
  }

  export type CustomerProductDistanceUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductDistanceUncheckedUpdateManyWithoutCustomerProductDistancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBoxItemsUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCustomerBoxItemsInput
  }

  export type CustomerBoxItemsUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBoxItemsUncheckedUpdateManyWithoutCustomerBoxItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueuedShopifyOrderUpdateWithoutCustomerInput = {
    orderName?: StringFieldUpdateOperationsInput | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | QueueStatus
    scheduledAt?: StringFieldUpdateOperationsInput | string
    orderedAt?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QueuedShopifyOrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderName?: StringFieldUpdateOperationsInput | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | QueueStatus
    scheduledAt?: StringFieldUpdateOperationsInput | string
    orderedAt?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QueuedShopifyOrderUncheckedUpdateManyWithoutQueuedShopifyOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderName?: StringFieldUpdateOperationsInput | string
    status?: EnumQueueStatusFieldUpdateOperationsInput | QueueStatus
    scheduledAt?: StringFieldUpdateOperationsInput | string
    orderedAt?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntermediateCustomerFlavorDislikeUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFlavor?: ProductFlavorUpdateOneRequiredWithoutIntermediateCustomerFlavorDislikesInput
  }

  export type IntermediateCustomerFlavorDislikeUncheckedUpdateWithoutCustomerInput = {
    productFlavorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFlavorDislikeUncheckedUpdateManyWithoutIntermediateCustomerFlavorDislikesInput = {
    productFlavorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerCategoryPreferenceUpdateWithoutCustomerInput = {
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productCategory?: ProductCategoryUpdateOneRequiredWithoutIntermediateCustomerCategoryPreferencesInput
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedUpdateWithoutCustomerInput = {
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedUpdateManyWithoutIntermediateCustomerCategoryPreferencesInput = {
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerIngredientDislikeUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productIngredient?: ProductIngredientUpdateOneRequiredWithoutIntermediateCustomerIngredientDislikesInput
  }

  export type IntermediateCustomerIngredientDislikeUncheckedUpdateWithoutCustomerInput = {
    productIngredientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerIngredientDislikeUncheckedUpdateManyWithoutIntermediateCustomerIngredientDislikesInput = {
    productIngredientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFoodTypeUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFoodType?: ProductFoodTypeUpdateOneRequiredWithoutIntermediateCustomerFoodTypesInput
  }

  export type IntermediateCustomerFoodTypeUncheckedUpdateWithoutCustomerInput = {
    productFoodTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFoodTypeUncheckedUpdateManyWithoutIntermediateCustomerFoodTypesInput = {
    productFoodTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateWithoutCustomerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productCookingMethod?: ProductCookingMethodUpdateOneRequiredWithoutIntermediateCustomerUnavailableCookingMethodsInput
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedUpdateWithoutCustomerInput = {
    productCookingMethodId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedUpdateManyWithoutIntermediateCustomerUnavailableCookingMethodsInput = {
    productCookingMethodId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerCustomerOrderHistoryUpdateWithoutCustomerInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerBox?: PractitionerBoxUpdateOneRequiredWithoutPractitionerCustomerOrderHistoryInput
  }

  export type PractitionerCustomerOrderHistoryUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    practitionerBoxId?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutPractitionerCustomerOrderHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    practitionerBoxId?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerNutritionNeedCreateManyCustomerNutritionNeedInput = {
    customerId: number
    nutritionValue: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerNutritionNeedUpdateWithoutCustomerNutritionNeedInput = {
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerNutritionNeedsInput
  }

  export type IntermediateCustomerNutritionNeedUncheckedUpdateWithoutCustomerNutritionNeedInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerNutritionNeedUncheckedUpdateManyWithoutIntermediateCustomerNutritionNeedInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    nutritionValue?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerMedicalConditionCreateManyCustomerMedicalConditionInput = {
    medicalConditionValue: string
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerMedicalConditionUpdateWithoutCustomerMedicalConditionInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerMedicalConditionsInput
  }

  export type IntermediateCustomerMedicalConditionUncheckedUpdateWithoutCustomerMedicalConditionInput = {
    medicalConditionValue?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFoodTypeCreateManyProductFoodTypeInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductFoodTypeCreateManyProductFoodTypeInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFoodTypeUpdateWithoutProductFoodTypeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerFoodTypesInput
  }

  export type IntermediateCustomerFoodTypeUncheckedUpdateWithoutProductFoodTypeInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductFoodTypeUpdateWithoutProductFoodTypeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntermediateProductFoodTypesInput
  }

  export type IntermediateProductFoodTypeUncheckedUpdateWithoutProductFoodTypeInput = {
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductFoodTypeUncheckedUpdateManyWithoutIntermediateProductFoodTypesInput = {
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductFoodTypeCreateManyProductInput = {
    productFoodTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductIngredientCreateManyProductInput = {
    productIngredientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductAllergenCreateManyProductInput = {
    productAllergenId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductCookingMethodCreateManyProductInput = {
    productCookingMethodId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediatePractitionerBoxProductCreateManyProductInput = {
    practitionerBoxId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerCreateManyProductInput = {
    id?: number
    responseId?: string | null
    customerId: number
    surveyQuestionId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductDistanceCreateManyProductInput = {
    id?: number
    distance: number
    customerId: number
    version?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerBoxItemsCreateManyProductInput = {
    id?: number
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageCreateManyProductInput = {
    id?: number
    src: string
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductFoodTypeUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productFoodType?: ProductFoodTypeUpdateOneRequiredWithoutIntermediateProductFoodTypesInput
  }

  export type IntermediateProductFoodTypeUncheckedUpdateWithoutProductInput = {
    productFoodTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductIngredientUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productIngredient?: ProductIngredientUpdateOneRequiredWithoutIntermediateProductIngredientsInput
  }

  export type IntermediateProductIngredientUncheckedUpdateWithoutProductInput = {
    productIngredientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductIngredientUncheckedUpdateManyWithoutIntermediateProductIngredientsInput = {
    productIngredientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductAllergenUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productAllergen?: ProductAllergenUpdateOneRequiredWithoutIntermediateProductAllergensInput
  }

  export type IntermediateProductAllergenUncheckedUpdateWithoutProductInput = {
    productAllergenId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductAllergenUncheckedUpdateManyWithoutIntermediateProductAllergensInput = {
    productAllergenId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductCookingMethodUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productCookingMethod?: ProductCookingMethodUpdateOneRequiredWithoutIntermediateProductCookingMethodsInput
  }

  export type IntermediateProductCookingMethodUncheckedUpdateWithoutProductInput = {
    productCookingMethodId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductCookingMethodUncheckedUpdateManyWithoutIntermediateProductCookingMethodsInput = {
    productCookingMethodId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediatePractitionerBoxProductUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerBox?: PractitionerBoxUpdateOneRequiredWithoutIntermediatePractitionerBoxProductInput
  }

  export type IntermediatePractitionerBoxProductUncheckedUpdateWithoutProductInput = {
    practitionerBoxId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutIntermediatePractitionerBoxProductInput = {
    practitionerBoxId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerUpdateWithoutProductInput = {
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionAnswerInput
    customer?: CustomersUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionUpdateOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    answerSingleOptionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionAnswerInput
  }

  export type CustomerProductDistanceUpdateWithoutProductInput = {
    distance?: FloatFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutCustomerProductDistancesInput
  }

  export type CustomerProductDistanceUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    distance?: FloatFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    version?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerBoxItemsUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutCustomerBoxItemsInput
  }

  export type CustomerBoxItemsUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUpdateWithoutProductInput = {
    src?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    src?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    src?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductCookingMethodCreateManyProductCookingMethodInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodCreateManyProductCookingMethodInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductCookingMethodUpdateWithoutProductCookingMethodInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntermediateProductCookingMethodsInput
  }

  export type IntermediateProductCookingMethodUncheckedUpdateWithoutProductCookingMethodInput = {
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerUnavailableCookingMethodUpdateWithoutProductCookingMethodInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerUnavailableCookingMethodsInput
  }

  export type IntermediateCustomerUnavailableCookingMethodUncheckedUpdateWithoutProductCookingMethodInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProductFlavorInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerFlavorDislikeCreateManyProductFlavorInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutProductFlavorInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProductFlavorInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerFlavorDislikeUpdateWithoutProductFlavorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerFlavorDislikesInput
  }

  export type IntermediateCustomerFlavorDislikeUncheckedUpdateWithoutProductFlavorInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProductVendorInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productCategoryId?: number | null
    productFlavorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutProductVendorInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProductVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateManyProductCategoryInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productProviderId: number
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerCategoryPreferenceCreateManyProductCategoryInput = {
    customerId: number
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutProductCategoryInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productProvider?: ProductProviderUpdateOneRequiredWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productProviderId?: IntFieldUpdateOperationsInput | number
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type IntermediateCustomerCategoryPreferenceUpdateWithoutProductCategoryInput = {
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerCategoryPreferencesInput
  }

  export type IntermediateCustomerCategoryPreferenceUncheckedUpdateWithoutProductCategoryInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductIngredientCreateManyProductIngredientInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerIngredientDislikeCreateManyProductIngredientInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductIngredientUpdateWithoutProductIngredientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntermediateProductIngredientsInput
  }

  export type IntermediateProductIngredientUncheckedUpdateWithoutProductIngredientInput = {
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerIngredientDislikeUpdateWithoutProductIngredientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerIngredientDislikesInput
  }

  export type IntermediateCustomerIngredientDislikeUncheckedUpdateWithoutProductIngredientInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateProductAllergenCreateManyProductAllergenInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateCustomerAllergenCreateManyProductAllergenInput = {
    customerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateProductAllergenUpdateWithoutProductAllergenInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntermediateProductAllergensInput
  }

  export type IntermediateProductAllergenUncheckedUpdateWithoutProductAllergenInput = {
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateCustomerAllergenUpdateWithoutProductAllergenInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutIntermediateCustomerAllergensInput
  }

  export type IntermediateCustomerAllergenUncheckedUpdateWithoutProductAllergenInput = {
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProductProviderInput = {
    id?: number
    activeStatus?: ActiveStatus | null
    name?: string | null
    label?: string | null
    ingredientLabel?: string | null
    allergenLabel?: string | null
    expertComment?: string | null
    productCategoryId?: number | null
    productFlavorId?: number | null
    productVendorId?: number | null
    externalSku: string
    upcCode?: string | null
    MSP?: number | null
    WSP?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutProductProviderInput = {
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productCategory?: ProductCategoryUpdateOneWithoutProductsInput
    productFlavor?: ProductFlavorUpdateOneWithoutProductsInput
    productVendor?: ProductVendorUpdateOneWithoutProductsInput
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUpdateManyWithoutProductInput
    productImages?: ProductImageUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateWithoutProductProviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeStatus?: NullableEnumActiveStatusFieldUpdateOperationsInput | ActiveStatus | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    ingredientLabel?: NullableStringFieldUpdateOperationsInput | string | null
    allergenLabel?: NullableStringFieldUpdateOperationsInput | string | null
    expertComment?: NullableStringFieldUpdateOperationsInput | string | null
    productCategoryId?: NullableIntFieldUpdateOperationsInput | number | null
    productFlavorId?: NullableIntFieldUpdateOperationsInput | number | null
    productVendorId?: NullableIntFieldUpdateOperationsInput | number | null
    externalSku?: StringFieldUpdateOperationsInput | string
    upcCode?: NullableStringFieldUpdateOperationsInput | string | null
    MSP?: NullableFloatFieldUpdateOperationsInput | number | null
    WSP?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateProductFoodTypes?: IntermediateProductFoodTypeUncheckedUpdateManyWithoutProductInput
    intermediateProductIngredients?: IntermediateProductIngredientUncheckedUpdateManyWithoutProductInput
    intermediateProductAllergens?: IntermediateProductAllergenUncheckedUpdateManyWithoutProductInput
    intermediateProductCookingMethods?: IntermediateProductCookingMethodUncheckedUpdateManyWithoutProductInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutProductInput
    productNutritionFact?: ProductNutritionFactUncheckedUpdateOneWithoutProductInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutProductInput
    customerProductDistances?: CustomerProductDistanceUncheckedUpdateManyWithoutProductInput
    customerBoxItems?: CustomerBoxItemsUncheckedUpdateManyWithoutProductInput
    productImages?: ProductImageUncheckedUpdateManyWithoutProductInput
  }

  export type IntermediateSurveyQuestionCreateManySurveyInput = {
    displayOrder?: number | null
    surveyQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionUpdateWithoutSurveyInput = {
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutIntermediateSurveyQuestionsInput
  }

  export type IntermediateSurveyQuestionUncheckedUpdateWithoutSurveyInput = {
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionUncheckedUpdateManyWithoutIntermediateSurveyQuestionsInput = {
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionCreateManySurveyQuestionInput = {
    surveyId: number
    displayOrder?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionOptionCreateManySurveyQuestionInput = {
    id?: number
    label: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerCreateManySurveyQuestionInput = {
    id?: number
    responseId?: string | null
    customerId: number
    answerSingleOptionId?: number | null
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionUpdateWithoutSurveyQuestionInput = {
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutIntermediateSurveyQuestionsInput
  }

  export type IntermediateSurveyQuestionUncheckedUpdateWithoutSurveyQuestionInput = {
    surveyId?: IntFieldUpdateOperationsInput | number
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionOptionUpdateWithoutSurveyQuestionInput = {
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutAnswerOptionInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionUncheckedUpdateWithoutSurveyQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutAnswerOptionInput
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionOptionInput
  }

  export type SurveyQuestionOptionUncheckedUpdateManyWithoutSurveyQuestionOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionAnswerUpdateWithoutSurveyQuestionInput = {
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionAnswerInput
    customer?: CustomersUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    answerOption?: SurveyQuestionOptionUpdateOneWithoutSurveyQuestionAnswerInput
    product?: ProductUpdateOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedUpdateWithoutSurveyQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    answerSingleOptionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionCreateManyQuestionCategoryInput = {
    id?: number
    name: string
    label: string
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    surveyQuestionAnswerTypeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionUpdateWithoutQuestionCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionAnswerType?: SurveyQuestionAnswerTypeUpdateOneRequiredWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutQuestionCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionAnswerTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    surveyQuestionAnswerTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionCreateManySurveyQuestionAnswerTypeInput = {
    id?: number
    name: string
    label: string
    questionCategoryId: number
    mustBeAnswered: boolean
    instruction?: string | null
    placeholder?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionUpdateWithoutSurveyQuestionAnswerTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionCategory?: QuestionCategoryUpdateOneRequiredWithoutSurveyQuestionsInput
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutSurveyQuestionAnswerTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    questionCategoryId?: IntFieldUpdateOperationsInput | number
    mustBeAnswered?: BoolFieldUpdateOperationsInput | boolean
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestions?: IntermediateSurveyQuestionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionOptions?: SurveyQuestionOptionUncheckedUpdateManyWithoutSurveyQuestionInput
    surveyQuestionAnswer?: SurveyQuestionAnswerUncheckedUpdateManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionAnswerCreateManyAnswerOptionInput = {
    id?: number
    responseId?: string | null
    customerId: number
    surveyQuestionId: number
    answerNumeric?: number | null
    answerText?: string | null
    answerBool?: boolean | null
    reason?: string | null
    title?: string | null
    content?: string | null
    answerCount?: number | null
    productId?: number | null
    orderNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionOptionInput = {
    surveyQuestionAnswerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SurveyQuestionAnswerUpdateWithoutAnswerOptionInput = {
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUpdateManyWithoutSurveyQuestionAnswerInput
    customer?: CustomersUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyQuestionAnswerInput
    product?: ProductUpdateOneWithoutSurveyQuestionAnswerInput
  }

  export type SurveyQuestionAnswerUncheckedUpdateWithoutAnswerOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    responseId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: IntFieldUpdateOperationsInput | number
    surveyQuestionId?: IntFieldUpdateOperationsInput | number
    answerNumeric?: NullableIntFieldUpdateOperationsInput | number | null
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    answerBool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    answerCount?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intermediateSurveyQuestionAnswerProduct?: IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutSurveyQuestionAnswerInput
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateWithoutSurveyQuestionOptionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionAnswer?: SurveyQuestionAnswerUpdateOneRequiredWithoutIntermediateSurveyQuestionAnswerProductInput
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedUpdateWithoutSurveyQuestionOptionInput = {
    surveyQuestionAnswerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedUpdateManyWithoutIntermediateSurveyQuestionAnswerProductInput = {
    surveyQuestionAnswerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductCreateManySurveyQuestionAnswerInput = {
    surveyQuestionOptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediateSurveyQuestionAnswerProductUpdateWithoutSurveyQuestionAnswerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestionOption?: SurveyQuestionOptionUpdateOneRequiredWithoutIntermediateSurveyQuestionAnswerProductInput
  }

  export type IntermediateSurveyQuestionAnswerProductUncheckedUpdateWithoutSurveyQuestionAnswerInput = {
    surveyQuestionOptionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerBoxCreateManyPractitionerInput = {
    id?: number
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerBoxUpdateWithoutPractitionerInput = {
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUpdateManyWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUpdateManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedUpdateWithoutPractitionerInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    practitionerCustomerOrderHistory?: PractitionerCustomerOrderHistoryUncheckedUpdateManyWithoutPractitionerBoxInput
    intermediatePractitionerBoxProduct?: IntermediatePractitionerBoxProductUncheckedUpdateManyWithoutPractitionerBoxInput
  }

  export type PractitionerBoxUncheckedUpdateManyWithoutPractitionerBoxInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PractitionerCustomerOrderHistoryCreateManyPractitionerBoxInput = {
    id?: number
    customerId: number
    orderNumber: string
    purchasePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntermediatePractitionerBoxProductCreateManyPractitionerBoxInput = {
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PractitionerCustomerOrderHistoryUpdateWithoutPractitionerBoxInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutPractitionerCustomerOrderHistoryInput
  }

  export type PractitionerCustomerOrderHistoryUncheckedUpdateWithoutPractitionerBoxInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    purchasePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntermediatePractitionerBoxProductUpdateWithoutPractitionerBoxInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutIntermediatePractitionerBoxProductInput
  }

  export type IntermediatePractitionerBoxProductUncheckedUpdateWithoutPractitionerBoxInput = {
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}